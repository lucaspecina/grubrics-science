Goal,Rubric,Reference solution,article_id,q_id,Subdomain,Category,Identifier
"You are developing a machine learning model for a complex scientific application, and you need to optimize its hyperparameters. The model has a mix of discrete and continuous hyperparameters, and you have limited computational resources. Your goal is to find the optimal hyperparameter configuration efficiently. Describe your strategy for hyperparameter tuning.","['The strategy involves using a hyperparameter tuning framework (e.g., Ray Tune).'
 'The approach employs grid search for discrete hyperparameters.'
 'Random search is used for continuous hyperparameters.'
 'The strategy allows for parallel training of models across different hyperparameter configurations.'
 'The approach is designed to be computationally efficient.'
 'The method automatically detects and leverages available computational resources (e.g., GPU acceleration).'
 'The strategy is designed to be flexible and adaptable to different model architectures.'
 'The method does not require manual tuning of hyperparameters.'
 'The strategy is designed to balance exploration of the hyperparameter space with computational efficiency.'
 'The approach can handle high-dimensional hyperparameter spaces.']","To optimize the hyperparameters of a complex machine learning model efficiently, we will employ the hyperparameter tuning framework used in GenAI4UQ, which leverages the Ray Tune platform. This approach is chosen for its ability to efficiently explore the hyperparameter space and adapt to available computational resources.

First, we identify the hyperparameters to be tuned, categorizing them as either discrete or continuous. Discrete hyperparameters, such as the number of nodes, number of layers in the fully connected neural network, and batch size, will be optimized using grid search. This method systematically explores the predefined set of values for these parameters, ensuring that all possible combinations are considered.

For continuous hyperparameters like learning rate and dropout rate, we will utilize random search. This approach samples parameter values from a uniform distribution, allowing for a more flexible and efficient exploration of the hyperparameter space, particularly in high-dimensional scenarios.

The Ray Tune framework enables parallel training of models across different hyperparameter configurations, significantly expediting the tuning process. It automatically detects and leverages available computational resources, preferentially using GPU acceleration when available and transitioning to multi-core CPU processing otherwise.

We will use the default hyperparameter ranges provided by the framework as a starting point. These defaults include a learning rate sampled from a logarithmic uniform distribution between $10^{-4}$ and $10^{-2}$, the number of neurons per layer chosen from [32, 64, 128], and one or two hidden layers. Additional settings include a dropout rate sampled uniformly between 0.01 and 0.3, batch sizes of either 32 or 64, and a maximum of 1000 epochs for training.

To ensure flexibility and adaptability to specific research requirements, we allow for customization of the hyperparameter search space. Users can adjust the number of trials, search space, and exploration strategies according to their needs.

The optimal hyperparameter configuration will be automatically saved for reproducibility. This configuration is determined based on the performance of the model on a validation dataset, using metrics such as validation loss.

To prevent overfitting, we implement a comprehensive early stopping mechanism. This involves monitoring the validation loss and stopping the training process when the loss stops improving beyond a predefined minimum delta threshold. Additionally, a generalization gap metric is used to detect potential overfitting by quantifying the difference between training and validation losses.

The hyperparameter tuning process is fully integrated into the model development workflow, ensuring seamless optimization and evaluation of the model. By leveraging the Ray Tune framework and implementing a combination of grid search and random search, we achieve a balance between exploration of the hyperparameter space and computational efficiency.

This approach is designed to be flexible and adaptable to different model architectures and suitable for users with varying levels of machine learning expertise. It eliminates the need for manual tuning of hyperparameters, making it an efficient and user-friendly solution for optimizing complex machine learning models.",950b80d2ce6144ab,7d7a19a931889f49,cs,cs.LG,2412.07026
"You are working on a data analytics project that requires releasing accurate counts from a large dataset while ensuring differential privacy. The dataset contains user information, and each user can contribute multiple distinct elements. Your goal is to develop a method that can release as many accurate counts as possible without relying on user contribution bounds over distinct elements (ℓ0-sensitivity bounds), which can be a significant source of bias. You need to design an approach that balances accuracy and privacy without requiring extensive hyperparameter tuning. Describe your plan to achieve this.","['The solution does not rely on user contribution bounds over distinct elements (ℓ0-sensitivity bounds).'
 'The approach uses a mechanism to iteratively find the highest counts in the dataset.'
 'The solution is designed to release as many accurate counts as possible.'
 'The approach balances accuracy and privacy.'
 'The method minimizes the need for hyperparameter tuning.'
 'The solution is applicable to large datasets.'
 'The approach handles datasets where users can contribute multiple distinct elements.'
 'The solution is robust to variations in dataset size and user contributions.'
 'The method is designed to work with minimal assumptions about the data distribution.'
 'The method provides a clear trade-off between accuracy and privacy.']","To develop a method that releases accurate counts from a large dataset while ensuring differential privacy, we will follow the Private Count Release (PCR) approach. This method does not rely on user contribution bounds over distinct elements, i.e., ℓ0-sensitivity bounds, which can be a significant source of bias.

First, we create a histogram over all possible items in the dataset with their corresponding counts. We assume that a user can contribute to a single count by at most 1 (ℓ∞-sensitivity is 1) but can modify as many counts as the maximum possible number of counts, k̄. This is achieved by running a distinct count aggregate function by a user ID column and ordering by the distinct counts in descending order up to k̄.

Next, we utilize the Unknown Domain Gumbel mechanism to iteratively find the highest counts in the dataset. The Unknown Domain Gumbel algorithm takes parameters such as the maximum number of items to return (k) and the total ranked counts (k̄ > k). We start with a very small privacy parameter ε1 and use the Unknown Domain Gumbel algorithm to find the top-1 query. If the algorithm returns ⊥, indicating that the threshold is too high, we increase ε1 to ε2 = 2ε1 and repeat the process until we get an element that is not ⊥.

Once we have selected a non-⊥ element, we use the Gaussian Mechanism to add noise to the count of the discovered element. The noise level is determined based on the target relative error (r) and the current εi. We calculate the standard deviation of the noise, σ(εi), such that the released count has a relative error less than or equal to r.

We continue this process, accumulating the privacy losses, until we have exhausted the given privacy budget (ρ, δ). The overall privacy guarantee is ensured by the privacy filters, which allow us to adaptively select the privacy parameters while maintaining the overall privacy budget.

The PCR approach is designed to release as many accurate counts as possible while balancing accuracy and privacy. It minimizes the need for hyperparameter tuning by fixing parameters such as ε∗, δ∗, and k̄ across different datasets. The method is applicable to large datasets and can handle datasets where users can contribute multiple distinct elements.

The solution is robust to variations in dataset size and user contributions, as demonstrated by the experiments on various real-world datasets. The approach does not require extensive preprocessing of the data and is designed to work with minimal assumptions about the data distribution.

By using the Unknown Domain Gumbel mechanism and the Gaussian Mechanism, we ensure differential privacy for the released counts. The method provides a clear trade-off between accuracy and privacy, allowing for adjustments to be made based on the specific requirements of the use case.

Overall, the Private Count Release approach provides a simple, scalable, and expressive framework for releasing accurate counts with differential privacy, making it suitable for various data analytics applications.",ed2a903f6974f98c,2572a05c6e2167e1,cs,cs.CR,2403.05073
"You are tasked with investigating the relationship between model sparsity and generalization performance in neural networks. Specifically, you need to design an experiment to study how increasing model sparsity affects test performance in a two-layer neural network trained on the MNIST dataset. The network's representation dimension and L1 regularization strength are variables that can be manipulated. Your goal is to identify and explain any non-monotonic behavior in test performance as model sparsity increases. Propose a research plan to explore this phenomenon, including the experimental design, variables to be measured, and potential confounding factors to control.","['The research plan includes an experimental design that varies model sparsity in a two-layer neural network.'
 'The representation dimension is considered as a variable in the experimental design.'
 'The plan measures test performance as the primary outcome variable.'
 'The plan includes controls for confounding factors that could influence the relationship between model sparsity and test performance.'
 'The experimental design allows for the observation of the sparse double descent phenomenon.'
 'The plan involves analyzing the effect of increasing model sparsity on test performance.'
 'The research plan is based on a clear understanding of the relationship between model complexity, sparsity, and generalization.'
 'The plan does not assume a monotonic relationship between model sparsity and test performance.'
 'The plan includes a clear description of how model sparsity will be measured or induced.'
 'The research plan considers the potential impact of representation dimension on the sparse double descent phenomenon.']","To investigate the relationship between model sparsity and generalization performance in neural networks, we will design an experiment to study how increasing model sparsity affects test performance in a two-layer neural network trained on the MNIST dataset. 

The experiment involves training a two-layer multilayer perceptron with ReLU non-linearity on the MNIST dataset using stochastic gradient descent. We will modify two components of the training procedure: the regularization coefficient α and the intermediate layer's dimension, referred to as the kernel dimension. 

We will vary the coefficient of the L1 regularizer (α) to observe the sparse double descent phenomenon for all choices of the number of intermediate neurons. The L1 penalty inductively biases the network to learn parametrizations that are sparse and well-generalizing. By increasing α, we place heavier emphasis on sparsity when training the neural network.

The kernel dimension is another variable we will manipulate. By varying this, we are essentially changing the learned kernel's intrinsic dimension. We will train separate neural networks with varying α for each kernel dimension.

The primary outcome variable we will measure is test performance. We expect to observe non-monotonic behavior in test performance as model sparsity increases. Specifically, we are looking for the sparse double descent phenomenon, where test performance first decreases, then increases, and finally decreases again as sparsity approaches 100%.

To capture this phenomenon, we will train neural networks with different kernel dimensions (5, 10, 25, 50, 75, and 100 intermediate neurons) and varying α values. For each combination of kernel dimension and α, we will measure the test performance.

The experimental design allows us to control for potential confounding factors. By keeping the neural network architecture fixed (two-layer multilayer perceptron with ReLU non-linearity) and only varying the kernel dimension and α, we can isolate the effects of model sparsity on test performance.

Our plan is based on the understanding that the relationship between model complexity, sparsity, and generalization is complex. We do not assume a monotonic relationship between model sparsity and test performance, and instead, we are prepared to observe the sparse double descent phenomenon.

The sparse double descent phenomenon, if observed, could challenge conventional understanding of model sparsity and generalization. By analyzing the effect of increasing model sparsity on test performance and considering the potential impact of representation dimension on this phenomenon, we aim to contribute to a deeper understanding of neural network training and optimization.

To execute this plan, we will utilize the code available at https://github.com/yashizhang/sparsedoubledescent, which is associated with the research paper that this experiment is based on. This code will enable us to efficiently implement the experimental design and analyze the results.

By following this research plan, we will be able to identify and explain any non-monotonic behavior in test performance as model sparsity increases, providing insights into the complex relationship between model sparsity and generalization performance in neural networks.",6baf3ea32e4d2f87,a02273a718b3d887,cs,cs.LG,2401.10686
"You are tasked with developing a novel linguistic analysis framework that can capture the nuances of natural language structures. Your goal is to create a system that can analyze expressions by composing functions in a way that maintains dependency, similar to the concept of monads in category theory. The system should be able to handle linguistic structures in a hierarchical manner, building structures from sequential asymmetries alone. You need to devise a method that turns traditional categorial grammar application into composition, ensuring that every analytic step is atomic. How would you approach this task, and what would be the key components of your framework?","['The proposed framework turns traditional categorial grammar application into composition.'
 'The framework ensures that every analytic step is atomic, maintaining the hermetic seal.'
 'The approach builds hierarchical structures from sequential asymmetries alone.'
 'The response discusses the importance of maintaining dependency between functions in linguistic analysis.'
 'The proposed framework is novel and differs from traditional categorial grammar.'
 'The framework is designed to handle linguistic structures in a hierarchical manner.'
 'The response discusses the implications of the monadic analysis for linguistic theory.'
 'The framework is capable of capturing the nuances of natural language structures.'
 'The response provides a clear plan for implementing the proposed framework.'
 'The response demonstrates an understanding of the limitations and potential challenges of the proposed framework.']","To develop a novel linguistic analysis framework that captures the nuances of natural language structures by composing functions in a way that maintains dependency, similar to the concept of monads in category theory, we will follow the approach outlined in the document ""THE BENCH Guide"" by Cem Bozşahin.

First, we will utilize the concept of monads to compose two functions, f and g, to maintain the dependency of f on g, written as λx. f (gx), by doing g ◦ f. This ensures that the head function, f, is always the ultimate element in the composition. We will implement this using the T HE B ENCH tool, which is designed to study monadic structures in natural language.

The framework will be based on old-school categorial grammar, but with a twist: application will be turned into composition. This means that both applications in a traditional categorial grammar analysis will be replaced with function composition in the template of λz. f (gz), where f is the head function. For example, the analysis of ""Sincerity admires John"" will be transformed into a compositional analysis where the verb ""admires"" is the head function.

To achieve this, we will define a set of elementary items, asymmetric relational rules, and symmetric relational rules in T HE B ENCH notation. Elementary items will bear categories that are functions of their phonological form, comprising a syntactic type and a predicate-argument structure. Asymmetric relational rules will map a surface category to another surface category, indicating that the surface form bearing the first category also bears the second category.

The framework will maintain two command relations: surface command (s-command) and predicate-argument command (l-command). S-command will specify the order and directionality of an element's syntactic arguments, while l-command will specify the order and dominance of the predicate-argument structure. The pairing of these two command relations will be required in the monadic grammar.

To explore the monadic analytic structures, we will use the 'c command' in T HE B ENCH to generate case functions from the verbs and verb-like elements of a grammar. These case functions will be asymmetric relational rules that show the understanding that if we have one category for an argument in an expression, we also have other categories for the argument.

We will also use the 'k command' to preview the syntactic skeleton of a grammar, reporting the distinct syntactic categories and enumerating the list of elements that bear each category. This will help identify patterns in the grammar's categories and understand why some categories are distinct.

For modeling, we will turn the textual form of T HE B ENCH grammar into a set of data points associated with parameters. We will use the 'z command' to transform the grammar into a 'source form', a C OMMON L ISP data structure, and then into a re-textualized grammar with added parameter values.

Training a grammar with data will update the parameters, which can then be used for ranking analyses. We will use the sequence learning method of Zettlemoyer and Collins (2005) to train the grammar. Supervision pairs will be correspondences of phonological forms and their correct predicate-argument structures.

To implement the proposed framework, we will follow the three work cycles outlined in the document: (1) development of an analysis by checking its aspects with respect to theoretical assumptions, (2) studying a grammatical analysis in its full implications for surface structure when the class of verbs is large enough, and (3) training a grammar to see how it affects ranking of analysis.

The output of the framework will be a set of analyses for a given expression, with the most likely analysis ranked highest. The framework will be capable of capturing the nuances of natural language structures by building hierarchical structures from sequential asymmetries alone.

By following this approach, we will develop a novel linguistic analysis framework that maintains the hermetic seal of monadic analysis, ensuring that every analytic step is atomic and composable. The framework will be designed to handle linguistic structures in a hierarchical manner, building structures from sequential asymmetries alone, and will be based on the principles of category theory.",dc45799f4bd2f25f,405a9a09f43bb27c,cs,cs.CL,2406.01372
"You are working on a collaborative virtual reality (VR) framework for inspecting digital twins (DTs) of additive manufacturing (AM) parts. The DTs include large-scale X-ray CT scans, which are challenging to manage and share among collaborators. Your goal is to design a data management and streaming approach that enables real-time inspection and collaboration. The approach should allow for flexible data querying, filtering, and cropping, as well as support for multi-resolution data. How would you approach this challenge?","['The proposed data management approach should be able to handle large-scale volumetric data.'
 'The technique should enable real-time streaming of volumetric data.'
 'The method should support flexible data querying, filtering, and cropping.'
 'The approach should allow for multi-resolution data streaming.'
 'The technique should be implemented using a client-server architecture for collaborative VR.'
 'The proposed approach should support multithreading for background computations.'
 'The technique should maintain VR rendering performance while streaming large datasets.'
 'The approach should be designed to minimize latency and ensure smooth data streaming.'
 'The proposed method should be scalable to support multiple users and large datasets.'
 'The data management and streaming approach should be integrated with other components of the collaborative VR framework.']","To address the challenge of designing a data management and streaming approach for real-time inspection and collaboration of digital twins (DTs) of additive manufacturing (AM) parts, we propose a comprehensive framework that leverages collaborative virtual reality (VR) and advanced data management techniques.

First, we utilize OpenViSUS for efficient querying and managing large-scale volumetric data, such as X-ray CT scans. OpenViSUS is a data management tool that allows for flexible data streaming, filtering, cropping, and multi-resolution data query. This is crucial for handling the massive datasets generated by CT scans and ensuring interactive inspection.

We implement a client-server architecture for the collaborative VR environment using Photon Unity Networking. This approach provides a stable and secure solution for network communication, avoids common connection issues associated with peer-to-peer approaches, and allows for real-time synchronization among users.

To support the massive computations required for data streaming and management, we incorporate multithreading. This enables background computations to be processed while maintaining the computational logic for VR rendering on the main thread, thus ensuring smooth VR performance.

The framework is designed to stream multi-resolution volumetric data remotely during runtime. By utilizing OpenViSUS, datasets are stored on a server and can be streamed with a developed WebAPI to provide flexible data streaming. This allows for instant retrieval of subsampled versions or high-resolution subspaces of the data, guaranteeing interactive inspection.

For occlusion management and volumetric rendering, we enhance UnityVolumeRendering to compute and visualize volumetric data in Unity. We adapt and integrate transfer functions and color mapping to improve occlusion and lighting management in VR. Additionally, we implement cutting geometries, such as cross-section planes, box, and sphere cutouts, to provide a flexible adjustment of visibility and inspect inner structures of volumetric data.

The framework supports multi-user collaboration through real-time synchronization, enabling geographically distributed users to jointly explore and inspect DT representations in a shared virtual environment. Features such as drawing annotations, virtual whiteboard, and personalized user avatars enhance team communication and discussion.

To evaluate the effectiveness of the proposed framework, we conduct exploratory and semi-structured interviews with domain experts in AM. The results demonstrate the usability, applicability, and potential benefits of the framework in enhancing the inspection process of AM DTs.

The proposed framework is designed to be scalable, secure, and reliable, with consideration for future extensions to other data types. By minimizing latency and ensuring smooth data streaming, the framework provides a powerful tool for real-time collaboration and inspection of complex AM parts.

The key components of the framework include:
1. **Data Management**: Utilizing OpenViSUS for efficient querying and managing large-scale volumetric data.
2. **Client-Server Architecture**: Implementing Photon Unity Networking for a stable and secure collaborative VR environment.
3. **Multithreading**: Supporting background computations while maintaining VR rendering performance.
4. **Multi-Resolution Data Streaming**: Streaming volumetric data remotely during runtime with flexible data querying and filtering.
5. **Occlusion Management and Volumetric Rendering**: Enhancing UnityVolumeRendering with transfer functions, color mapping, and cutting geometries.
6. **Multi-User Collaboration**: Enabling real-time synchronization and team communication features.

By integrating these components, the proposed framework addresses the challenges associated with inspecting DTs of AM parts and provides a new benchmark for emerging DTs inspection methods.",791e1b4583c5c1fc,590455562c5597f1,cs,cs.HC,2405.12931
"You are conducting an empirical study to understand the prevalence and distribution of test smells in open-source C# projects that use the xUnit testing framework. 
    You have access to a large number of GitHub projects and a tool (xNose) capable of detecting test smells in C# code. 
    Your goal is to analyze the frequency and co-occurrence of different test smells across these projects, 
    and to identify any patterns or correlations that could inform best practices for test suite design and maintenance. 
    You need to select a representative dataset of C# projects, run the xNose tool on these projects, 
    and analyze the results to draw meaningful conclusions about test smell prevalence and co-occurrence. 
    How would you conduct this empirical study?","['The study selects a large and representative dataset of open-source C# projects from GitHub.'
 'The selected projects use the xUnit testing framework.'
 'The xNose tool is used to detect test smells in the selected projects.'
 'The study analyzes the frequency of different test smells across the projects.'
 'The study examines the co-occurrence of different test smells within test suites.'
 'The study identifies the most common and least common test smells in the C# projects.'
 'The analysis considers the granularity of test smells (e.g., test suite level vs. test case level).'
 'The study discusses the implications of the findings for test suite design and maintenance.'
 'The study acknowledges potential threats to validity and discusses measures taken to mitigate them.'
 'The analysis includes an examination of the distribution of test smells among projects.']","To conduct an empirical study on the prevalence and distribution of test smells in open-source C# projects that use the xUnit testing framework, we will follow a structured research plan.

First, we need to select a representative dataset of C# projects from GitHub. To achieve this, we will use the GitHub advanced search option to identify relevant projects. The search query will be framed to retrieve projects with a significant number of stars, using the xUnit testing framework, and having an MIT license. The query will be: ""topic: xUnit language: C# license: mit"" and the results will be sorted by ""Most Stars"". We will then manually review the top 200 projects to ensure they meet our criteria, specifically that they contain test code written using the xUnit testing framework.

Next, we will utilize the xNose tool, which is capable of detecting 16 distinct test smells in C# code that uses the xUnit framework. xNose is implemented as a Visual Studio extension and uses Roslyn APIs to parse C# source code and build syntactic and semantic code models for further analysis. We will run xNose on the selected projects to detect test smells.

After detecting test smells, we will analyze the frequency and co-occurrence of different test smells across the projects. We will examine the distribution of test smells at different levels of granularity, including test suite and test case levels. This will involve calculating the percentage of test suites that contain at least one test smell and identifying the most common and least common test smells.

To gain a deeper understanding of test smell prevalence, we will also investigate how test smells co-occur within test suites. This will involve calculating the percentage of test suites that exhibit multiple test smells and examining the relationships between different test smells.

The analysis will be performed on a dataset of 200 open-source C# projects, which will provide a robust understanding of test smell prevalence in C# code. We will also compare our findings with existing studies on test smells in other programming languages, such as Python, to identify any similarities or differences.

To ensure the integrity of our study, we will acknowledge potential threats to validity and discuss measures taken to mitigate them. One potential limitation is that our study relies on a specific set of open-source C# projects, which may not be representative of all C# projects. Additionally, the detection of certain test smells relies on thresholds established in previous research, which may not be optimal for C#.

Finally, we will make the dataset used for the study available for future research, along with detailed statistics about the number of test projects, test suites, and test cases analyzed. This will facilitate further studies on test smells in C# and enable the research community to build upon our findings.

By following this research plan, we aim to provide a comprehensive understanding of test smell prevalence and distribution in open-source C# projects that use the xUnit testing framework. Our findings will have implications for test suite design and maintenance, and will contribute to the development of best practices for C# testing.",fa5a8a06a4c4e484,4078c8f31e5ba811,cs,cs.SE,2405.04063
You are analyzing the performance of a novel visually grounded language learning model that has shown improvements in language modeling and word learning tasks. The model leverages visual information to enhance textual representations. You observe that the model performs better on concrete words than on abstract words in terms of human-likeness of the learned representations. Your task is to understand why this is the case and to speculate on the implications for developing more comprehensive language models. The key uncertainty is whether the concreteness-based bias is due to the nature of the visual grounding or the training data.,"['The analysis involves comparing the performance of the visually grounded model on concrete vs. abstract words.'
 'The performance metric includes assessing the human-likeness of the learned word representations.'
 'The difference in performance is related to the concreteness of the words.'
 'Concreteness is measured using a pre-existing concreteness rating dataset.'
 'The analysis suggests that visual grounding benefits the learning of concrete words more.'
 'The implication is that the model may need additional mechanisms to effectively learn abstract concepts.'
 'The performance difference between the visually grounded and language-only models is analyzed.'
 'The words are grouped by their concreteness scores for the analysis.'
 'The results have implications for understanding the limitations of the current visually grounded language learning approach.'
 'The findings suggest directions for future research to develop more comprehensive language models.']","To address the scenario, we need to understand why the LexiContrastive Grounding (LCG) model performs better on concrete words than on abstract words in terms of human-likeness of the learned representations. We will investigate whether this concreteness-based bias is due to the nature of the visual grounding or the training data.

First, we will analyze the performance of the LCG model on the word-relatedness benchmark. We will calculate the Spearman correlation between the model's outputs and human evaluations for both concrete and abstract words. To do this, we will use a pre-existing concreteness rating dataset (Brysbaert et al., 2014) to categorize words based on their concreteness scores.

Next, we will examine the difference in performance between the LCG model and the Language-Only model on concrete and abstract words. We will calculate the per-word prediction performance across a test set and compare the performance difference between the two models for each word. We will then group the words by their concreences scores to investigate whether the performance difference is related to the concreteness of the words.

Furthermore, we will analyze the results of the LCG model on the SimVerb-3500 benchmark, which evaluates the model's performance on verb words. This will help us understand whether the visual grounding using static images benefits the learning of verbs.

To validate the algorithm design of LCG, we will perform ablation studies on the algorithm and compare the performance of the ablated algorithms to the original performance on the word-learning benchmarks.

The analysis will be performed on models trained in a mixed learning scenario, where the models are co-trained on image-caption and language-only datasets. We will vary the size of the training datasets and the source of the ungrounded corpus to investigate the robustness of the findings.

The results of this analysis will have implications for understanding the limitations of the current visually grounded language learning approach. The findings will suggest directions for future research to develop more comprehensive language models, such as augmenting the LCG algorithm to better learn abstract words or adjusting the training corpus to better represent the distribution of words humans learn.

The study will utilize the LCG model and other visual-language learning algorithms, including CLIP, GIT, Flamingo, and Vokenization. The models will be trained on the Conceptual-Captions-12M dataset and evaluated on various word-learning benchmarks, including Word Relatedness, Semantic Feature Prediction, Lexical Relation Prediction, and Context Understanding.

The computational resources required for this study include A100 GPUs, with each model having around 70M trainable parameters. The training of all models will take around 2400 GPU hours.

By following this research plan, we will gain insights into the concreteness-based bias in the LCG model and its implications for developing more comprehensive language models.",15aa625ea9ee3713,7de6d25de798f924,cs,cs.CL,2403.14551
"You are tasked with developing a framework to quantify musicality scores based on EEG responses to auditory stimuli. The goal is to evaluate machine-composed music using EEG data and compare it with human-composed music. You need to propose a model that can distinguish between different levels of musicality (e.g., human-composed music, partially randomized music, and random noise sequences) using EEG signals. The model should minimize inter-subject variance while preserving the ranking of musicality scores. You have access to EEG data recorded from subjects listening to various types of music and noise sequences.","['The proposed model should be a bilinear model that quantifies musicality scores based on EEG responses.'
 'The solution should involve optimizing projection vectors to minimize inter-subject variance.'
 'The model should preserve the ranking of musicality scores across different types of auditory stimuli.'
 'The approach should identify the most influential EEG frequency bands in distinguishing musicality.'
 'The solution should include a clear mathematical formulation of the bilinear model.'
 'The method should be evaluated based on its ability to distinguish between different levels of musicality.'
 'The solution should be robust to variations in EEG signals across different subjects.'
 'The solution should include a plan for testing its effectiveness using relevant metrics or benchmarks.'
 'The approach should provide insights into the neural basis of musical perception.'
 'The proposed model should be applicable to other types of auditory stimuli or cognitive tasks.']","To develop a framework for quantifying musicality scores based on EEG responses to auditory stimuli, we employ a bilinear model. This model aims to evaluate machine-composed music by comparing EEG data recorded from subjects listening to various types of music and noise sequences.

First, we extract EEG features from the recorded data. The EEG signals are processed to identify the most relevant frequency bands that distinguish between different levels of musicality. Research indicates that the Gamma band (> 30 Hz) is particularly influential in distinguishing musicality, as it is associated with emotional and auditory processing. Additionally, the inclusion of DC components significantly enhances model performance, suggesting that cortical activation patterns play a crucial role in musical perception.

The bilinear model is formulated as follows:
\[ f(X_m^s) = w_1^\top X_m^s w_2 + b \]
where \(X_m^s\) is the EEG feature matrix for subject \(s\) and stimulus \(m\), and \(w_1\) and \(w_2\) are projection vectors optimized to minimize inter-subject variance while preserving the ranking of musicality scores. The model is designed such that human-composed music (HCM) scores highest, random noise sequences (RNS) score lowest, and partially randomized music (PRM) occupies intermediate scores.

To optimize the projection vectors \(w_1\) and \(w_2\), we use a dataset of EEG recordings from subjects listening to HCM, PRM, and RNS. The optimization process involves minimizing the inter-subject variance in musicality scores while maintaining the desired ranking. This ensures that the model is robust to variations in EEG signals across different subjects.

The effectiveness of the bilinear model is evaluated based on its ability to distinguish between different levels of musicality. We compare the model's performance with alternative methods for evaluating musicality, such as traditional subjective scoring methods. The model's performance is also assessed using relevant metrics, including its ability to correctly rank HCM, PRM, and RNS.

The proposed framework is feasible to implement given the available EEG dataset and resources. It is well-integrated with existing frameworks for EEG analysis, leveraging established techniques for EEG signal processing and feature extraction. The bilinear model's mathematical formulation provides a clear and concise description of the approach, highlighting its key components and benefits.

By applying this framework, we aim to provide insights into the neural basis of musical perception. The model's ability to quantify musicality scores based on EEG responses can help bridge the gap between artificial and human creativity, opening avenues for the development of more intuitive AI systems in multimedia applications. Furthermore, the approach can be applicable to other types of auditory stimuli or cognitive tasks, making it a versatile tool for neuroscience and AI research.

The solution involves the following steps:
1. EEG data collection: Record EEG data from subjects listening to HCM, PRM, and RNS.
2. EEG feature extraction: Process EEG signals to extract relevant features, focusing on the Gamma band and DC components.
3. Bilinear model formulation: Formulate the bilinear model to quantify musicality scores based on EEG responses.
4. Optimization: Optimize the projection vectors \(w_1\) and \(w_2\) to minimize inter-subject variance while preserving the ranking of musicality scores.
5. Evaluation: Evaluate the model's performance using relevant metrics and compare it with alternative methods.
6. Analysis: Analyze the results to provide insights into the neural basis of musical perception and the effectiveness of the proposed framework.

This approach is justified by relevant theoretical and empirical evidence from the literature, which highlights the importance of EEG frequency bands and cortical activation patterns in musical perception. By following this plan, we can develop a robust and effective framework for evaluating musicality using EEG data.",5cf15fc6d43c0dd0,a4e07be028d86e69,cs,cs.CV,2412.19999
"You are working on a project to improve the robustness of deep neural networks (DNNs) for image classification tasks under distribution shifts. The DNNs are prone to overfitting when the test data distribution deviates from the training data distribution. You have access to a knowledge graph (KG) that contains hierarchical and association relationships between object categories and their elements, as well as the ability to generate synthetic images of object category elements. Propose a novel approach to leverage this multi-modal prior knowledge to enhance the generalization ability of DNNs.","['The proposed approach integrates multi-modal prior knowledge from both a knowledge graph (KG) and synthetic images.'
 'The method aligns image embeddings and knowledge graph embeddings (KGEs) in a common latent space.'
 'The approach regularizes the latent space to prevent overfitting.'
 'The method is designed to be end-to-end, combining regularization loss and cross-entropy loss.'
 'The approach is evaluated on image classification tasks under distribution shifts.'
 'The method is tested on multiple datasets to demonstrate its effectiveness.'
 'The approach is compared with baseline models to show its superiority.'
 'The use of synthetic images is justified as a means to augment the dataset.'
 'The construction of the KG is based on domain knowledge and includes relevant relations.'
 'The proposed method is adaptable to different domains and datasets.']","To address the scenario of improving the robustness of deep neural networks (DNNs) for image classification tasks under distribution shifts, we propose a novel approach that leverages multi-modal prior knowledge. This approach is based on the Knowledge-Guided Visual representation learning (KGV) method.

### Step 1: Knowledge Modeling
First, we construct a knowledge graph (KG) that captures factual knowledge such as hierarchical and association relations across different data distributions. The KG represents object categories, object category elements, and the relationships between them. For instance, in the road sign recognition domain, the KG includes categories like 'road sign' and 'road sign feature', with relations such as 'has the shape of', 'has the sign legend of', 'has the background color of', and 'has the border color of'. We also generate synthetic images of object category elements (e.g., shapes, colors, sign legends) that are semantically represented in the KG but lack visual information in the dataset.

### Step 2: Embedding Generation
We generate embeddings for images, nodes, and relations in the KG. Image embeddings are obtained using an image encoder network, while node and relation embeddings are learned using a variant of translation-based knowledge graph embedding (KGE) methods. Specifically, we represent object categories in the KG as Gaussian embeddings in the latent space to capture uncertainty and variability.

### Step 3: Alignment of Embeddings
We align the image embeddings and KGEs in a common latent space using our novel variant of translation-based KGE methods. The score function is designed to maximize the score for positive triplets (i.e., true facts in the KG) and minimize it for negative triplets (i.e., corrupted triples). The score function is based on the Gaussian representation of nodes, defined as $s(z_I, z_i^r, z_j^o) = N(z_I + z_i^r; \mu_j, \Sigma_j)$, where $z_I$ is the image embedding, $z_i^r$ is the relation embedding, and $z_j^o = (\mu_j, \Sigma_j)$ is the Gaussian node embedding.

### Step 4: Training
The training loss comprises two components: the cross-entropy loss for image classification and the regularization loss to align image embeddings with KGEs. The regularization loss is formulated as $L_{reg} = \frac{\sum_{i,j} M_{ij} \cdot S_{ij} + \sum_{i,j} (1 - M_{ij}) \cdot \max\{0, \epsilon - S_{ij}\}}{\sum_{i,j} M_{ij} + \sum_{i,j} (1 - M_{ij})}$, where $M$ is a mask tensor indicating positive and negative triplets, $S_{ij} = -\log(s(z_I, z_i^r, z_j^o))$, and $\epsilon$ is a threshold score difference. The total loss is $L = L_{CE} + \beta L_{reg}$, where $\beta$ is a hyperparameter balancing the two loss terms.

### Step 5: Evaluation
We evaluate KGV on various image classification tasks under distribution shifts, including road sign classification across datasets from Germany, China, and Russia, image classification with the mini-ImageNet dataset and its variants, and the DVM-CAR dataset. We compare KGV with baseline models, including ResNet50, CLIP+LP, DINOv2+LP, DGP, and GCNZ.

### Justification
The proposed KGV method is designed to leverage multi-modal prior knowledge to enhance the generalization ability of DNNs under data distribution shifts. By aligning image embeddings and KGEs in a common latent space, KGV regularizes the latent space to prevent overfitting. The use of Gaussian node embeddings and translation-based KGE methods allows the model to capture uncertainty and variability in the KG. The approach is end-to-end, combining regularization loss and cross-entropy loss, making it adaptable to different domains and datasets.

### Experimental Details
We will implement KGV using PyTorch and train the model on an NVIDIA A100 GPU with 80GB memory. The hyperparameters will be tuned based on the validation set performance. We will conduct ablation studies to analyze the impact of different components of KGV, such as the KG, synthetic images, and score function design.

By following this research plan, we aim to demonstrate the effectiveness of KGV in improving the robustness of DNNs for image classification tasks under distribution shifts. The results will provide insights into the benefits of leveraging multi-modal prior knowledge and the adaptability of KGV to different domains and datasets.",6c391ab0c47e3e37,d73333271f5c2d19,cs,cs.CV,2410.15981
You are tasked with developing an optimization algorithm for multi-task learning (MTL) that can handle conflicting gradients among tasks. The algorithm should be able to flexibly emphasize certain tasks based on different fairness criteria and have a theoretical convergence guarantee. You need to propose a novel optimization objective that solves the α-fair MTL utility maximization problem. Describe how you would implement this algorithm and what theoretical guarantees it provides.,"['The proposed algorithm should be named and clearly described.'
 'The algorithm should enable flexible emphasis on certain tasks based on different fairness criteria.'
 'The algorithm should have a theoretical convergence guarantee to a Pareto stationary point.'
 'The algorithm should be efficient and effective in handling conflicting gradients.'
 'The algorithm should be applicable to different MTL scenarios.'
 'The algorithm should be easy to implement.'
 'The theoretical analysis should include assumptions about the gradients of different tasks.'
 'The theoretical analysis should include assumptions about the loss functions.'
 'The algorithm should be compared with existing MTL optimization methods.'
 'The theoretical guarantees should be clearly stated and proven.']","To develop an optimization algorithm for multi-task learning (MTL) that can handle conflicting gradients among tasks and flexibly emphasize certain tasks based on different fairness criteria, we propose a novel algorithm named FairGrad. The algorithm is designed to solve the α-fair MTL utility maximization problem.

The α-fair MTL utility maximization problem is formulated by drawing an analogy between MTL and fair resource allocation in communication networks. In this context, the update direction d for all tasks is considered a resource to be allocated, and the loss decrease rate g i ⊤ d for each task i is viewed as the utility. The α-fair utility function for each task i is defined as (g i ⊤ d) 1−α /(1 − α), and the overall objective is to maximize the total utility across all tasks.

FairGrad solves the α-fair MTL utility maximization problem by determining the update direction d that maximizes the total utility. To achieve this, we first note that the optimal d lies on the boundary of the feasible set B ϵ , which is a ball centered at 0 with radius ϵ. Then, we derive the gradient of the overall objective with respect to d and show that it is aligned with d. By representing d as a linear combination of task gradients, d = P i w i g i , we obtain the equation G ⊤ Gw = w −1/α , where G is the matrix of task gradients, w is the vector of weights w i , and α is the fairness parameter.

To solve for w, we formulate a constrained nonlinear least square problem: min w ∥G ⊤ Gw − w −1/α ∥ 2 , subject to w ∈ R K + . This problem is solved efficiently using the scipy.optimize.least squares function.

The complete procedure of FairGrad is as follows:
1. Initialize model parameters θ 0 and set α and learning rate {η t }.
2. At each iteration t, compute task gradients G(θ t ).
3. Solve the constrained nonlinear least square problem to obtain w t .
4. Compute the update direction d t = G(θ t )w t .
5. Update model parameters θ t+1 = θ t − η t d t .

FairGrad has a theoretical convergence guarantee to a Pareto stationary point under mild assumptions. Specifically, we assume that the gradients of different tasks are linearly independent when not at a Pareto stationary point, and that the loss functions are differentiable and L-smooth.

The algorithm is efficient and effective in handling conflicting gradients, and it can capture different ideas of fairness by adjusting the value of α. For example, when α → 0, FairGrad reduces to Linear Scalarization; when α → 1, it corresponds to proportional fairness; and when α → ∞, it approaches max-min fairness.

To evaluate FairGrad, we conduct extensive experiments on various MTL benchmarks, including supervised learning and reinforcement learning tasks. We compare FairGrad with existing MTL optimization methods, such as Linear Scalarization, MGDA, PCGrad, CAGrad, Nash-MTL, and FAMO.

Furthermore, we investigate the effect of different fairness criteria on the performance of FairGrad by varying the value of α. We also apply the α-fair loss transformation to existing MTL methods and demonstrate that it can significantly improve their performance.

Theoretical analysis shows that FairGrad converges to a Pareto stationary point under mild assumptions. The convergence guarantee is provided by Theorem 7.3, which states that there exists a subsequence of the output sequence generated by FairGrad that converges to a Pareto stationary point.

In summary, FairGrad is a novel optimization algorithm for MTL that handles conflicting gradients and flexibly emphasizes certain tasks based on different fairness criteria. It solves the α-fair MTL utility maximization problem and has a theoretical convergence guarantee to a Pareto stationary point. The algorithm is efficient, effective, and easy to implement, making it a promising solution for various MTL applications.",42dbb9fb1ea5c6c9,9d94d5d1e3e33a2f,cs,cs.LG,2402.15638
"You are tasked with training a learned sparse retrieval (LSR) model to achieve superior performance on the BEIR benchmark. The model is based on a large language model (LLM), and you have the option to train it on various datasets. However, you are constrained by computational resources and cannot employ hard negative mining or distillation techniques. Your goal is to propose a training strategy that maximizes the model's performance on the BEIR benchmark under these constraints. You need to select an appropriate dataset and training methodology that can effectively leverage the LLM's capabilities.","['The solution proposes training the LSR model on a diverse dataset.'
 'The Sentence-Transformers embedding data is used for training the LSR model.'
 'The proposal includes a discussion on the importance of dataset diversity for LSR model generalization.'
 'The approach leverages the scale of the LLM to improve performance.'
 'The solution demonstrates an understanding of the trade-offs between different training strategies and dataset choices.'
 'The method is evaluated based on its zero-shot performance on the BEIR benchmark.'
 'The proposal includes a comparison with other potential training datasets or strategies.'
 'The solution discusses the potential benefits and limitations of the chosen training strategy.'
 'The approach is grounded in the specifics of how LSR models and LLMs operate.'
 'The proposal includes a clear plan for testing the effectiveness of the trained LSR model.']","To address the task of training a Learned Sparse Retrieval (LSR) model to achieve superior performance on the BEIR benchmark under the given constraints, we propose the following research plan.

First, we will utilize a large language model (LLM) as the backbone for our LSR model. Specifically, we will employ the Mistral-7B model, which is a decoder-only LLM. To adapt this model for sparse retrieval, we will incorporate Echo embeddings, a technique that improves the representation of the LLM by using repetition to overcome the bias inherent in unidirectional attention.

The training dataset is a critical component of our approach. Given the constraint of not using hard negative mining or distillation techniques, we will train our LSR model on the Sentence-Transformers embedding data, which is a large-scale dataset comprising 15.5 million samples. This dataset has been shown to improve the performance of dense passage retrieval models on the BEIR benchmark. We will sample from this dataset using probabilities proportional to the size of each constituent dataset, ensuring a diverse range of examples for the model to learn from.

Our training methodology will involve optimizing a contrastive InfoNCE loss alongside FLOPS regularization to achieve the desired sparsity in the representations. We will use in-batch negatives for training, with a batch size of 512, and train the model for 150,000 steps. The model will be trained using the ADAM optimizer with a learning rate of 2e-5 and linear scheduling, including a warmup phase of 6000 steps. The maximum input sequence length will be set to 256.

To mitigate the issue of untied weight matrices in the LLM, which could lead to uninterpretable logits, we will employ QLoRA finetuning. This involves finetuning the quantized LLM with a low-rank adaptation, using α = 8, rank = 16, and a dropout value of 0.1 over the projection layers. This approach will allow us to maintain the interpretability of the LSR model while adapting the LLM for sparse retrieval.

We will evaluate the performance of our trained LSR model, Echo-Mistral-SPLADE, on the BEIR benchmark, focusing on the subset of 13 readily available datasets. The evaluation metric will be nDCG@10, which measures the normalized discounted cumulative gain at the top 10 retrieved documents.

The rationale behind our approach is to leverage the scale and diversity of the training data, combined with the capabilities of the LLM, to achieve state-of-the-art performance on the BEIR benchmark without relying on hard negative mining or distillation. By using Echo embeddings and QLoRA finetuning, we aim to adapt the LLM effectively for sparse retrieval while maintaining interpretability.

Our plan is grounded in the specifics of how LSR models and LLMs operate, and it addresses the constraints of limited computational resources. By comparing our results with other LSR and dense retrieval models, we will assess the effectiveness of our training strategy and discuss its implications for the model's interpretability and inference latency.

The proposed research plan is designed to maximize the performance of the LSR model on the BEIR benchmark under the given constraints. It includes a clear plan for testing the effectiveness of the trained model and considers the trade-offs between different training strategies and dataset choices. By leveraging the strengths of LLMs and diverse training data, we aim to achieve superior performance in sparse retrieval tasks.",6f987ae85ee81865,258c644c6c151d19,cs,cs.IR,2408.11119
"You are tasked with evaluating the fairness of various conditional generative models used for image upsampling. The goal is to develop a comprehensive framework that assesses not only the performance but also the fairness and diversity of these models. You have access to a dataset of face images with race labels, but you are aware that the distribution of races in the dataset may not be uniform. How would you approach this problem and develop a systematic way to evaluate the fairness and diversity of the models?","['The proposed framework must include metrics for evaluating both performance and fairness of conditional generative models.'
 'The framework should extend traditional group-fairness measures to conditional generative models.'
 'The metrics should quantify fairness violations using divergence measures between probability distributions.'
 'The evaluation should consider the coherence between the condition and the generated samples.'
 'The metrics should be designed to handle cases where multiple outputs align with a given condition.'
 'The framework should be able to handle different types of conditional generative models.'
 'The evaluation should consider the impact of dataset bias on model fairness.'
 'The framework should provide a way to compare the fairness and diversity of different models.'
 'The evaluation should be based on a statistically sound methodology.'
 'The framework should be flexible enough to accommodate different divergence measures for quantifying fairness violations.']","To evaluate the fairness of various conditional generative models used for image upsampling, we will develop a comprehensive framework that assesses not only the performance but also the fairness and diversity of these models.

First, we will introduce a set of metrics to quantify the performance and fairness of conditional generative models. The performance metrics will include expected reconstruction losses, referenceless quality losses, and expected attribute reconstruction losses. For image data, we will use LPIPS distance or structural dissimilarity as reconstruction losses, and NIQE score or negative blurriness index as quality assessment metrics.

To assess fairness, we will extend traditional group-fairness measures to conditional generative models and define Representation Demographic Parity (RDP), Proportional Representation (PR), and Conditional Proportional Representation (CPR). RDP is satisfied if the conditional generative model does not perform better at correctly reconstructing one class over another. PR aims at retaining the true class distribution, and CPR assesses the diversity of the model in the presence of uninformative conditions.

We will quantify fairness violations using divergence measures between probability distributions, such as Pearson $\chi^2$-divergence and Chebyshev-distance. Specifically, we will introduce metrics $\Delta_{RDP}$, $\Delta_{PR}$, and $\Delta_{UCPR}$ to measure the amount of violation of RDP, PR, and UCPR (uninformative conditional proportional representation), respectively.

To validate our framework, we will apply it to evaluate the fairness of image upsampling methods on human face images using the FairFace dataset, which provides race labels. We will create a subset of FairFace, called UnfairFace, that replicates the racial distribution of common large-scale face datasets, to investigate the effect of dataset bias on image upsampling algorithms.

We will evaluate five image upsampling methods: PULSE, pSp, fair-pSp, Posterior Sampling, and DDRM. We will train these models on both UnfairFace and FairFace datasets and compare their performance, fairness, and diversity on a held-out test set with balanced races.

To assess diversity, we will generate uninformative low-resolution samples by averaging over test samples of the same race and downsampling to a resolution of 4 × 4. We will then upsample these samples multiple times using each model and evaluate the resulting racial distribution.

Our evaluation will be based on a statistically sound methodology, using tests such as Pearson's $\chi^2$-test to verify whether the models satisfy RDP, PR, and UCPR. We will also provide qualitative results to gain insights into the strengths and weaknesses of each method.

By following this framework, we will be able to comprehensively evaluate the fairness and diversity of conditional generative models used for image upsampling and provide a systematic way to compare different models. This will help to identify potential biases in these models and guide the development of more fair and diverse models.",c3945311dce71c34,8cc89f6bd3e20567,cs,cs.CV,2401.13555
"You are developing an Explainable AI (XAI) system that allows users to interact with large language models (LLMs) through a conversational interface. One of the key challenges you face is accurately recognizing user intents from their queries, which can be vague or open-ended. The system needs to parse user inputs into specific operations that the LLM can execute. You have a set of predefined operations (e.g., feature attribution, rationalization, data augmentation) and need to develop a parsing strategy that can accurately identify the intended operation and its attributes from the user's query. The parsing strategy should be flexible enough to handle a wide range of user inputs and should leverage the capabilities of the LLMs. How would you design a parsing strategy to achieve high accuracy in user intent recognition?","['The parsing strategy should be able to handle a wide range of user inputs and operations.'
 'The strategy should leverage the strengths of large language models (LLMs) in handling multiple tasks.'
 'The strategy should involve a multi-step process to enhance parsing accuracy.'
 'The first step should identify the main operation intended by the user.'
 'The subsequent steps should generate the full parse using operation-specific prompts.'
 'The strategy should be able to handle operations with multiple attributes.'
 'The approach should include a mechanism to check for hallucinations or incorrect parses.'
 'The strategy should be able to adapt to different LLMs, including those with varying sizes and capabilities.'
 ""The approach should be able to handle cases where the LLM's output does not match any predefined operation.""
 'The parsing strategy should be designed to be flexible and adaptable to new operations or changes in user behavior.']","To develop a parsing strategy for accurately recognizing user intents from their queries in the context of an Explainable AI (XAI) system, we will follow a multi-step approach that leverages the capabilities of large language models (LLMs).

First, we will implement a novel parsing strategy called Multi-prompt Parsing (MP). This approach involves a two-step process where the LLM is first queried to identify the main operation intended by the user from a list of available operations. Once the main operation is identified, the LLM is then prompted with operation-specific examples to generate the full parse, including any necessary attributes.

The MP approach is designed to handle a wide range of user inputs and operations by showing the LLM all possible operations in a simplified format initially. This allows the model to understand the context and scope of available operations before being asked to fill in more fine-grained attributes.

To enhance parsing accuracy, we will use a combination of techniques. For smaller LLMs, Guided Decoding (GD) can be employed to ensure that the generated output adheres to predefined grammatical rules and constraints. However, for larger LLMs, MP will be used as it can handle the complexity and variability of user queries more effectively.

To address the issue of hallucinations or incorrect parses, we will implement checks to verify the output of the LLM. If the model's output does not match any predefined operation, we will use SBERT to find the best match based on embedding similarity. This ensures that even when the LLM generates an output that does not exactly match any available operation, the system can still provide a relevant and useful response.

The parsing strategy will be evaluated using a manually created test set consisting of user queries and corresponding SQL-like queries. The evaluation metric will be exact match parsing accuracy, which will provide a clear measure of how well the parsing strategy performs.

To adapt to different LLMs with varying sizes and capabilities, we will test the parsing strategy across multiple models, including Falcon-1B, Pythia-2.8B, Llama2-7B, Mistral-7B, and Stable Beluga 2. This will help in understanding how the parsing strategy performs with different model sizes and architectures.

The MP approach is designed to be flexible and adaptable to new operations or changes in user behavior. By using a modular design where operation-specific prompts are used to generate full parses, the system can easily be extended to include new operations or modified to accommodate changes in user query patterns.

To further improve the parsing accuracy, we will analyze the performance of different LLMs on the parsing task and identify the factors that contribute to their performance. This will involve examining the impact of model size, the number of demonstrations provided, and the specific prompting strategy used.

Overall, the proposed parsing strategy combines the strengths of LLMs in handling multiple tasks with a multi-step process to enhance parsing accuracy. By leveraging MP and implementing checks to handle hallucinations or incorrect parses, the system will be able to accurately recognize user intents and provide relevant responses, thereby improving the overall user experience in interacting with the XAI system.",b69e3e121c41e32b,ffa2f9c781bf8df7,cs,cs.CL,2401.12576
"You are working on a citation text generation task where the goal is to generate a citation for a reference paper given the context window around the target citation and the reference paper abstract. However, you notice that the generated citations are often generic summaries of the reference paper, ignoring the context's focus on a specific topic. Your task is to propose a modification to the citation text generation task to make better use of the contextual information and produce more coherent and relevant citations. You have access to a dataset of citation texts with their corresponding context windows and reference paper abstracts. You need to come up with a novel approach that can effectively utilize the contextual clues to improve the quality of the generated citations.","['The proposed approach should modify the existing citation text generation task to incorporate the context window more effectively.'
 'The new approach should generate not just the target citation but also the surrounding context.'
 'The proposed method should be able to make use of contextual clues about the topic and stance of the citation.'
 'The approach should be applicable to any existing seq2seq citation generation model.'
 'The evaluation should involve human judges to assess the quality of the generated citations.'
 'The proposed approach should demonstrate an improvement over the baseline infilling-based approach.'
 'The approach should be able to handle different types of contextual information, such as historical development of a topic.'
 'The solution should be able to identify when the reference paper is an extension of another work cited earlier in the context.'
 'The proposed method should be able to generate citations that are not redundant with the context.'
 'The approach should be able to capture the nuances of the context, such as the tone and intent of the citation.']","To address the task of generating coherent and relevant citations that effectively utilize contextual information, we propose a modification to the existing citation text generation task. The goal is to make better use of the context window around the target citation and the reference paper abstract to produce high-quality citations.

The proposed approach involves reframing the citation text generation task to generate not only the target citation but the entire context window, including the target citation. This is achieved by modifying the generation target to include the surrounding context, distinguished from the target citation using a meta-token [SEP]. The input to the model remains the same, comprising the citing paper's introduction section, the paragraph containing the masked target citation, and the citation mark, title, and abstract of the reference paper.

We utilize the Longformer Encoder-Decoder (LED) citation generation model, which is a sequence-to-sequence model. The training dataset is the CORWA citation text generation dataset, which is a comprehensive dataset for citation text generation tasks. We merge the human-annotated train and automatically-labeled distant sets to create a large, unified training set.

To evaluate the proposed approach, we conduct a human evaluation involving six graduate students from the Computer Science Department. The judges are presented with the input to the generation model, the ground truth citation, and the citations generated by the baseline infilling-based approach and our proposed contextualized approach. The judges are asked to prefer one citation over the others based on fluency, relevance to the reference paper, coherence in the citation context, and overall quality.

The proposed approach is expected to generate citations that are more coherent with their surrounding contexts, as it makes use of contextual clues about the topic and stance of the citation. The contextualized model is able to identify the topic of focus, recognize when the reference paper is an extension of another work cited earlier in the context, and generate citations that are not redundant with the context.

The evaluation results are expected to demonstrate an improvement over the baseline infilling-based approach. We also acknowledge the limitations of automatic evaluation metrics like ROUGE, which do not capture coherence well, and therefore, rely on human evaluation to assess the quality of the generated citations.

The proposed approach is applicable to any existing sequence-to-sequence citation generation model, as it only changes the generation target and does not require significant changes to the input representations or features used by the existing models. The solution is well-documented, and the evaluation is comprehensive, involving human judges to assess the quality of the generated citations.

By generating the entire context window, the proposed approach is able to capture the nuances of the context, such as the tone and intent of the citation. The contextualized model is able to handle different types of contextual information, including the historical development of a topic, and identify when the reference paper is an extension of another work cited earlier in the context.

Overall, the proposed approach provides a simple yet effective modification to the existing citation text generation task, making better use of contextual information to produce high-quality citations.",10e02dfd17d62f59,1987eb27c282a061,cs,cs.CL,2402.18054
"You are working on a project to enhance the through-plane resolution of CT images. The CT images have varying resolution and overlap between slices, and you need to develop a method that can handle these variations. You have a dataset of CT volumes with high-resolution axial images, but the coronal and sagittal images have lower resolution and varying overlap. Your goal is to develop a self-supervised method that can enhance the resolution of the coronal and sagittal images without requiring high-resolution reference images. Describe your approach to this problem, including how you would simulate training data and design your model.","['The proposed method is self-supervised, leveraging high-resolution axial images to enhance coronal and sagittal images.'
 'The method accurately models the relationship between resolutions and voxel spacings of different planes.'
 'The approach simulates virtual through-plane-like axial images as inputs from high-resolution axial images.'
 'The method can handle CT images with arbitrary resolution and overlap.'
 'The proposed method leverages the similarity of image features across different orientations in medical CT volumes.'
 'The model is trained on axial images and applied to coronal and sagittal images.'
 'The approach involves using a neural network that can learn the mapping from degraded images to high-resolution images.'
 'The method includes a clear plan for evaluating its performance on coronal and sagittal images.'
 'The method is designed to be robust to variations in CT image acquisition parameters.'
 'The proposed approach is innovative and not a straightforward application of existing methods.']","To address the problem of enhancing the through-plane resolution of CT images with varying resolution and overlap between slices, we propose a self-supervised method called SR4ZCT. The goal is to develop a method that can handle these variations without requiring high-resolution reference images.

The SR4ZCT method is based on the assumption that medical CT images share similar features across different orientations. It leverages high-resolution axial images to enhance the resolution of coronal and sagittal images. The approach involves simulating virtual through-plane-like axial images as inputs from the high-resolution axial images, which are used to train a neural network.

To simulate the training data, we define a downscaling function F↓ver that downscales an axial image with pixel sizes rxy × rxy to produce a virtual through-plane-like image with pixel sizes rz × rxy and overlaps oz between image rows. We use linear interpolation in the vertical direction to achieve this. Similarly, we define an upscaling function F↑ver that upscales the virtual through-plane-like image to produce a degraded axial image with pixel sizes rxy × rxy and zero overlap. We also define scaling functions F↓hor and F↑hor that apply the scaling in the horizontal direction.

The training data is produced by creating two network input images for each axial image ai: aver = F↑ver(F↓ver(ai)) and ahor = F↑hor(F↓hor(ai)). These simulated images are then fed into the neural network fθ to learn the mapping from degraded images aver and ahor to their corresponding original axial image ai. Since the resolution enhancement is along the z-axis, which is always in the vertical direction for coronal and sagittal images, the horizontally degraded images and their corresponding axial images are rotated 90° using rotation function R.

The training is performed on all Z axial images and their corresponding degraded images using the loss function L, resulting in 2 × Z training pairs. The weights θ of the neural network fθ are determined by minimizing the total loss.

After training, the network fθ represents the learned mapping from virtual through-plane-like axial images with resolution rz × rxy and overlap oz between image rows to HR axial images with rxy × rxy resolution. We can then extend this learned mapping to coronal and sagittal images to enhance their resolution.

To enhance the resolution, we first use F↑ver to upscale coronal and sagittal images with voxel sizes rz × rxy and overlap oz between image rows to images with resolution rxy × rxy. Subsequently, we apply the trained neural network fθ directly to the upscaled coronal and sagittal images. The outputs of the neural network correspond to the improved images with enhanced resolution.

Any image-to-image neural network can be used as fθ. In this work, we use 2D MS-D networks with 100 layers, trained for 200 epochs using L2 loss and ADAM optimizer.

To evaluate the effectiveness of SR4ZCT, we compare it with supervised learning methods using simulated CT volumes with varying through-plane resolutions and overlaps. We also compare it with SMORE, a self-supervised method designed for MRI images, and demonstrate that SR4ZCT outperforms SMORE in handling CT images with arbitrary resolution and overlap.

We apply SR4ZCT to real-world CT images without reference volumes and present the results for visual assessment. The enhanced images exhibit sharper details compared to the original images, demonstrating the effectiveness of SR4ZCT in improving CT image resolution in real-world scenarios.

The correct modeling of the simulated training images is crucial for the success of SR4ZCT. We demonstrate the importance of accurate modeling by introducing modeling errors into the training images and showing that even minor deviations result in a decrease in performance.

Overall, SR4ZCT is a self-supervised method that can enhance the through-plane resolution of CT images with arbitrary resolution and overlap without requiring high-resolution reference images. Its ability to accurately model the relationship between resolutions and voxel spacings of different planes and handle varying resolution and overlap makes it a robust and effective solution for improving CT image resolution.",09fed91eb9a563d3,505e1661b49886f1,cs,cs.CV,2405.02515
"You are developing a scoring system to quantify the faithfulness of persona-driven role-playing (PRP) agents. 
    The PRP agents generate responses to user queries based on a set of given persona statements. 
    Your task is to leverage natural language inference (NLI) to assess whether the agent's responses are faithful to the persona statements. 
    You need to design a method that can accurately determine if a response is entailed by or contradicts a given persona statement, 
    and use this information to develop a scoring system that can compare different PRP methods.","[""The NLI-based method should assess the entailment or contradiction between persona statements and the agent's responses.""
 'The NLI assessment should be conditioned on the query to account for the context in which the response is generated.'
 'The scoring system should incorporate probabilities from NLI labels (entailment, neutral, contradiction) to quantify faithfulness.'
 'The scoring system should also incorporate statement-query relevance scores to weight the importance of each persona statement.'
 'The APC score should be capable of reflecting the expected number of satisfied constraints by the response.'
 'The APC score should be regularized to ∆APC score by subtracting the score gained by a PRP algorithm that always outputs neutral responses.'
 'The scoring system should be validated against human evaluation to ensure it correlates with human judgment of PRP faithfulness.'
 'The NLI-based scoring system should be applicable to evaluating PRP methods on characters with a large number of persona statements.'
 'The method should allow for tracing back and analyzing specific persona statements that are violated or satisfied.'
 'The scoring system should be evaluator-agnostic, allowing for comparison across different PRP methods and LLMs.']","To develop a scoring system that quantifies the faithfulness of persona-driven role-playing (PRP) agents, we will leverage natural language inference (NLI) to assess whether the agent's responses are faithful to the given persona statements. The approach involves several key steps:

1. **Formulate PRP Faithfulness as a Constraint Satisfaction Problem (CSP):** We view PRP as a CSP where each persona statement is a constraint. The satisfaction of a constraint depends on its relevance to the query (active or passive). An active constraint requires the response to be entailed by the persona statement, while a passive constraint requires the response not to contradict the persona statement.

2. **Quantify the CSP into a MAX-CSP Problem:** Since a response faithful to more persona statements is considered better, we reformulate the CSP as a maximal constraint satisfaction problem (MAX-CSP). The Active-Passive-Constraint (APC) score counts the number of constraints satisfied by the response, fine-granularized by evaluating the probability of each constraint being satisfied.

3. **Calculate the APC Score:** The APC score is calculated by summing up the satisfaction probabilities of the response to each persona statement. This involves two probabilistic evaluators: one for statement-query relevance (P_g) and one for statement-to-response NLI (P_h). The satisfaction probability for a persona statement is given by (P_g(s, q)P_h(s |= r|q)) + (1 - P_g(s, q))P_h(s ̸|= ¬r|q), where s is the persona statement, q is the query, and r is the response.

4. **Regularize the APC Score to ∆APC Score:** To make the absolute value of the APC score more straightforward to reflect faithfulness, we introduce the ∆APC score. This is done by subtracting the APC score gained by a PRP algorithm that always outputs neutral responses from the original APC score. The ∆APC score reflects the difference between the expected number of entailed active constraints (active reward) and the expected number of contradicted passive constraints (passive penalty).

5. **Symbolically Distill Small NLI and Relevance Discriminators:** For efficiency, we symbolically distill small discriminators (∼300M parameters) from a state-of-the-art LLM (GPT-4) to assign probabilities for statement-query relevance and statement-to-response NLI. These discriminators are fine-tuned on datasets generated by prompting GPT-4 with templates filled with input information.

6. **Validate the APC Score Against Human Evaluation:** To ensure the APC score correlates with human judgment of PRP faithfulness, we validate it against human evaluation based on example personas with tens of statements. Human evaluators are asked to memorize the persona statements and assign scores to responses.

7. **Apply the APC Score to Evaluate PRP Methods:** We use the APC score to compare different PRP methods, including experience upload (EU), retrieval-augmented generation (RAG), and long-context memory (LCM). The comparison reveals the advantages and limitations of these methods in terms of satisfying active and passive constraints.

8. **Leverage APC Score for Direct Preference Optimization (DPO):** The APC score is used as a reward for DPO to strengthen the faithfulness of PRP methods. The DPO loss is formulated based on the probabilities from the NLI and relevance discriminators, optimizing the PRP model's preference to align with the APC score.

9. **Analyze the Properties of PRP Methods:** We analyze how the scale of in-context persona statements affects PRP faithfulness and evaluate the faithfulness to active and passive constraints before and after APC-based DPO.

10. **Conduct Case Studies:** Finally, we conduct case studies to demonstrate how APC benefits the PRP domain, including analyzing violations in responses and experience uploading, and showcasing the effect of protective persona statements on PRP.

By following these steps, we aim to develop a comprehensive and effective method for quantifying and optimizing the faithfulness of PRP agents, providing a reliable reference for faithfulness improvement and comparison across different PRP methods and LLMs.",6ff80060430e86ec,4727c086312a4799,cs,cs.CL,2405.07726
"You are working on evaluating the interpretability of a text embedding framework that uses binary yes/no questions as interpretable dimensions. The goal is to assess how well users can understand the similarity between texts based on the questions answered by the framework. You need to define a metric that quantifies the interpretability of the embeddings produced by the framework. The metric should reflect the cognitive load on users when interpreting the similarity between two texts. How would you define such a metric, and what factors would you consider when designing it to ensure it accurately captures the interpretability of the embeddings?","['The proposed metric should be based on the number of questions that contribute to the similarity between two texts.'
 'The metric should be defined as the inner product of two binary embedding vectors.'
 'The inner product should count the number of dimensions where both vectors have a value of 1.'
 'The metric should be inversely related to interpretability, i.e., lower values should indicate higher interpretability.'
 'The metric should be applicable to binary embedding vectors of varying lengths.'
 'The metric should be simple to compute and understand.'
 'The metric should be sensitive to changes in the number of active dimensions in the embeddings.'
 'The metric should be based on the assumption that users need to consider all dimensions where both texts have a ""yes"" answer.'
 'The metric should not depend on the specific content of the questions, only on the binary answers.'
 'The metric should be useful for evaluating the trade-off between embedding quality and interpretability.']","To evaluate the interpretability of the text embedding framework that uses binary yes/no questions as interpretable dimensions, we need to define a metric that quantifies the cognitive load on users when interpreting the similarity between two texts. The framework, CQG-MBQA, generates interpretable semantic text embeddings by posing a set of carefully designed yes/no questions about a given text, with the answers forming an interpretable embedding vector.

The metric we propose is based on the number of questions that contribute to the similarity between two texts. Specifically, for any two binary embedding vectors u and v, the cognitive load is defined as the inner product of u and v: cognitive load = ⟨u, v⟩ = Σ(u_i * v_i) from i=1 to m, where m is the number of questions (dimensions) in the embedding vector. This metric counts the number of dimensions where both vectors have a value of 1, indicating that both texts have a ""yes"" answer to the same question.

The motivation behind this metric is that a lower cognitive load indicates higher interpretability, as fewer dimensions are involved in understanding the similarity between two texts. This metric is inversely related to interpretability, meaning lower values indicate higher interpretability. The cognitive load metric is applicable to binary embedding vectors of varying lengths and is simple to compute and understand.

To ensure the metric is relevant to the task of interpreting text similarity, we focus on the dimensions where both embedding vectors have a value of 1. This approach assumes that users need to consider all dimensions where both texts have a ""yes"" answer to understand their similarity. The metric does not depend on the specific content of the questions but rather on the binary answers, making it comparable across different pairs of texts.

The cognitive load metric is useful for evaluating the trade-off between embedding quality and interpretability. By varying the binary classification threshold τ, which determines the final binary embedding vector, we can adjust the number of active dimensions and thus the cognitive load. A higher τ results in fewer active dimensions, potentially improving interpretability but possibly reducing embedding quality.

To apply this metric, we will first generate binary embedding vectors for a set of texts using the CQG-MBQA framework. We will then compute the cognitive load for pairs of texts by calculating the inner product of their binary embedding vectors. This will allow us to assess the interpretability of the embeddings and evaluate how changes in the framework's parameters, such as the number of questions (dimensions) m and the binary classification threshold τ, affect the cognitive load.

We will conduct experiments on various text embedding tasks and datasets to demonstrate the applicability and usefulness of the cognitive load metric. By analyzing the relationship between cognitive load and embedding quality, we can provide insights into how to improve the interpretability of the embeddings produced by the CQG-MBQA framework.

The steps involved in this research plan include:
1. Generate binary embedding vectors for a set of texts using the CQG-MBQA framework.
2. Compute the cognitive load for pairs of texts by calculating the inner product of their binary embedding vectors.
3. Evaluate the interpretability of the embeddings based on the cognitive load.
4. Investigate how changes in the framework's parameters (e.g., number of questions, binary classification threshold) affect the cognitive load and embedding quality.
5. Conduct experiments on various text embedding tasks and datasets to demonstrate the applicability of the cognitive load metric.

By following this plan, we can develop a comprehensive understanding of how to quantify and improve the interpretability of text embeddings generated by the CQG-MBQA framework.",979c0ab52392eed1,f7d2e274163ccb81,cs,cs.CL,2410.03435
"You are working on a research problem involving parity-query protocols and their ability to distinguish between different distributions over affine subspaces in GF_n^2. Your goal is to construct a distribution that is hard for a parity-query protocol to distinguish from the uniform distribution over a given affine subspace C. The distribution should be constructed by consecutively fixing certain coordinates of elements in C to ""1"". You need to identify a method to select these coordinates such that the resulting distribution is not too concentrated and is hard for a parity-query protocol to distinguish from the uniform distribution. What approach would you take to construct this distribution, and how would you argue that it is hard for a parity-query protocol to distinguish it from the uniform distribution over C?","['The distribution is constructed by consecutively fixing ""likely unfixed"" coordinates of elements in C to ""1"".'
 'The selection of coordinates to fix is based on Lemma 1, which guarantees the existence of a set J of ""likely unfixed"" coordinates.'
 'The construction involves iteratively choosing coordinates from J that are unbiased when X ~ U_C.'
 'The construction of —_C^(t) ensures that it is not too concentrated by selecting coordinates that are likely to be unfixed.'
 'The argument for the hardness of distinguishing —_C^(t) from U_C involves showing that a parity-query protocol cannot easily distinguish between the two distributions.'
 'The comparison between —_C^(t)(D) and U_C(D) for any affine subspace D involves analyzing the probability of X ∈ D under both distributions.'
 'The union bound is used to argue that the probability of any of the consecutive choices fixing the corresponding coordinate in x ∈ C ∩ D is at most 1/2.'
 'The argument involves viewing i_1, ..., i_t as random variables distributed according to the procedure for generating X ~ —_C^(t).'
 'The distribution —_C^(t) is shown to be close to U_C in terms of the probability of being in any affine subspace D.'
 'The construction and the argument are tailored to the specific properties of affine subspaces in GF_n^2.']","To construct a distribution that is hard for a parity-query protocol to distinguish from the uniform distribution over a given affine subspace C, we will consecutively fix certain coordinates of elements in C to ""1"". The selection of these coordinates is based on Lemma 1, which guarantees the existence of a set J of ""likely unfixed"" coordinates.

We start by identifying a set J of size ⌊n/3⌋, such that for every j ∈ J, the coordinate X_j is unbiased when X ∼ U_C. This is possible due to Lemma 1, which states that for any affine subspace C with dimension at least 2n/3, there exists a set J of size ⌊n/3⌋ satisfying the required property.

We then define the distribution —_C^(t) for 0 ≤ t ≤ dim(C) - 2n/3, which involves t consecutive fixings of coordinates. Specifically, we choose i_1 uniformly at random from J, and let C_1 = {x ∈ C | x_i_1 = 1}. For each 2 ≤ j ≤ t, we choose i_j uniformly at random from the set J guaranteed by Lemma 1 with respect to C_j-1, and let C_j = {x ∈ C_j-1 | x_i_j = 1}. The distribution —_C^(t) is then defined as U_C_t, where C_t is the resulting affine subspace after t fixings.

The construction ensures that —_C^(t) is not too concentrated by selecting coordinates that are likely to be unfixed. To argue that —_C^(t) is hard for a parity-query protocol to distinguish from U_C, we show that a parity-query protocol cannot easily distinguish between the two distributions.

Specifically, we compare —_C^(t)(D) to U_C(D) for any affine subspace D. We analyze the probability of X ∈ D under both distributions and show that —_C^(t)(D) ≥ 1/2 * U_C(D). This relies on the properties of the construction and the guarantees of Lemma 1. The union bound is used to argue that the probability of any of the consecutive choices fixing the corresponding coordinate in x ∈ C ∩ D is at most 1/2.

We view i_1, ..., i_t as random variables distributed according to the procedure for generating X ∼ —_C^(t). The condition t ≤ n/14 is used to ensure that the probability of fixing any coordinate is not too high. The requirement n ≥ 14 is necessary for the construction and the argument to hold.

The distribution —_C^(t) is shown to be close to U_C in terms of the probability of being in any affine subspace D. The construction and the argument are tailored to the specific properties of affine subspaces in GF_n^2.

This approach allows us to construct a distribution —_C^(t) that is hard for a parity-query protocol to distinguish from U_C, as required. The construction is based on the properties of affine subspaces and the guarantees of Lemma 1, ensuring that the resulting distribution is not too concentrated and is hard to distinguish from the uniform distribution.",5c09aa72eb48378b,63dd8f6726b1aadb,cs,cs.CC,2401.11274
"You are working on a binary classifier for a learned B-frame codec to decide between motion estimation at high and low resolutions. The dataset is imbalanced, with a larger number of samples belonging to one class. You want to train the classifier to perform well on both classes, but you're concerned that the traditional Cross-Entropy Loss may not be effective due to the class imbalance. How would you modify the loss function to address this issue and improve the performance of the classifier?","[""The response acknowledges the issue of class imbalance in the dataset and its potential impact on the classifier's performance.""
 'The response proposes using Focal Loss as an alternative to Cross-Entropy Loss to address the class imbalance issue.'
 'The response explains that Focal Loss is designed to down-weight well-classified samples and focus on hard-to-classify samples.'
 'The Focal Loss function is correctly formulated as a modification of Cross-Entropy Loss, incorporating a focusing weight.'
 'The response explains that the focusing weight is inversely proportional to the confidence of the model.'
 'The response mentions the use of a hyperparameter (γ) to control the focusing effect.'
 'The response demonstrates an understanding of the challenges associated with training a classifier on imbalanced data.'
 'The response explains how to implement Focal Loss in the context of the given problem.'
 'The response highlights the potential benefits of using Focal Loss over traditional loss functions in this context.']","To address the issue of class imbalance in the dataset for training a binary classifier to decide between motion estimation at high and low resolutions in a learned B-frame codec, we will modify the loss function used during training. The traditional Cross-Entropy Loss may not be effective due to the class imbalance issue, where one class has a significantly larger number of samples than the other.

We propose using Focal Loss as an alternative to Cross-Entropy Loss. Focal Loss is designed to down-weight well-classified samples and focus on hard-to-classify samples, which is particularly useful in cases where there is a significant class imbalance. The Focal Loss function is formulated as a modification of Cross-Entropy Loss, incorporating a focusing weight that is inversely proportional to the confidence of the model.

The Focal Loss is given by the equation: 
L Bi = α t · (1 − p t ) γ · CE(p t , L hard ), 
where α t is used to balance the uneven distributions of the two prediction classes, (1 − p t ) γ is the focusing weight that discounts well-classified samples, γ is a hyperparameter set empirically to 2, L hard is the ground truth label in the form of a one-hot vector, and CE represents the cross-entropy loss. p t is set to the classifier's output p if the ground truth label is 1 and 1 − p otherwise.

By using Focal Loss, we aim to improve the performance of the classifier on both classes. The focusing weight (1 − p t ) γ helps to down-weight easy examples and focus on hard examples, thereby addressing the issue of class imbalance. The hyperparameter γ controls the focusing effect, allowing us to adjust the degree to which the loss function focuses on hard examples.

We will train multiple classifiers, one for each temporal level in a hierarchical temporal prediction structure, using the Focal Loss function. The optimal downsampling factor obtained through the OMRA method will be used as the ground truth label for each training sample.

The use of Focal Loss is justified by its ability to handle class imbalance and focus on hard-to-classify samples. This is particularly important in our scenario, where the classifier needs to perform well on both classes despite the imbalance in the dataset. By down-weighting well-classified samples and focusing on hard-to-classify samples, Focal Loss can help improve the overall performance of the classifier.

To implement Focal Loss, we will replace the traditional Cross-Entropy Loss with the Focal Loss function in our training objective. We will also set the hyperparameter γ to 2, as empirically determined. The α t parameter will be used to balance the uneven distributions of the two prediction classes.

By using Focal Loss, we expect to improve the performance of our binary classifier on both classes, despite the class imbalance issue. This will enable our learned B-frame codec to effectively decide between motion estimation at high and low resolutions, leading to improved coding performance and reduced computational complexity.",4d66ed2118e6be7d,404f06fb365c2603,cs,cs.CV,2410.21763
"You are working on a project to improve the interpretability of deep neural networks, specifically CNNs, by enhancing the quality of their gradients. You notice that standard backpropagation produces noisy gradients, which negatively affects interpretability. Guided backpropagation has been proposed as a method to produce sharper visualizations but is not typically used during training. Your task is to devise a creative way to leverage guided backpropagation during the training process to improve the standard gradient. Describe how you would use double backpropagation to regularize the standard gradient using guided backpropagation as a ""teacher"".","['The proposed method involves using double backpropagation to compute the gradient of the loss with respect to the input image.'
 'Guided backpropagation is used to obtain a ""teacher"" gradient that guides the standard gradient during training.'
 'The computation of the guided gradient is detached from the computational graph.'
 'The standard gradient is regularized to be similar to the guided gradient.'
 'The regularization is achieved through a loss term that measures the difference between the standard and guided gradients.'
 'The total loss includes both the classification loss and the regularization loss.'
 'The method involves differentiating through the computational graph twice.'
 'The guided backpropagation branch is excluded from the gradient computation for the model parameters.'
 'The evaluation involves comparing the interpretability of models trained with and without the proposed regularization.'
 ""The choice of detaching the guided gradient computation is justified to avoid affecting the model's training dynamics.""]","To address the given research scenario, we propose a novel training approach that leverages guided backpropagation during the training process to improve the standard gradient of a deep neural network, specifically CNNs, for better interpretability.

The primary motivation behind this approach is that standard backpropagation produces noisy gradients, which negatively affects the interpretability of CNNs. Guided backpropagation, on the other hand, has been shown to produce sharper visualizations but is typically used only during inference. Our task is to devise a creative way to utilize guided backpropagation during training to enhance the quality of the standard gradient.

We achieve this by employing double backpropagation, a general regularization paradigm. The core idea is to regularize the standard gradient by aligning it with the guided gradient obtained through guided backpropagation, which serves as a ""teacher"" gradient. This is done by introducing a regularization term into the loss function.

Here's a step-by-step breakdown of our research plan:

1. **Preliminaries**: We consider an image classification network \( f \) with parameters \( \theta \), which maps an input image \( x \) to a vector of predicted class probabilities \( p = f(x; \theta) \). At training, given training images \( X = \{x_i\} \) and target labels \( T = \{t_i\} \), we compute the classification loss \( L_C(X, \theta, T) \) using cross-entropy.

2. **Motivation**: The standard gradient \( \partial L_C / \partial x \) is noisy due to non-linearities like ReLU activations and downsampling operations. In contrast, the guided gradient \( \partial^G L_C / \partial x \) obtained by guided backpropagation is less noisy and preserves sharp details. Our goal is to make the standard gradient behave similarly to the guided gradient during training.

3. **Regularization**: For each input training image \( x_i \) and its target label \( t_i \), we perform a forward pass through \( f \) to compute \( p_i = f(x_i; \theta) \) and the contribution to \( L_C \). We then obtain \( \delta x_i = \partial L_C / \partial x_i \) and \( \delta^G x_i = \partial^G L_C / \partial x_i \) by two separate backward passes. We detach \( \delta^G x_i \) from the computational graph so it serves as a ""teacher"" without affecting the model's training dynamics.

4. **Regularization Loss**: We define the regularization loss \( L_R(X, \theta, T) \) as the average error between \( \delta x_i \) and \( \delta^G x_i \) over the training set, using an error function \( E \) such as mean absolute error (MAE), mean squared error (MSE), cosine similarity, or histogram intersection.

5. **Total Loss**: The total loss is \( L(X, \theta, T) = L_C(X, \theta, T) + \lambda L_R(X, \theta, T) \), where \( \lambda \) is a hyperparameter controlling the regularization strength.

6. **Updates**: We update \( \theta \) based on \( \partial L / \partial \theta \), which involves differentiating through the computational graph twice, excluding the guided backpropagation branch.

7. **Evaluation**: We train and evaluate ResNet-18 and MobileNet-V2 on CIFAR-100. At inference, we generate saliency maps using various CAM-based methods and evaluate faithfulness and causality metrics.

Our method improves the gradient quality and interpretability of CNNs without altering the inference process. It is novel in its use of guided backpropagation during training and is tested on multiple CNN architectures to demonstrate its generality. The choice of detaching the guided gradient computation is justified to prevent it from affecting the model's training dynamics. The regularization strength \( \lambda \) is a hyperparameter that needs to be tuned.

By following this plan, we aim to demonstrate that our approach enhances the interpretability of CNNs by improving the quality of their gradients, as evaluated by various metrics and methods, while maintaining their predictive power.",62880fc9b006679e,9399cf478af4c0a1,cs,cs.CV,2404.15024
"You are tasked with developing an automated system for solving complex geometry problems that require auxiliary constructions. The system must efficiently explore a vast space of possible constructions and proofs to identify valid solutions. Given the complexity of geometry and the need for both numerical and spatial reasoning, propose a novel approach that integrates symbolic reasoning with machine learning techniques to guide the search for solutions.","['The proposed approach must integrate tree search with machine learning models.'
 'The machine learning models should be fine-tuned large language models (LLMs).'
 'The LLMs should be used to predict promising search directions.'
 'The LLMs should estimate the remaining steps to solve a problem.'
 'The system should be capable of handling complex geometry problems requiring auxiliary constructions.'
 'The approach should efficiently explore the vast space of geometry problems.'
 'The integration of symbolic reasoning and machine learning should be clearly explained.'
 'The role of LLMs in guiding the tree search should be well-defined.'
 'The limitations of the proposed approach should be discussed.'
 'The potential for future improvements or extensions should be considered.']","To develop an automated system for solving complex geometry problems that require auxiliary constructions, we propose a novel approach that integrates symbolic reasoning with machine learning techniques. The system, inspired by TongGeometry, will efficiently explore a vast space of possible constructions and proofs to identify valid solutions.

First, we will implement a tree-based system for synthetic Euclidean planar geometry that facilitates human-readable problem proposing via backward tracing and theorem proving through forward chaining. This system will be scalable and efficient, allowing it to traverse a large number of unique paths in the defined space of geometry.

To guide the tree search, we will fine-tune two large language models (LLMs): one dedicated to suggesting possible search directions and another for estimating the number of steps to go in each direction. The LLMs will be trained on a dataset of geometry problems and their solutions, enabling them to learn patterns and relationships between geometric elements.

The system will start with a blank canvas and randomly draw geometric elements to generate new problems. It will then use the LLMs to guide the tree search, exploring promising directions and estimating the remaining steps to solve the problem. The system will also employ a replay buffer to cache promising intermediate states, allowing it to restart the search from these states and explore different branches.

To assess the quality of the generated problems, we will develop a set of rubrics for problem selection, inspired by GeoGen's methodology. Human experts will examine a batch of proposals during the initial phase of problem search, and the system will be trained to predict the difficulty and suitability of problems for olympiad competitions.

The system will be designed to work within a reasonable computational budget, utilizing consumer-grade hardware with 32 CPU cores and a single GPU card. We will compare our approach with existing state-of-the-art methods, such as AlphaGeometry, and evaluate its performance on benchmarks like IMO-AG-30 and MO-TG-225.

The integration of symbolic reasoning and machine learning will be crucial to the system's success. The symbolic reasoning component will provide a rigorous and logical framework for proving theorems, while the machine learning component will enable the system to explore the vast space of geometry problems efficiently.

While the proposed approach has shown promising results, we acknowledge its limitations. Currently, the system still falls short in sequentially constructing a series of interrelated actions, failing on problems requiring multiple new points to be constructed. To address this limitation, we plan to investigate more advanced techniques for generating and verifying auxiliary constructions.

In the future, we envision extending our approach to handle more complex geometry problems, such as those involving 3D geometry or non-Euclidean geometries. We also plan to explore the application of our system to other areas of mathematics, such as algebra and number theory.

By integrating tree search with machine learning models and leveraging the strengths of both symbolic reasoning and machine learning, our proposed system has the potential to revolutionize the field of automated geometry problem-solving and theorem proving.",962e08e4d8d1d7df,ee3678a24b963e31,cs,cs.AI,2412.10673
"You are tasked with designing a distributed hypothesis testing (DHT) system against independence for Binary Symmetric Sources (BSS). The system consists of two nodes: the first node observes a random vector $X^n$ and transmits a coded version of it to the second node over a noiseless channel, and the second node observes $Y^n$ and makes a decision based on the received coded version of $X^n$ and its own observation $Y^n$. The goal is to minimize Type-II error probability $\beta_n$ under a constraint on Type-I error probability $\alpha_n \leq \epsilon$. You are given the exact analytical expressions for $\alpha_n$ and $\beta_n$ based on the coset leader spectrum of a binary linear code used as the quantizer. Formulate an optimization problem to find the optimal coset leader spectrum that minimizes $\beta_n$ while satisfying the constraint on $\alpha_n$. Propose a method to solve this optimization problem.","['The optimization problem is formulated as minimizing Type-II error probability $\\beta_n$ under the constraint $\\alpha_n \\leq \\epsilon$.'
 'The optimization problem is expressed in terms of the coset leader spectrum $N = (N_0, N_1, ..., N_\\rho)$ of a binary linear code.'
 'The constraint $\\alpha_n \\leq \\epsilon$ is incorporated into the optimization problem using the exact analytical expression for $\\alpha_n$.'
 'The optimization problem is recognized as an integer linear programming (ILP) problem.'
 'The ILP problem is solved using an alternating optimization (AO) algorithm.'
 'The AO algorithm iteratively updates the decision threshold $\\gamma_t$ and the coset leader spectrum $N$.'
 'If $\\alpha_n > \\epsilon$, the AO algorithm increments $\\gamma_t$ and updates $W_\\alpha$ accordingly.'
 'The AO algorithm continues until it finds a $\\gamma_t$ that satisfies $\\alpha_n \\leq \\epsilon$.'
 'The final solution includes the optimal coset leader spectrum $N^*$ and the corresponding decision threshold $\\gamma_t^*$.'
 'The optimization problem formulation includes constraints on $N_i$ based on the finite number of vectors of length $n$ and weight $i$.']","To address the given scenario, we are tasked with designing a distributed hypothesis testing (DHT) system against independence for Binary Symmetric Sources (BSS). The system consists of two nodes: the first node observes a random vector $X^n$ and transmits a coded version of it to the second node over a noiseless channel, and the second node observes $Y^n$ and makes a decision based on the received coded version of $X^n$ and its own observation $Y^n$. The goal is to minimize Type-II error probability $\beta_n$ under a constraint on Type-I error probability $\alpha_n \leq \epsilon$.

## Step 1: Understand the Problem and the System Model
The problem involves a two-node DHT system where $X^n$ and $Y^n$ are observed at the first and second nodes, respectively. $X$ and $Y$ are related through $Y = X \oplus W$, where $W \sim \text{Bern}(p)$ and $\oplus$ denotes binary addition. The hypotheses are $\mathcal{H}_0: W \sim \text{Bern}(p_0)$ and $\mathcal{H}_1: W \sim \text{Bern}(p_1)$, with $p_1 = 0.5$ indicating independence between $X$ and $Y$.

## Step 2: Formulate the Optimization Problem
We need to minimize $\beta_n$ under the constraint $\alpha_n \leq \epsilon$. The error probabilities $\alpha_n$ and $\beta_n$ are given by exact analytical expressions based on the coset leader spectrum $N = (N_0, N_1, ..., N_\rho)$ of a binary linear code used as the quantizer.

## Step 3: Express Error Probabilities Using Coset Leader Spectrum
$\alpha_n$ and $\beta_n$ can be expressed as $\alpha_n = \frac{1}{N} \sum_{i=0}^{\rho} W_i^{\alpha} N_i$ and $\beta_n = \frac{1}{N} \sum_{i=0}^{\rho} W_i^{\beta} N_i$, where $W_i^{\alpha}$ and $W_i^{\beta}$ are defined in terms of the decision threshold $\gamma_t$ and the probabilities $p_0$ and $p_1$.

## Step 4: Simplify $\beta_n$ Using Lemma 1
According to Lemma 1, $\beta_n = \sum_{\gamma=0}^{\gamma_t} \binom{n}{\gamma} \frac{1}{2^n}$, which implies that minimizing $\beta_n$ is equivalent to minimizing $\gamma_t$.

## Step 5: Formulate the Minimization Problem for $\alpha_n$
To satisfy $\alpha_n \leq \epsilon$, we formulate the minimization problem: $\min_{N_i} e = \sum_{i=1}^{\rho} W_i^{\alpha} N_i$ subject to $0 \leq N_i \leq \binom{n}{i}$ and $\sum_{i=1}^{\rho} N_i = N - 1$, where $N_0 = 1$.

## Step 6: Recognize the Problem as Integer Linear Programming (ILP)
The formulated problem is an ILP problem because it involves integer variables $N_i$ and linear constraints.

## Step 7: Solve the ILP Problem Using Alternating Optimization (AO) Algorithm
We propose an AO algorithm (Algorithm 1) to solve the ILP problem. The algorithm starts with $\gamma_t = 0$, solves the ILP, and checks if $\alpha_n \leq \epsilon$. If not, it increments $\gamma_t$ and updates $W^{\alpha}$ until the constraint is satisfied.

## Step 8: Justify the Use of AO Algorithm
The AO algorithm is used because it can handle the integer constraints of the ILP problem. It iteratively updates $\gamma_t$ and $N_i$ to find the optimal solution.

## Step 9: Consider the Large Code-Length Regime
For large $n$, the error exponents for $\alpha_n$ and $\beta_n$ are derived, showing that the effective parameter influencing the error probabilities is the normalized decision threshold $\frac{\gamma_t}{n}$.

## Step 10: Evaluate the Proposed Method
The proposed method is evaluated based on its ability to minimize $\beta_n$ while satisfying $\alpha_n \leq \epsilon$. Numerical results demonstrate the effectiveness of the AO algorithm in finding near-optimal coset leader spectrums for binary linear codes.

The final solution includes the optimal coset leader spectrum $N^*$ and the corresponding decision threshold $\gamma_t^*$, which are obtained through the AO algorithm. This approach ensures that $\alpha_n \leq \epsilon$ while minimizing $\beta_n$, thus achieving the goal of the DHT system against independence for BSS.",ceb091d104471eac,d85295d174368ea3,cs,cs.IT,2410.15839
"Investigate the possibility of designing a fair and strategyproof tournament rule under a partially transferable utility model with a given selfishness parameter λ. Specifically, determine the range of λ for which it is possible to prevent pairwise manipulations while maintaining fairness, as defined by Condorcet consistency and monotonicity. Explore the conjecture that there exists a tournament rule that is both Condorcet consistent and non-manipulable for λ = 1, and analyze the implications of this conjecture for tournament design.","['The investigation should clearly define the fairness properties required, such as Condorcet consistency and monotonicity.'
 'The analysis should be conducted under the partially transferable utility model with a variable selfishness parameter λ.'
 'The possibility of preventing pairwise manipulations should be examined for different values of λ.'
 'The implications of the conjecture for λ = 1 on tournament design should be discussed.'
 'The analysis should consider the trade-offs between fairness and strategyproofness.'
 'The investigation should involve examining existing tournament rules for their manipulability under the given utility model.'
 'The role of λ in determining the manipulability of tournament rules should be highlighted.'
 'The investigation should consider the computational feasibility of determining whether a given tournament rule is non-manipulable for λ = 1.'
 'The analysis should be grounded in the existing literature on tournament rules and strategyproofness.'
 'The investigation should identify open problems or areas for further research related to the conjecture.']","To investigate the possibility of designing a fair and strategyproof tournament rule under a partially transferable utility model with a given selfishness parameter λ, we will follow a multi-step research plan.

First, we will clearly define the fairness properties required for the tournament rule, specifically Condorcet consistency and monotonicity. Condorcet consistency ensures that the undefeated agent wins the tournament with certainty, while monotonicity guarantees that no agent can improve her chances of winning by deliberately losing a match.

Next, we will analyze the partially transferable utility model with a variable selfishness parameter λ. This model interpolates between the non-transferable utility model and the completely transferable utility model. We will examine how λ affects the manipulability of tournament rules, with a focus on pairwise manipulations.

We will then investigate the conjecture that there exists a tournament rule that is both Condorcet consistent and non-manipulable for λ = 1. To do this, we will computationally solve for fair and manipulation-resistant tournament rules for λ = 1 for up to 6 agents. We will formulate the problem as a feasibility linear program and analyze the results to determine if such a rule exists.

Furthermore, we will analyze the implications of the conjecture for λ = 1 on tournament design. If the conjecture holds, it will imply that it is possible to prevent deliberate loss and collusion as long as each agent weighs her own probability of winning twice as much as her opponents'. We will discuss the significance of this result for designing fair and strategyproof tournaments.

In addition, we will examine the trade-offs between fairness and strategyproofness for existing tournament rules under the partially transferable utility model. We will analyze the performance of rules such as ICR, RVC, TCR, RSEB, RKotH, RDM, PR, and PRSL in terms of their manipulability for different values of λ. This will involve deriving lower bounds on α (the maximum gain from manipulation) for these rules as a function of λ.

We will also investigate the role of λ in determining the manipulability of tournament rules. By varying λ, we will examine how the level of selfishness affects the robustness of tournament rules to pairwise manipulations.

To further understand the challenges in designing tournament rules that are both fair and strategyproof, we will discuss the limitations of existing rules and the difficulties in constructing new rules that satisfy both properties.

The computational feasibility of determining whether a given tournament rule is non-manipulable for λ = 1 will also be considered. As the number of tournaments on n agents grows exponentially with n, we will discuss the computational challenges in checking for non-manipulability for larger values of n.

Finally, we will identify open problems and areas for further research related to the conjecture. Potential extensions to other fairness properties or utility models will be discussed, and the implications of our findings for real-world tournament settings will be highlighted.

By following this research plan, we aim to contribute to a deeper understanding of the interplay between fairness and strategyproofness in tournaments under the partially transferable utility model. Our analysis will provide insights into the design of fair and strategyproof tournament rules and shed light on the challenges and opportunities in this area.",f6816dcc3dbf34e3,63e9d941136a7327,cs,cs.GT,2408.10346
"You are working on fine-tuning a large language model (LLM) to improve its cultural reasoning capabilities by incorporating culturally-specific instructions into its training data. You have two approaches to generate answers for the cultural instructions: context-dependent answer generation, where the answer is generated based on a provided context, and context-free answer generation, where the answer is generated without relying on a specific context. Your goal is to determine which approach is more effective in improving the LLM's performance on culturally-related tasks. How would you design an experiment to compare these two approaches and evaluate their impact on the LLM's cultural reasoning capabilities?","['The experiment should compare context-dependent and context-free answer generation approaches.'
 'The evaluation metric should assess the accuracy and relevance of the generated answers.'
 ""The experiment should control for other factors that could influence the LLM's performance.""
 'The comparison should be based on a sufficient number of test samples to ensure reliability.'
 'The experiment should consider the potential biases introduced by the context or lack thereof.'
 ""The evaluation should include an assessment of the LLM's performance on a diverse set of cultural tasks.""
 'The results should be analyzed to determine if one approach consistently outperforms the other.'
 'The experiment should consider the potential impact of the quality of the provided context on the results.'
 'The experiment should be designed to minimize the influence of randomness on the results.'
 'The experiment should provide insights into why one approach might be more effective than the other.']","To determine which approach is more effective in improving the LLM's cultural reasoning capabilities, we will design an experiment to compare context-dependent and context-free answer generation methods. 

First, we will utilize the CRAFT method to synthesize cultural instructions from a vast, unlabeled English corpus. This involves selective data extraction using keyword filtering to identify culturally relevant concepts, automated question creation using an off-the-shelf LLM, and answer production through both context-dependent and context-free approaches.

For selective data extraction, we will use a collection of region-specific keywords to filter text chunks from the SlimPajama corpus, which contains over 600 billion English tokens. We will curate at least 150 words to represent each region and retain text chunks that include at least two regional keywords.

Next, we will employ an off-the-shelf LLM, Zephyr-7B-Beta, to generate questions related to the cultural and regional concepts mentioned in the text chunks. For answer production, we will use two approaches: context-dependent answer generation, where the given context is provided to the LLM when forming answers, and context-free answer generation, where the LLM generates answers without relying on a specific context. We will use Zephyr-7B-Beta for context-dependent answer generation and ChatGPT-3.5 for context-free answer generation.

After developing the cultural instructions, we will compile at least 20,000 instructions for each specified region and incorporate 50,000 single-round instructions from the OpenHermes-2.5 dataset alongside random sampled 20,000 cultural instructions to fine-tune the Mistral-7B-Instruct-v0.2 model using LoRA training with a rank of 16.

To evaluate the impact of the two approaches on the LLM's cultural reasoning capabilities, we will use three culturally-focused datasets: SG-Eval, Ph-Eval, and US-Eval, each containing human-crafted multiple-choice questions and answers that probe cultural or regional knowledge. We will also utilize a subset of the MMLU dataset to assess the LLM's knowledge capabilities in general subjects.

We will investigate the effects of adding varying amounts of cultural instructions to a base of 50,000 general instructions and report the average results from five runs using paraphrased prompt templates to minimize the influence of randomness. 

The comparison between context-dependent and context-free answer generation approaches will be based on their performance on the culturally-focused datasets. We will analyze the results to determine if one approach consistently outperforms the other and investigate how the two approaches affect the LLM's ability to understand cultural nuances.

To ensure a fair and unbiased comparison, we will control for other factors that could influence the LLM's performance, such as the quality of the provided context. We will also assess the potential biases introduced by the context or lack thereof and consider the potential impact of the quality of the provided context on the results.

By following this experimental design, we aim to provide insights into why one approach might be more effective than the other in improving the LLM's cultural reasoning capabilities.",805ef5ceead4505a,d7b6e1c16484ed99,cs,cs.CL,2405.03138
"Evaluate the performance of a novel cross-city Origin-Destination (OD) flow prediction model, LLM-COD, which leverages Large Language Models (LLMs) and a new loss function integrating POI semantics and trip distance. The goal is to assess the model's superiority over state-of-the-art learning-based methods, particularly for high-volume and long-distance flows. Describe a detailed experimental setup to test the model's performance, including the datasets to be used, evaluation metrics, and a robustness analysis to examine the model's accuracy across different OD flow and distance distributions.","['The experimental setup should utilize real-world trip data from multiple cities.'
 'The evaluation should include a comparison with state-of-the-art learning-based methods.'
 ""The experiments should assess the model's performance using metrics such as RMSE, SMAPE, and CPC.""
 ""The robustness analysis should examine the model's performance across different OD flow distributions.""
 ""The experiments should test the model's performance for high-volume and long-distance flows.""
 'The evaluation should include a visualization of the generated OD flows to demonstrate practicality and accuracy.'
 'The experimental setup should account for variations in city characteristics and urban environments.'
 ""The model's performance should be evaluated for different grid sizes.""
 ""The evaluation should highlight the impact of the new loss function on the model's performance.""
 ""The robustness analysis should indicate the model's ability to generalize across different cities.""]","To evaluate the performance of the novel cross-city Origin-Destination (OD) flow prediction model, LLM-COD, we will conduct a comprehensive experimental setup. The primary objective is to assess the model's superiority over state-of-the-art learning-based methods, particularly for high-volume and long-distance flows.

First, we will utilize real-world trip data from multiple cities, including Beijing, Xi'an, and Chengdu. The Beijing dataset contains taxi trajectories, while the Xi'an and Chengdu datasets contain trajectories by DiDi ride-sharing. We will also obtain Points of Interest (POIs) data through APIs provided by Tencent Map API.

The experimental setup involves the following steps:
1. **Grid Map Creation**: Divide the geographical area of each city into square grid cells with sizes of 500m x 500m, 1000m x 1000m, and 2000m x 2000m.
2. **Grid cell POI distribution retrieval**: Retrieve the POI distributions for each cell to obtain the spatial feature sets.
3. **OD POI dataset creation**: Process the trajectory dataset to obtain the POI distributions of the origin and destination cells of each trip.

We will compare the performance of LLM-COD with state-of-the-art baseline models, including Random Forest, Gravity Model, GBRT, and GODDAG. The evaluation metrics will include Root Mean Square Error (RMSE), Symmetric Mean Absolute Percentage Error (SMAPE), and Common Part of Commuters (CPC).

To assess the model's performance, we will conduct the following experiments:
1. **Cross-city OD flow prediction**: Train LLM-COD on the Beijing dataset and perform prediction on the Chengdu and Xi'an datasets.
2. **Robustness analysis**: Examine the model's performance across different OD flow and trip distance distributions.
3. **Design choices evaluation**: Assess the impact of different design choices, such as the use of city indicators and the Single POI strategy, on the model's performance.
4. **Visualization**: Visualize the generated OD flows to demonstrate practicality and accuracy.

The experiments will be carried out on a system with 4 NVIDIA A100 GPUs, each with 40GB of memory. We will use the Adam optimizer with a learning rate of 0.001 for training LLM-based models, while Random Forest, Gravity Model, and GBRT will use the Adam optimizer with a learning rate of 0.0002 and weight decay of 0.001. The LLMs used will be LLAMA2 7B.

By conducting these experiments, we will demonstrate the superiority of the LLM-COD model, particularly for high-volume and long-distance flows, and highlight the impact of the new loss function on the model's performance. The results will also indicate the model's ability to generalize across different cities and its robustness across different OD flow and trip distance distributions. The visualization of OD flows will align with the ground truth and demonstrate the model's accuracy. The comprehensive experimental setup will cover various aspects of the model's performance, providing a thorough evaluation of the LLM-COD model.",a823de4efee96530,44eb1bf9c9c38fc5,cs,cs.AI,2409.03937
"You are tasked with developing a personalized Large Language Model (LLM) for edge devices, which must learn from user-generated data while operating under strict resource constraints. The goal is to enhance the model's performance and privacy protection by enabling local learning and adaptation. However, existing fine-tuning methods are either too resource-intensive or have limited learning capacity. You need to devise a novel approach to efficiently fine-tune the LLM on edge devices, addressing the challenges of domain shift issues and limited resources.","['The solution proposes a framework that leverages Non-Volatile Computing-in-Memory (NVCiM) architectures to assist prompt tuning for edge LLMs.'
 'The framework includes a representative selection component to identify the most representative data samples from the user-generated data.'
 'The solution involves noise-aware training to make the virtual tokens resilient to NVM device variations.'
 'The framework employs a scaled search algorithm on NVCiM to efficiently retrieve the appropriate Optimal sets of Virtual Tokens (OVTs).'
 'The solution is designed to operate within the constraints of edge devices, including limited memory and computational power.'
 'The approach addresses the domain shift issue by utilizing multiple OVTs instead of a single ""one-for-all"" set of virtual tokens.'
 'The solution includes a pre-trained autoencoder to reshape the obtained virtual tokens to fit the NVM devices.'
 'The approach mitigates the incompatibility between user input embeddings and stored OVTs through a multi-level scaling strategy.'
 'The solution involves a co-designed approach that integrates the benefits of NVCiM with prompt tuning.'
 'The approach is designed to be adaptable to different types of NVCiM devices.']","To develop a personalized Large Language Model (LLM) for edge devices that learns from user-generated data while operating under strict resource constraints, we propose a novel framework called NVCiM-PT. This framework leverages Non-Volatile Computing-in-Memory (NVCiM) architectures to assist prompt tuning for edge LLMs, addressing the challenges of domain shift issues and limited resources.

First, we identify the need to move beyond existing fine-tuning methods that are either too resource-intensive or have limited learning capacity. Prompt tuning (PT) emerges as a viable alternative, but it suffers from domain shift issues due to the limited data buffer sizes on edge devices. To address this, we adopt the concept of Optimal sets of Virtual Tokens (OVTs), where each OVT is derived through PT on a specific data sample, significantly enhancing the LLM's performance.

The NVCiM-PT framework consists of three primary components: Representative Selection (RS), Noise-aware Training (NT), and Store & Scaled Search Algorithm (SSA) on NVCiM.

1. **Representative Selection (RS):** RS is designed to identify the most representative data samples from the user-generated data stored in a data buffer. When the buffer is full, RS employs k-means clustering to identify domains within the data and selects the most representative sample from each domain based on cosine similarity. This process ensures that multiple OVTs are obtained, each corresponding to a specific domain, thereby addressing the domain shift issue.

2. **Noise-aware Training (NT):** NT involves training the virtual tokens to be resilient to device variations inherent in Non-Volatile Memory (NVM) devices. We inject simulated noise into the virtual tokens during training, based on a Gaussian distribution parameterized by σ. This noise-aware training approach shapes the virtual tokens to be more resilient to the device variations expected during NVM storage and retrieval.

3. **Store & Scaled Search Algorithm (SSA) on NVCiM:** SSA involves storing the obtained OVTs in NVM devices and retrieving the appropriate OVT based on user input. To implement this, we first employ a pre-trained autoencoder to transform the OVTs into an encoding space compatible with NVM devices. We then introduce a scaled search algorithm that leverages the NVCiM architecture to compare the user input embedding with the stored OVTs. The algorithm uses a Weighted Multi-Scale Dot Product (WMSDP) function, which computes the weighted sum of matrix multiplications at different scales (1, 2, and 4) to capture similarities between the user input and OVTs at various granularities.

The NVCiM-PT framework is designed to operate within the constraints of edge devices, including limited memory and computational power. By utilizing NVCiM architectures, we reduce data movement and enhance energy efficiency. The framework is tailored for resource-constrained environments where LLMs need to learn on edge devices, enabling efficient use of OVTs.

To evaluate the effectiveness of NVCiM-PT, we conduct experiments across various NVM devices, LLMs, and datasets. We compare the performance of NVCiM-PT with existing noise mitigation methods and retrieval algorithms, demonstrating its superior performance. Additionally, we evaluate the latency and energy efficiency of the scaled search algorithm on NVCiM devices, showcasing significant improvements over traditional CPU-based approaches.

By co-designing the NVCiM architecture with prompt tuning, NVCiM-PT provides a comprehensive solution for deploying personalized LLMs on edge devices, balancing powerful AI capabilities with enhanced privacy protection and resource efficiency.",ddc31c238d6c2165,1a21b789eaf7895d,cs,cs.LG,2411.08244
"You are tasked with developing a robust estimation strategy for the bounds of the conditional average treatment effect (CATE) using observational data from multiple environments. The data is subject to violations of standard causal assumptions, and you need to ensure that your estimators are consistent and robust to misspecification. Propose a theoretical framework that provides guarantees for your estimators.","['The theoretical framework should provide consistency guarantees for the proposed estimators.'
 'The framework should include a double robustness property for certain estimators.'
 'The theory should be applicable to both within-environment and cross-environment bounds estimation.'
 'The framework should clarify the conditions under which the nuisance parameters (e.g., propensity scores, response surfaces) need to be correctly specified.'
 'The theoretical guarantees should be derived under the assumptions stated in the problem setup.'
 'The framework should be flexible enough to accommodate different types of machine learning models used for nuisance estimation.'
 'The theory should provide insights into the trade-offs between different estimation strategies.'
 'The approach should clearly outline the assumptions required for the theoretical guarantees to hold.'
 'The framework should be generalizable to other partial identification settings beyond the specific problem considered.'
 'The theoretical framework should provide a foundation for future research on robust causal inference methods.']","To develop a robust estimation strategy for the bounds of the conditional average treatment effect (CATE) using observational data from multiple environments, we will follow a theoretical framework that provides guarantees for our estimators.

First, we will leverage the environment variable as an instrumental variable (IV) to derive bounds for the CATE. The environment variable is assumed to have an effect on the treatment assignment but no direct effect on the outcome. We will generalize results from the literature on partial identification for IVs to our setting with multiple environments and continuous outcomes.

The derivation of the bounds will be based on the following assumptions:
1. Consistency across environments: Observing a treatment implies the corresponding potential outcome.
2. Environment-agnostic oracle response surfaces: The expected potential outcomes are the same across environments.
3. Common support: The populations of all environments are supported on a common domain.

Under these assumptions, we will derive bounds for the CATE by combining bounds for the oracle response functions across environments. The bounds will be a function of the propensity scores and response surfaces in each environment.

To estimate these bounds, we will propose novel meta-learners that can be used in combination with arbitrary machine learning models. The meta-learners will be designed to estimate both within-environment bounds and cross-environment bounds.

The within-environment bounds will be estimated using a within-environment bound-learner (WB-learner), which constructs a pseudo-outcome that equals the bound in expectation. The cross-environment bounds will be estimated using cross-environment bound-learners (CB-learners), which cast the estimation problem into a standard CATE estimation task with transformed outcomes and treatments.

The CB-learners will come in different variants, including a plugin-learner, a regression-adjustment learner, an inverse-propensity weighted learner, and a doubly robust learner. These learners will be consistent estimators of the bounds under certain conditions on the nuisance estimates.

Theoretical guarantees will be provided for the proposed meta-learners. The WB-learner will be shown to be always consistent, while the CB-learners will be consistent under certain conditions on the nuisance estimates. The doubly robust learner will be shown to be consistent if either the response function or the propensity score is correctly specified.

The theoretical framework will be validated through empirical demonstrations on synthetic and real-world data. The synthetic data will be used to examine the performance of the meta-learners under different data-generating processes, while the real-world data will be used to demonstrate the applicability of the meta-learners to a case study on the effect of comorbidity on COVID-19 mortality.

The proposed meta-learners will be implemented using neural networks, and the implementation details will be provided. The performance of the meta-learners will be evaluated using the root mean squared error (RMSE) to the oracle bounds.

Overall, our research plan provides a robust estimation strategy for the bounds of the CATE using observational data from multiple environments. The theoretical framework provides guarantees for the proposed estimators, and the empirical demonstrations validate the effectiveness of the meta-learners.",4739fdbebfa43f20,56f50a3e14582fe4,cs,cs.LG,2406.02464
"You are tasked with extending a denoising diffusion-based variational inference algorithm to semi-supervised learning and clustering tasks. The algorithm should be able to handle partially labeled data and incorporate cluster assignments as latent variables. The goal is to demonstrate the versatility and applicability of the algorithm to various problem settings beyond standard variational inference. Propose modifications to the original algorithm to accommodate these new tasks, ensuring the extended algorithm remains tractable and efficient.","['The proposed extension should accommodate semi-supervised learning with partially labeled data.'
 'The method should incorporate labels as latent variables for unlabeled data.'
 'The approach should modify the learning objective to include a classification loss for labeled data.'
 'The extended algorithm should be applicable to clustering tasks by introducing cluster assignments as latent variables.'
 'The clustering extension should involve a mixture of priors or an additional cluster latent variable.'
 'The proposed modifications should remain tractable and allow for efficient optimization.'
 'The semi-supervised learning extension should utilize the same diffusion-based posterior as the original algorithm.'
 'The clustering extension should be able to discover a specified number of clusters.'
 'The proposed extensions should be compared to baseline methods in terms of performance metrics.'
 'The approach should be scalable to larger datasets and more complex models.']","To extend the denoising diffusion-based variational inference algorithm to semi-supervised learning and clustering tasks, we will follow the approach outlined in the document.

First, we will extend the algorithm to semi-supervised learning by incorporating labels as latent variables for unlabeled data. We assume a model of the form $p_\theta(x, y, z, l) = p_\theta(x|z, l)r(y|z, l)p_\theta(z|l)p(l)$, where $l$ represents the label. For data points with observed labels, we use the variational distributions $q_\phi(z|x,y,l)$ and $q_\phi(y|x)$. For data points without labels, we treat the label as a latent variable and use $q_\phi(z|x,y,l)$, $q_\phi(y|x)$, and $q_\phi(l|x)$. The learning objective is modified to include a classification loss for labeled data.

The semi-supervised learning objective is given by $L_{semi} = E_{q_\phi(y,z|x,l)} [\log p_\theta(x|z,l)] - D_{KL}(q_\phi(y,z|x,l)||p_\theta(y,z|l)) - E_{p_\theta(x)} [D_{KL}(p_\theta(z|x,l)||q_\phi(z|x,l))]$. When the label is not observed, we marginalize over the label using $U_{semi} = \sum_c q_\phi(l|x)L_{semi}(x, l, \theta, \phi) + D_{KL}(q_\phi(l|x)||p(l))$. The overall objective is $L̃_{semi} = \sum_{(x,l) \in L} L_{semi}(x,l,\theta,\phi) + \sum_{x \in U} U_{semi}(x,\theta,\phi)$, where $L$ and $U$ are the sets of data with and without labels, respectively.

To improve classification accuracy, we combine the marginal likelihood with a classification loss to form an extended learning objective: $L̃_{semi}^\alpha = L̃_{semi} + \alpha \cdot E_{p̃(x,l)} [-\log q_\phi(l|x)]$.

Next, we will extend the algorithm to clustering tasks by introducing cluster assignments as latent variables. We propose two strategies: (1) using a mixture of priors $p_\theta(z)$ with means characterized by $\theta$, from which cluster membership can be deduced; and (2) introducing an additional cluster latent variable $c$ where $\sum_i c_i = 1$, with $p(c) = Dir(\epsilon)$.

For the first clustering approach, we fit a model with a mixture of priors without altering the existing learning objective. For the second approach, we reformulate the learning objective as $L_{clus}(x) = E_{q_\phi(y,z,c|x)} [\log p_\theta(x|z,c)] - D_{KL}(q_\phi(y,z,c|x)||p_\theta(y,z,c)) - E_{p_\theta(x)} [D_{KL}(p_\theta(z|x)||q_\phi(z|x))]$.

We will use the same diffusion-based posterior as the original algorithm for both semi-supervised learning and clustering tasks. The diffusion-based posterior is given by $q_\phi(z|x) = \int q_\phi(z|y,x)q_\phi(y|x)dy$, where $y$ represents a sequence of latents that are progressively simplified versions of $z$.

To optimize the learning objectives, we will use gradient descent with a wake-sleep optimization algorithm. For semi-supervised learning, we use a simplified sleep term that optimizes $q_\phi$ to denoise $z$ from $y$ independently of $x$. For clustering, we will evaluate the performance on real-world datasets such as the 1000 Genomes dataset and provide visualizations of the latent space.

We will compare the performance of our extended algorithm to baseline methods in terms of performance metrics such as ELBO, accuracy, and clustering metrics like NMI and cluster purity. Our approach is designed to be scalable to larger datasets and more complex models.

By following this plan, we will demonstrate the versatility and applicability of the denoising diffusion-based variational inference algorithm to various problem settings beyond standard variational inference.",7b4cc65e5040a0ee,fe93f787535451d4,cs,cs.LG,2401.02739
"You are tasked with enhancing the transparency and verifiability of large language models (LLMs) by enabling them to cite the sources of their parametric knowledge. The goal is to develop a training framework that allows LLMs to associate unique document identifiers with the knowledge in each document. You have access to a pretraining corpus and can modify the pretraining and fine-tuning stages. However, you are constrained by the need to minimize changes to the model architecture and implementation. Propose a training framework that achieves this goal.","['The proposed training framework involves a two-stage process: pretraining and instruction tuning.'
 'The pretraining stage includes injecting unique document identifiers into the pretraining data.'
 'The instruction tuning stage is designed to teach the model to generate the document ID along with the response.'
 'The framework minimizes changes to the model architecture and implementation.'
 'The pretraining stage involves training the model to predict the next word in the document with the injected document ID.'
 'The instruction tuning stage uses examples from the in-domain documents to fine-tune the model.'
 'The model is trained to generate a tuple containing the response and the document ID supporting the response.'
 'The instruction tuning stage is restricted to a subset of the pretraining documents (in-domain documents).'
 ""The model's ability to attribute knowledge to out-of-domain documents is evaluated.""
 'The proposed framework is applicable to off-the-shelf LLMs.']","To enhance the transparency and verifiability of large language models (LLMs) by enabling them to cite the sources of their parametric knowledge, we propose a training framework that involves a two-stage process: pretraining and instruction tuning.

### Pretraining Stage
During the pretraining stage, we inject unique document identifiers into the pretraining data. This involves associating each document in the pretraining corpus with a unique identifier. The document identifier is injected into the document using one of several strategies:
1. **DOC-BEGIN**: Inject the ID once before the first token in the document.
2. **DOC-END**: Inject the ID once after the last token in the document.
3. **REPEAT**: Inject the ID after every sentence in the document.

To maximize GPU utilization, we pack several pretraining documents within a single training sequence. However, to avoid the model associating a document ID with knowledge from other documents, we disable cross-document attention.

### Instruction Tuning Stage
The instruction tuning stage is designed to teach the model to generate the document ID along with the response. We create instruction tuning examples from a subset of the pretraining documents (in-domain documents). Each example is a tuple containing a prompt, a ground-truth response, and the ID of the document supporting the response. The model is trained to generate both the response and the document ID.

We also explore a variant of instruction tuning called **chain-of-thought attribution**, where the model is trained to cite the relevant part of the document before generating the document ID.

### Data Construction
To study the attribution ability of LLMs in a controlled setting, we construct a synthetic pretraining corpus called B IO C ITE . B IO C ITE is based on the BioS dataset, which contains biographies of fake individuals. We construct documents by sampling facts from multiple biographies and assigning a unique identifier to each document.

### Evaluation
We evaluate the model's ability to attribute knowledge to out-of-domain documents (documents not seen during instruction tuning). We measure the answer exact match and the recall of the gold document ID (Hits@k).

### Key Components and Justification
1. **Document ID Injection Strategy**: The choice of document ID injection strategy significantly affects the model's attribution ability. We experiment with different strategies to identify the most effective one.
2. **Data Augmentation**: To improve the model's ability to generalize to out-of-domain documents, we apply data augmentation techniques, such as document-level augmentation by shuffling the sentences within a document.
3. **Chain-of-Thought Attribution**: This approach helps the model to better associate the document ID with the relevant knowledge.

### Minimizing Changes to Model Architecture and Implementation
Our proposed framework is designed to be compatible with existing pretraining pipelines and requires minimal changes to the model architecture and implementation. This is achieved by building upon the standard pretraining and fine-tuning frameworks used for LLMs.

By following this training framework, we aim to enable LLMs to attribute their parametric knowledge to the supporting pretraining sources, thereby enhancing their transparency, interpretability, and verifiability.",69c4d0bdb5ecce8b,c4ae2ffdda554c5a,cs,cs.CL,2404.01019
"You are tasked with developing a comprehensive evaluation framework to assess the biases in a text-to-image generation model. The model generates images based on text prompts, and you need to quantify the biases present in the generated images. You have a dataset of generated images and corresponding prompts, but you are unsure about the most effective metrics to use for evaluating bias. Your goal is to identify and apply appropriate metrics that can comprehensively assess the biases in the model's outputs.","['The response categorizes bias evaluation metrics into distribution metrics, bias tendency metrics, and quality metrics.'
 'The response identifies distribution metrics as being used to assess context-to-gender bias by analyzing differences in attribute distributions.'
 'The response mentions the use of Mean Absolute Deviation (MAD) as a distribution metric to evaluate bias.'
 'The response notes the application of the chi-square test to determine significant differences in generated attributes.'
 'The response explains that bias tendency metrics are used to examine whether attributes in generated images are biased towards a specific gender.'
 'The response discusses the use of quality metrics to evaluate the semantic alignment and image quality of generated images.'
 'The response acknowledges the importance of using multiple metrics to comprehensively understand biases.'
 'The response implies that the choice of metrics depends on the specific objectives of the bias evaluation.'
 'The response suggests that a comprehensive evaluation framework will involve a combination of existing and potentially new metrics.'
 'The response demonstrates an understanding of the complexity of bias in text-to-image generation and the need for a multi-faceted evaluation approach.']","To develop a comprehensive evaluation framework for assessing biases in a text-to-image generation model, we need to follow a structured approach that involves understanding the types of biases present, designing appropriate prompts, classifying attributes in generated images, and applying relevant metrics to quantify bias.

First, we define the scope of our bias evaluation by identifying the types of gender bias: context-to-gender bias and gender-to-context bias. Context-to-gender bias occurs when gender-neutral prompts result in unequal probabilities of generating images of different genders. Gender-to-context bias happens when the presence of gender-indicating words in prompts leads to significant differences in the context of the generated images.

Next, we design prompts that serve as semantic guidance for text-to-image generation. We use template-based prompts, such as ""a photo of [DESCRIPTION],"" where [DESCRIPTION] can include professions, adjectives, or activities. This allows us to investigate context-to-gender bias across various scenarios. Additionally, we utilize captions from vision-language datasets as natural language prompts and leverage large language models for prompt generation. We also create counterfactual prompts by swapping gender-neutral words with gendered terms to compare generated images when only the gender reference changes.

To evaluate gender bias in generated images, we need to assign protected attributes like gender based on the appearance of people in the images. We apply several methods for attribute classification: 
1. Using a gender classifier on generated faces.
2. Utilizing embeddings from vision-language models (like CLIP, BLIP 2, InternVL) to compare with text embeddings of sentences like ""a photo of a woman/man"" and assign gender based on the highest similarity.
3. Employing visual question answering (VQA) models by asking questions like ""What is the gender of the person?""
4. Relying on human annotation for assigning gender to generated images.

Beyond gender, we examine other attributes such as attire, concepts, and objects in the generated images.

For quantifying bias, we categorize evaluation metrics into three types: distribution metrics, bias tendency metrics, and quality metrics. 
1. **Distribution Metrics**: We use Mean Absolute Deviation (MAD) to measure differences between the detected attribute distribution and an unbiased distribution. The chi-square test is applied to determine significant differences in generated attributes from counterfactual prompts.
2. **Bias Tendency Metrics**: We assess whether attributes in generated images are biased towards a specific gender. Metrics include calculating the proportion of predicted genders, comparing these proportions with real-world data, and using metrics like Stereotype Score and Gender Presentation Differences (GEP) to evaluate specific aspects of bias. 
3. **Quality Metrics**: We evaluate the semantic alignment between images and prompts using metrics like CLIPScore and human evaluation. Fréchet Inception Distance (FID) is used to compare generated images with real images under gendered prompts.

By combining these approaches, we develop a comprehensive evaluation framework that assesses bias from multiple angles, including distribution, tendency, and quality aspects. This framework will involve a combination of existing and potentially new metrics tailored to the specific objectives of the bias evaluation. The choice of metrics depends on whether we are examining context-to-gender bias, gender-to-context bias, or the overall quality of generated images.

Our comprehensive evaluation will enable us to quantify and analyze bias in text-to-image generation models thoroughly, providing insights necessary for developing more equitable models. This approach acknowledges the complexity of bias and the need for a multi-faceted evaluation strategy.",2f90826d466de6ec,e1c8d01c2968c142,cs,cs.CY,2408.11358
"You are evaluating the impact of quantization on a multilingual LLM across a variety of tasks and languages. The model is being considered for deployment in a real-world setting where it will be used for open-ended generation tasks. You have conducted automatic evaluations using standard benchmarks but are concerned that these metrics might not fully capture the effects of quantization on model performance. You need to design a comprehensive evaluation plan that includes human evaluation to assess the model's performance on realistic prompts. How would you approach this problem, and what considerations would you take into account when comparing automatic and human evaluation results?","['The evaluation plan includes human evaluation on a subset of tasks and languages to validate automatic metrics.'
 'The human evaluation is conducted on realistic prompts that are representative of real-world usage scenarios.'
 'The evaluation plan compares the results of automatic metrics with human evaluation to identify any discrepancies.'
 'The analysis considers the complexity and difficulty of the tasks and prompts used in the human evaluation.'
 'The human evaluation is conducted by native speakers or fluent annotators for the languages being tested.'
 'The comparison between automatic and human evaluation results is done across different levels of quantization.'
 'The analysis accounts for potential biases in human evaluation, such as annotator variability and cultural factors.'
 'The comparison includes an analysis of how well automatic metrics correlate with human judgments across different tasks and languages.'
 'The analysis provides insights into why automatic metrics might underestimate or overestimate the damage caused by quantization.'
 'The comparison between automatic and human evaluation results informs recommendations for future model evaluation and deployment.']","To comprehensively evaluate the impact of quantization on a multilingual LLM across various tasks and languages, we design a research plan that incorporates both automatic and human evaluations.

First, we select a set of representative multilingual LLMs, including Command R+, Command R, and Aya 23 models, which vary in size from 8 to 103 billion parameters and support up to 23 languages. We apply different quantization techniques to these models, including weight-only quantization (W8 and W4-g) and weight-and-activation quantization (W8A8), to understand their effects on model performance.

For automatic evaluation, we use a range of benchmarks that assess different aspects of the models' capabilities, such as multilingual MMLU, MGSM, FLORES-200, and Language Confusion. These benchmarks cover 10 primary languages: Arabic, French, German, English, Spanish, Italian, Portuguese, Korean, Japanese, and Chinese. We compare the performance of quantized models to their FP16 counterparts, reporting relative degradation.

To validate the automatic metrics and gain insights into the models' performance on realistic prompts, we conduct human evaluation on a subset of tasks and languages. We select Spanish, French, Korean, Japanese, and English for human evaluation, using internal evaluation suites with 150 diverse prompts designed to be more complex than public benchmarks, as well as the Aya Dolly-200 test set for open-ended generation tasks. Human annotators, who are native-level speakers of the respective languages and fluent in English, rate the outputs of FP16 and quantized models on a 5-point Likert scale and express their preference.

In addition to human evaluation, we use LLM-as-a-Judge and RM-as-a-Judge to rate model completions. We employ GPT-4 as the LLM proxy judge and a multilingual RM to score prompt-completion pairs. This allows us to compare the results of automatic metrics with both human evaluation and LLM/RM-as-a-Judge, identifying any discrepancies and understanding how well automatic metrics correlate with human judgments.

We analyze the results across different levels of quantization, tasks, languages, and model sizes. We also investigate the effect of quantization strategies like SmoothQuant and group-wise scaling on downstream performance. By comparing the performance of quantized models in English versus other languages, we assess whether the impact of quantization varies across languages.

Our evaluation plan is designed to be scalable and adaptable to different models and quantization techniques. By combining automatic and human evaluations, we provide a comprehensive understanding of the impact of quantization on multilingual LLMs. The comparison between automatic and human evaluation results informs recommendations for future model evaluation and deployment, highlighting the importance of considering multilingual performance at all stages of system design.

The limitations of our study include the focus on a specific set of models and languages. Future work could extend this evaluation to other models, languages, and quantization techniques, as well as explore methods to mitigate the disparate impact of quantization on different languages.

By following this research plan, we aim to provide a thorough understanding of how quantization affects multilingual LLMs and to inform the development of more robust and equitable language models.",36ed11d98901880c,46801c714d1f22b7,cs,cs.CL,2407.03211
"You are analyzing the limitations of existing Temporal Graph Neural Network (TGNN) architectures, particularly their ability to capture information from distant nodes in temporal graphs. You need to understand how the temporal dimension affects the propagation of information between nodes and identify the specific challenges posed by temporal under-reaching. Your goal is to provide a theoretical analysis of temporal under-reaching in TGNNs and explain how it differs from static under-reaching. Propose a definition for temporal under-reaching and discuss its implications for TGNN performance.","['The analysis should clearly define temporal under-reaching and its relation to the temporal dimension.'
 'The proposed definition should account for the directionality of temporal edges.'
 'The analysis should demonstrate that temporal under-reaching is more severe than static under-reaching.'
 'The discussion should highlight the asymmetry of temporal under-reaching.'
 'The discussion should touch on the effects of dynamic node and edge updates on temporal under-reaching.'
 'The proposed definition should be applicable to continuous-time dynamic graphs.'
 'The analysis should provide examples or counterexamples to illustrate the concept of temporal under-reaching.'
 'The discussion should relate temporal under-reaching to the limitations of existing TGNN architectures.'
 'The analysis should consider the role of node and edge features in temporal under-reaching.'
 'The analysis should provide a clear motivation for developing methods to alleviate temporal under-reaching.']","To address the limitations of existing Temporal Graph Neural Network (TGNN) architectures, particularly their ability to capture information from distant nodes in temporal graphs, we need to understand how the temporal dimension affects the propagation of information between nodes and identify the specific challenges posed by temporal under-reaching.

First, we define temporal under-reaching and its relation to the temporal dimension. Temporal under-reaching occurs when the features of a node $u$ are not temporally mixed into node $v$'s memory at time $\tau$, meaning there is no sequence of nodes $u \xrightarrow{t_0} w_1 \xrightarrow{t_1} \ldots \xrightarrow{t_{n-1}} w_n \xrightarrow{t_n} v$ such that $t_0 < t_1 < \cdots < t_n$. This definition accounts for the directionality of temporal edges, as the sequence of edges must be in chronological order.

We demonstrate that temporal under-reaching is more severe than static under-reaching by considering a simple ""path temporal graph"" where the only edges are $(u, w_1, t_0), (w_1, w_2, t_1), \ldots, (w_n, v, t_n)$. A static GNN over this graph with $n+1$ layers would not exhibit under-reaching between $u$ and $v$, but temporal under-reaching occurs if $t_0 > t_1 > \cdots > t_n$ is not satisfied.

Temporal under-reaching is also asymmetric, as shown by the same ""path temporal graph"" example. If node $u$ does not temporally under-reach into node $v$, it must hold that node $v$ temporally under-reaches into $u$. This asymmetry arises because the temporal edges have a direction in time.

Temporal batching exacerbates temporal under-reaching, as edges within the same batch cannot feature on the same mixing path. This means that the constraint on the mixing path becomes $b(t_0) < b(t_1) < \cdots < b(t_n)$, where $b(t)$ is the batch identifier for an edge at time $t$, making it a stricter condition than $t_0 < t_1 < \cdots < t_n$.

Dynamic node and edge updates further complicate temporal under-reaching. When new information enters the temporal graph, either as novel node or edge features or entirely new nodes, the condition for temporal mixing becomes $t \leq t_0 < t_1 < \cdots < t_n$, where $t$ is the time of the update. This stricter condition increases the likelihood of temporal under-reaching.

Temporal under-reaching affects TGNN performance on link prediction tasks, as nodes may not be able to capture relevant information from distant nodes. This limitation is particularly significant in bipartite graphs or graphs with high surprise indices, where traditional TGNN architectures struggle to distinguish between nodes.

To alleviate temporal under-reaching, we propose using Temporal Graph Rewiring (TGR) with expander graphs. TGR enhances input node features with expander embeddings computed through memory mixing, facilitating information exchange between disconnected and distant nodes. By utilizing expander graphs, TGR provides additional information about potentially unreachable nodes to the base TGNN model.

The TGR framework consists of memory mixing using expander graphs and expander embeddings that translate this information to the base TGNN model. We leverage the expander graph propagation framework, known for alleviating over-squashing and under-reaching in static graphs, and adapt it for temporal graph learning.

To evaluate TGR, we conduct experiments on the dynamic link property prediction task using the Temporal Graph Benchmark (TGB). We implement TGR on top of state-of-the-art TGNN models, TGN and TNCN, and demonstrate that TGR improves their performance on various datasets. The results show that TGR achieves state-of-the-art performance on several datasets, highlighting its effectiveness in alleviating temporal under-reaching.

Our analysis provides a clear motivation for developing methods to alleviate temporal under-reaching, and TGR represents a promising first step towards applying temporal graph rewiring to optimize TGNN performance. Future work can investigate other graph rewiring methods and compare their performance to TGR.",04285120a7ddbaab,95fb8b9c1eeb22a9,cs,cs.LG,2406.02362
"You are designing a data management system for a large-scale research project in Life & Earth sciences. The project involves collecting and integrating diverse datasets from various sources, including sensors, experiments, and observational studies. Your goal is to create a data storage and sharing system that enables researchers to publish, cite, and discover datasets while providing metadata and tools to ensure others can understand and use the data. Describe how you would design the data storage and sharing system to meet the needs of the research community.","['The proposed system is based on a data lake architecture.'
 'The system includes the concept of ""dataverses"" within the data lake.'
 'Dataverses are used to create a networked space where data is stored, managed, and shared.'
 'The dataverse concept is used to enable researchers to publish, cite, and discover datasets.'
 'The system provides metadata and tools to ensure others can understand and use the data.'
 'The dataverse is a data repository platform that provides features such as data version control and digital object identifiers (DOIs) for citation.'
 'The system is designed to support the principles of open science.'
 'The system is designed to facilitate interdisciplinary collaboration.'
 'The dataverse is used to store, access, share, and analyze datasets.'
 'The system enables researchers to replicate studies and build upon existing work.']","To design a data management system for a large-scale research project in Life & Earth sciences, we will adopt a data lake architecture that incorporates the concept of ""dataverses."" This approach will enable the storage, sharing, and analysis of diverse datasets from various sources, including sensors, experiments, and observational studies.

First, we will construct a data lake that stores raw data in its original format. This will involve gathering heterogeneous raw data from various sources, such as digital sources (e.g., observation stations, social media, and the Web) and in situ collectors (e.g., sensors and experimental equipment). The data lake will be designed to accommodate a range of data types, including structured, semi-structured, and unstructured data.

To ensure that the data is properly curated and managed, we will implement a ""researcher-in-the-loop"" (RITL) approach. This involves actively involving scientists in the curation process, combining automated, mathematical, and manual tasks to address complex problems. The RITL approach will enable the assessment of content concerning the conditions in which it is produced and make decisions about new tasks to perform and how a research project will move forward.

The data lake will include a metadata model that represents the structural, semantic, and contextual aspects of the data. This will involve developing a meta-model that captures the quantitative and qualitative perspectives of the data, including provenance, conditions, and assumptions under which analytical results are obtained. The metadata model will be designed to make the content of the data lake findable, accessible, interoperable, and reusable (FAIR principles).

To facilitate data sharing and collaboration, we will create ""dataverses"" within the data lake. A dataverse is a networked space where data is stored, managed, and shared within the scientific community. Dataverses will enable researchers to publish, cite, and discover datasets while providing metadata and tools to ensure others can understand and use the data. The dataverse concept will be used to promote data sharing across disciplinary boundaries, facilitate interdisciplinary collaboration, and enable researchers to replicate studies and build upon existing work.

The dataverse will be designed to provide features such as data version control and digital object identifiers (DOIs) for citation. It will also include robust metadata standards and tools to ensure that datasets are well-described and discoverable. The dataverse will be community-driven, emphasizing the accessibility and reusability of research data.

To test the data lake and dataverse, we will conduct pilot experiments in collaboration with domain experts in seismology and biodiversity studies. The pilot experiments will involve classifying seismic signals and in situ observations of the ""carabela portuguesa"" and modeling its behavior on the Brazilian coast.

The proposed system will be designed to support the principles of open science, promoting data sharing, collaboration, and reproducibility. By providing a robust and flexible data management system, we aim to strengthen the capacity of Life & Earth sciences to solve some of the world's most critical environmental and biological challenges.

The data lake will be maintained and exploited through a curation approach that involves quantitative and qualitative data curation. The curation process will include data discovery, exploration, selection, and integration, as well as data cleaning and engineering. The curated data will be shared in the dataverse, enabling researchers to access, analyze, and build upon existing work.

Overall, our proposed system will provide a comprehensive data management solution for Life & Earth sciences research, enabling the storage, sharing, and analysis of diverse datasets and promoting collaboration, reproducibility, and scientific discovery.",157e3263d25e6220,5686642f70ed5cd4,cs,cs.DB,2403.20063
"You are tasked with developing a model for image aesthetics assessment (IAA) that can effectively extract relevant features from images and their associated user comments. You have access to pre-trained visual and textual encoders that have been trained on large-scale datasets. However, you are constrained by limited computational resources and a relatively small dataset for fine-tuning. You need to design a model that can efficiently utilize the pre-trained encoders and adapt to the specific task of IAA. What approach would you take to develop such a model, and how would you test its effectiveness?","['The method should be computationally efficient and able to adapt to the limited computational resources.'
 'The approach should involve a mechanism for fine-tuning or adapting the pre-trained encoders to the IAA task.'
 'The model should be able to handle the relatively small dataset for fine-tuning.'
 'The proposed method should be able to extract relevant features from both images and user comments.'
 'The model should be able to capture task-specific features and patterns in the data.'
 'The proposed approach should be robust to overfitting and able to handle the limited fine-tuning data.'
 'The approach should involve a well-defined evaluation metric for assessing its performance.'
 'The proposed method should be compared to existing state-of-the-art methods for IAA.'
 'The model should be able to generalize to new, unseen data and images.'
 'The proposed method should be able to leverage the strengths of both visual and textual modalities.']","To develop a model for image aesthetics assessment (IAA) that effectively extracts relevant features from images and their associated user comments, we will utilize a multi-modal learnable queries (MMLQ) approach. This method leverages pre-trained visual and textual encoders, MMLQ, to efficiently extract and process multi-modal aesthetic features.

1. **Pre-trained Visual and Textual Encoders**: We will employ frozen pre-trained vision transformers (ViT) as the visual encoder and BERT base as the textual encoder. The visual encoder will split the input image into patch tokens and a [CLS] token, extracting pre-trained image features. The textual encoder will encode the accumulated user comments into token-level embeddings.

2. **Multi-modal Learnable Queries (LQs)**: A set of learnable queries will be created to extract visual and textual aesthetic features. These LQs will be shared among samples and normalized with separate layer normalization.

3. **Multi-modal Interaction Blocks (MMIB)**: The LQs will go through multiple MMIBs, each consisting of a replaceable self-attention (SA) layer, a separate multi-modal cross-attention (CA) layer, and a replaceable feed-forward (FF) layer. The CA layer will extract aesthetic features from pre-trained visual and textual features.

4. **Prediction Head**: After multiple MMIBs, the averaged visual and textual LQs will be concatenated and fed into linear layers followed by Softmax to output the estimated aesthetic distribution of opinion scores (DOS).

5. **Optimization**: The model will be optimized using Earth Mover's Distance (EMD) loss between the predicted and ground truth DOS.

**Implementation Details**:
- We will use the AVA dataset for training and testing, with the same split as in previous works.
- The visual encoder will be ViT-L/14 from CLIP or ViT-G/14 from EVA-CLIP, with a patch size of 14x14, resulting in 256 patches for each input image.
- The textual encoder will be BERT base, with a maximum comment length of 512.
- We will set the query hidden size to 768, and the number of visual and textual queries to 2.
- The model will be trained with a batch size of 128 for 10 epochs using the Adam optimizer, with an initial learning rate of 3 × 10^−5, and multiplied by 0.1 every two epochs.

**Justification**:
The MMLQ approach is chosen because it efficiently utilizes pre-trained encoders and adapts to the specific task of IAA. By using frozen pre-trained encoders, we reduce the computational resources required for training. The learnable queries mechanism allows the model to extract task-specific features from the pre-trained features. The multi-modal interaction blocks enable the model to capture the complementarity of visual and textual modalities in extracting aesthetic features.

**Advantages**:
- The MMLQ method is computationally efficient and can adapt to limited computational resources.
- It can handle the relatively small dataset for fine-tuning by leveraging pre-trained encoders.
- The model can extract relevant features from both images and user comments.
- The approach involves a clear and well-defined strategy for utilizing pre-trained encoders.

By following this research plan, we aim to develop an effective MMLQ model for IAA that can efficiently extract and process multi-modal aesthetic features, achieving state-of-the-art performance on the benchmark AVA dataset.",c7dde16e91178745,599c7bb48f5bd585,cs,cs.CV,2405.01326
"You are a researcher working on a project to estimate individualized treatment effects (ITE) in a healthcare setting. You have access to data from multiple hospitals, each with its own unique patient population, treatment protocols, and outcome measures. However, due to privacy concerns and data usage agreements, you are not allowed to pool the data from different hospitals into a centralized location. Your goal is to develop a framework that can collaboratively learn from the distributed data across hospitals while maintaining data privacy. The framework should be able to handle heterogeneous features, treatments, and outcomes across different hospitals. How would you approach this problem?","['The proposed framework should be able to handle data from multiple sources without requiring data to be pooled into a centralized location.'
 'The framework should be able to accommodate heterogeneous features across different hospitals.'
 'The framework should be able to handle different treatment protocols across hospitals.'
 'The framework should be able to handle diverse outcome measures across hospitals.'
 'The framework should utilize a federated learning approach to maintain data privacy.'
 'The framework should include a mechanism for learning a common representation space for patient covariates across hospitals.'
 'The framework should be able to capture complex relationships between covariates and treatments.'
 'The framework should include a personalized predictor for each hospital to handle diverse outcomes.'
 'The framework should be able to operate within the context of observational data where treatment assignment is non-randomized.'
 'The framework should be able to leverage supplementary information about treatments.']","To address the problem of estimating individualized treatment effects (ITE) in a healthcare setting with data from multiple hospitals, we propose a novel framework called Federated Transformers for Treatment Effects Estimation (FedTransTEE). This framework is designed to collaboratively learn from distributed data across hospitals while maintaining data privacy.

First, we utilize a federated learning (FL) approach to enable collaborative learning across hospitals without pooling their data into a centralized location. FL involves learning across numerous organizations or end devices known as clients, each maintaining access to local data while collaborating through a central server.

To accommodate heterogeneous features across different hospitals, we design a covariate encoder that can work with diverse feature sets. The covariate encoder is based on transformers, which have exhibited remarkable proficiency in learning representations and processing inputs of varying lengths. Each patient covariate vector undergoes processing to generate a sequence of tokens, which is then fed through a learnable embedder to convert it into a sequence of 256-dimensional embeddings. These embeddings are processed through a transformer network consisting of k-layers of multi-headed self-attention modules.

To capture treatment-specific information, we employ a treatment encoder that converts specific treatments into 256-dimensional embeddings. The treatment encoder includes an optional treatment information encoder, which processes information like textual descriptions or drug compositions about the treatments to create a representation of the treatment in a high-dimensional space.

The covariate and treatment embeddings are then fed into a cross-attention module, which models the interaction between them through a cross-attention transformer block. The cross-attention module uses the treatment embedding as the query and the sequence of feature embeddings in the patient embedding as the keys and values.

To handle diverse outcome measures across hospitals, we employ a personalized predictor for each hospital. The predictor is constructed from a two-layer MLP with ReLU activation non-linearity and is used to predict the observed outcome for the given treatment and covariate vector.

The overall training process consists of E communication rounds between the clients and e local training epochs on individual clients. In each communication round, the globally aggregated covariate encoder, treatment encoder, and cross-attention module are broadcasted to all clients. The clients initialize their corresponding local modules with the obtained global modules and train the entire local model for e epochs.

The local optimization at each client involves an alternate minimization procedure where the predictor and representation learning modules are optimized alternatively on the mean squared error loss between the prediction and the true outcome of the treatment on the given patient.

To leverage supplementary information about treatments, we utilize the treatment information encoder to process information like textual descriptions or drug compositions about the treatments. This enables the framework to estimate the effects of novel and unseen treatments by utilizing the available treatment level information.

We evaluate the proposed framework on real-world clinical trial and research datasets to demonstrate its efficacy in ITE estimation. The performance is assessed using metrics such as Root Mean Squared Error on the factual outcome (RMSE-F), Error in the Average Treatment Effect (ATE ϵ ), and Precision in the Estimation of Heterogeneous Effects (PEHE).

By following this approach, we can develop a framework that can collaboratively learn from distributed data across hospitals, accommodate heterogeneous features and treatment protocols, and handle diverse outcome measures while maintaining data privacy.",158c60c4c87d18ca,4429e2a9d19f30ca,cs,cs.LG,2402.17705
"You are working on a cross-domain named entity recognition (NER) task where the source domain data has general entity types, and the target domain data has more fine-grained annotation. The goal is to develop a model that can effectively transfer knowledge from the source domain to the target domain. However, you notice that the label distributions between the two domains are inconsistent, leading to label conflicts. Propose a novel approach to address this label conflict problem and improve the model's performance on the target domain.","['The proposed approach should explicitly address the label conflict problem between the source and target domains.'
 'The approach should involve aligning the labels between the source and target domains.'
 'The approach should include reassigning the labels to the target domain entities based on the aligned labels.'
 'The method should be able to handle the difference in granularity between the source and target domain entity types.'
 'The approach should be applicable to both supervised and zero-shot out-of-domain settings.'
 'The proposed method should be able to leverage the knowledge from the source domain to improve performance on the target domain.'
 'The method should be able to handle cases where the target domain has limited annotated data.'
 'The approach should be robust to variations in the label distribution between the source and target domains.'
 'The proposed method should be able to handle multiple target domains with different label distributions.'
 'The approach should be efficient in terms of computational resources and training time.']","To address the label conflict problem in cross-domain named entity recognition (NER), we propose a label alignment and reassignment approach. The goal is to effectively transfer knowledge from a source domain with general entity types to a target domain with more fine-grained annotation, despite inconsistent label distributions between the two domains.

First, we train a generative language model on the source domain data under the standard supervised setting. This step equips the model with entity knowledge from the source domain. We denote this initial model as $M_s$.

Next, we perform label alignment between the source and target domains. We use $M_s$ to predict pseudo labels on the target domain train set. By comparing these pseudo labels with the gold labels, we determine the mapping relationship between source domain types and target domain types based on statistical results. For instance, if the majority of entities with type ""musician"" in the target domain are predicted as ""person"" by $M_s$, we assign ""musician"" to ""person"". Some target entity types may not be recognized due to the limitation of source domain knowledge; we generalize these as miscellaneous. This process results in a one-to-many or many-to-one mapping between source and target entity types.

After label alignment, we fine-tune $M_s$ on the target domain dataset with label reassignment. We represent every sample on the target domain as a triplet $(S, Y_s, Y_t)$, where $Y_s$ and $Y_t$ denote entity types on the source and target domains, respectively. We modify the textualized labels to $Y_s$: $S_{i:j}$ => $Y_t$, maximizing the use of $M_s$'s prior knowledge. This label reassignment enables the model to learn the mapping between source and target types.

For prediction on the target domain, the model $M_t$ (fine-tuned on the target domain) has basic target entity knowledge. However, its ability to recognize entities with target domain types is weaker than with source domain types due to the complexity and scarcity of target domain data. To enhance this, we leverage an external knowledge source like GPT-3.5. We formulate the label reassignment as a multiple-choice question that GPT-3.5 can understand, effectively improving the model's discrimination between similar types.

Our approach is applicable to both supervised and zero-shot out-of-domain settings. In the zero-shot scenario, we prompt GPT-3.5 to produce synthetic labels for target domain samples, replacing gold labels.

We evaluate our method on CrossNER datasets and other classic NER datasets, comparing it to state-of-the-art cross-domain NER methods. Our experiments demonstrate that our approach achieves remarkable performance under both supervised and zero-shot out-of-domain settings.

The label alignment step is crucial as it allows the model to understand the relationship between source and target entity types, thereby addressing the label conflict problem. The ablation study on label alignment shows that it significantly improves model performance, especially in low-resource supervised learning scenarios.

The enhanced inference with GPT-3.5 further boosts the model's performance by improving its ability to discriminate between similar entity types. Type-wise quantitative analysis shows that enhanced inference outperforms direct inference on most types.

Our method also exhibits robustness in continual learning settings, showing a more gradual decline in performance compared to original transfer learning without label alignment.

In conclusion, our label alignment and reassignment approach effectively addresses the label conflict problem in cross-domain NER. By leveraging a generalist large language model for enhanced inference, our method performs well in both supervised and zero-shot out-of-domain settings, demonstrating its potential for real-world applications.",a89728074ec1072c,86139817b406de33,cs,cs.CL,2407.17344
"You are tasked with developing a generative model for retinal fundus images that can produce high-quality, realistic images while allowing for controllable feature changes. The model should be able to encode patient attributes and technical factors into separate latent subspaces. Your dataset consists of retinal fundus images with associated metadata, including age, ethnicity, and camera type. You want to extend a state-of-the-art generative adversarial network (GAN) architecture to achieve this. Propose a method to modify the GAN to encode label information into subspaces while ensuring their independence and describe how you would evaluate the image generation quality and controllability.","['The proposed method should be based on a state-of-the-art GAN architecture.'
 'The method should include individual mapping networks for each subspace to encode label information.'
 'The proposal should incorporate a disentanglement loss to ensure independence between subspaces.'
 'The disentanglement loss should be based on a measure that captures both linear and nonlinear dependencies between subspaces.'
 'The method should allow for controllable image generation through subspace manipulation.'
 'The evaluation should include metrics for assessing image quality, such as Frechet Inception Distance (FID).'
 'The proposal should outline a plan for evaluating the controllability of image generation through subspace swapping experiments.'
 'The method should be capable of handling multiple subspaces for different patient attributes and technical factors.'
 'The proposal should outline a plan for assessing the robustness of the image generation quality to different subspace configurations.'
 'The method should be evaluated on its potential to generate realistic counterfactual images by manipulating specific subspaces.']","To develop a generative model for retinal fundus images that produces high-quality, realistic images while allowing for controllable feature changes, we will extend a state-of-the-art generative adversarial network (GAN) architecture. The model will encode patient attributes and technical factors into separate latent subspaces.

First, we will use the StyleGAN2 architecture as our base GAN model due to its ability to generate high-fidelity and high-resolution images. We will modify this architecture to sample individual latent codes from a standard normal distribution for each subspace, allowing us to encode different factors of variation (e.g., age, ethnicity, camera type) independently.

To achieve this, we will implement individual mapping networks for each subspace. These mapping networks will map the sampled latent codes to intermediate latent spaces that control the styles in each convolutional layer of the generator. By doing so, we can encode label information for real images into the corresponding subspaces.

To ensure the independence of the subspaces, we will incorporate a disentanglement loss based on distance correlation. Distance correlation is a measure that captures both linear and nonlinear dependencies between random vectors of arbitrary dimensions. By minimizing the distance correlation between the subspaces, we can prevent the subspaces from being correlated and sharing information.

The overall objective function for our model will include the standard GAN loss, path length regularization, and an R1 regularizer as a gradient penalty on the discriminator for real data. Additionally, we will include the disentanglement loss to enforce independence between the subspaces.

To evaluate the image generation quality, we will use the Frechet Inception Distance (FID) score, which assesses the difference between the distribution densities of real and fake images in the feature space of an InceptionV3 classifier. We will also assess the controllability of image generation through subspace swapping experiments, where we swap the subspaces of different images and evaluate the resulting generated images.

We will consider the dimensionality of each subspace and its impact on image generation quality. The dimensionality of each subspace will be selected based on the dimensions of the labels we aim to encode.

To train the model, we will use a dataset of retinal fundus images with associated metadata, including age, ethnicity, and camera type. We will preprocess the images by cropping them to a tightly centered circle and resizing them to a resolution of 256 × 256 pixels.

We will implement the model using PyTorch and PyTorch Lightning, and train it on multiple GPUs with a batch size of 56 distributed over 4 GPUs. We will use a data ring buffer on every GPU to store a number of data batches from the past for distance correlation computation.

Hyperparameter tuning will be essential to balance the disentanglement loss, feature encoding, and image generation tasks. We will monitor the FID score, image encoding loss, and pixel space reconstruction loss to ensure that the additional constraints for learning disentangled subspaces do not affect the image quality.

By following this plan, we aim to develop a generative model that can produce high-quality, realistic retinal fundus images while allowing for controllable feature changes through subspace manipulation. The model will be capable of handling multiple subspaces for different patient attributes and technical factors, and will provide a useful tool for understanding the interplay between these factors.",d15337261f650ddd,a115c11354f5ac76,cs,cs.CV,2402.19186
"You are tasked with evaluating the quality of stories generated by various models for the visual storytelling task. The goal is to develop an evaluation method that effectively captures the key aspects of a 'good' story. However, there's a lack of consensus on what makes a story 'good', and absolute metrics for dimensions like coherence, visual grounding, and repetition may not be sufficiently informative due to the absence of standard conventions for their optimal levels. How would you design an evaluation method that can effectively compare model-generated stories to human-written stories, considering these challenges?","[""The proposed evaluation method should be human-centric, focusing on the 'closeness' of generated stories to human-written stories.""
 'The method should consider multiple dimensions such as coherence, visual grounding, and non-repetitiveness.'
 'The evaluation should be relative, comparing model-generated stories to human-generated stories rather than relying on absolute metrics.'
 'The method should acknowledge the lack of standard conventions for optimal levels of coherence, grounding, or repetition.'
 'The evaluation method should be applicable to various models, including those specifically designed for visual storytelling and general-purpose foundation models.'
 'The method should be able to handle the variability in plausible stories for a given image sequence.'
 'The evaluation should be based on reference-free metrics that do not directly compare generated stories to a specific ground-truth story.'
 ""The evaluation method should facilitate the comparison of different models' performance on the visual storytelling task.""
 'The method should be grounded in the understanding that visual storytelling is a creative task with inherent variability.'
 'The evaluation should account for the subjective nature of story quality.']","To address the task of evaluating the quality of stories generated by various models for the visual storytelling task, we propose a human-centric evaluation method. This method assesses the 'closeness' of generated stories to human-written stories along multiple dimensions: coherence, visual grounding, and non-repetitiveness.

First, we select three reference-free metrics to measure these dimensions: GROOViST for visual grounding, a modified version of RoViST-C for coherence, and RoViST-NR for repetition. We apply these metrics to both model-generated and human-written stories for the same image sequences.

For a given image sequence, we compute the scores for model-generated and human-written stories using the selected metrics. We then calculate the absolute differences between the scores of human and model-generated stories for each dimension. These differences are denoted as $d_C^{HM}$, $d_G^{HM}$, and $d_R^{HM}$ for coherence, visual grounding, and repetition, respectively.

The overall distance between the model-generated story and the human-written story is computed as the average of these differences: $d_{HM} = (d_C^{HM} + d_G^{HM} + d_R^{HM})/3$. This $d_{HM}$ score represents how close the model-generated story is to the human-written story across the considered dimensions.

We evaluate various models using this method, including those specifically designed for visual storytelling (GLAC Net, AREL, TAPM) and general-purpose foundation models (BLIP-2, LLaVA). The models are tested on the VIST dataset, and their performance is compared based on the $d_{HM}$ score.

To gain further insights, we upgrade the TAPM model by replacing its language and vision components with more advanced models (LLaVA's vision encoder and LLaMA 2 language model). We train these upgraded versions (+ViT and +LLaMA 2) on the VIST dataset and evaluate their performance.

We also conduct a qualitative human evaluation study to validate the effectiveness of our $d_{HM}$ metric. Human annotators compare stories generated by the best-performing models (TAPM +LLaMA 2 and LLaVA) with human-written stories, assessing which story is better or if both are similarly fine or bad.

The results of our evaluation method show that LLaVA achieves the lowest $d_{HM}$ score, indicating its generated stories are closest to human-written stories. The upgraded TAPM models also show improved performance, with (+LLaMA 2) achieving a comparable $d_{HM}$ score to LLaVA despite being significantly smaller.

The human evaluation study reveals that while the $d_{HM}$ metric effectively captures key aspects of visual stories, human annotators still prefer human-written stories over model-generated ones. This suggests that a 'good' story may involve more than just coherence, visual grounding, and non-repetitiveness, such as creative expressions, emotions, and overarching narratives.

Our evaluation method provides a comprehensive framework for comparing the performance of different models on the visual storytelling task. By considering multiple dimensions and comparing model-generated stories to human-written ones, we can gain a deeper understanding of the strengths and weaknesses of various models and identify areas for improvement.",a4470cfb5dbaabfe,117cde7a25a175d6,cs,cs.CL,2407.04559
You are working on a malware classification project where the goal is to detect zero-day malware attacks that have been obfuscated using techniques like junk code and no-operation code insertions. Your task is to develop a novel classification model that can effectively capture the complex nonlinear relationships between features in different malware samples. You need to leverage a Siamese Neural Network (SNN) and address the challenge of noise introduced by obfuscation techniques. Propose an innovative approach that combines SNN with another technique to enhance its robustness against obfuscation.,"['The proposed approach should combine a Siamese Neural Network (SNN) with denoising autoencoders.'
 'The denoising autoencoder should be used to reconstruct the input data and reduce the impact of noise.'
 'The approach should be trained using a few-shot learning mechanism to adapt to new malware classes.'
 'The denoising autoencoder should be integrated with the SNN to enhance its robustness against obfuscation.'
 'The proposed approach should be evaluated on a dataset that includes obfuscated malware samples.'
 'The solution should compare the performance of the combined SNN and denoising autoencoder with existing methods.'
 'The approach should discuss the importance of capturing nonlinear relationships between malware features.'
 'The model should be robust against variations in malware samples due to obfuscation techniques.'
 'The solution should outline the architecture of the denoising autoencoder and its integration with the SNN.'
 'The proposed approach should be tested using a suitable few-shot learning scenario.']","To address the challenge of detecting zero-day malware attacks that have been obfuscated using techniques like junk code and no-operation code insertions, we propose a novel classification model that leverages a Siamese Neural Network (SNN) and addresses the challenge of noise introduced by obfuscation techniques.

Our approach involves a few-shot classification task using a Siamese denoising autoencoder against junk code obfuscation. We start by converting malware samples into entropy images, which measure the uncertainty distribution of the information. This step is crucial as it preserves the connected information of each entropy sequence in the context of the raw bytecode data, and enables our model to extract better structural information and subtle differences in malware signatures.

The SNN model is useful for pairwise identity verification and takes as input two images to identify a meaningful distance between their representations. Each sub-network is parameterized by shared weights and bias, performed on both input images regardless of whether they are the same. The connection between the encoder and decoder parts of the autoencoder enables us to extract features optimized by the Siamese denoising autoencoder.

A relation-aware function calculates the correlation between the two input images based on the latent features in the last fully connected layers within the encoder. This correlation is used to predict whether the two malware samples are similar or not. The contrastive loss is computed to calculate their relationship, and the classification ability depends on the performance of this relation score.

Our model incorporates a relation-aware Siamese denoising autoencoder that enhances the conventional SNN with relational semantic information. We jointly learn new representations in the non-linear relationships between malware samples, which are assumed to represent the concatenation of feature maps in depth. This allows us to explore a learnable rather than fixed metric or non-linear rather than linear classifier.

The network architecture of our model consists of 4 convolutional and batch-normalization layers. The input size is denoted as H × W × C, where C represents the number of color components. We consider C = 1 for the entropy images due to the conversion to grayscale images. The encoder part is designed with 4 convolution layers, each followed by a batch normalization layer and ReLU activation layer. A max pool layer is added after the first convolution layer, and two linear layers are used to improve the classification performance with the extracted features.

We evaluate the performance of our proposed model on two malware datasets, VUW and Malimage, according to the few-shot learning mechanism. We conduct ablation experiments to analyze the effect of various parameters, such as pooling methods, layer dimension, and hyperparameters.

The results show that our model achieves the highest accuracy on both datasets, outperforming existing methods. The use of entropy images and the relation-aware Siamese denoising autoencoder enables our model to effectively capture the complex nonlinear relationships between features in different malware samples and distinguish between different malware signatures.

In the future, we aim to broaden the scope of our research by incorporating a more extensive range of malware samples and various other obfuscation techniques, such as code hiding using Packers/XOR/Base64, Register reassignment, and Code Transposition/Subroutine Reordering. This will further enhance our model's ability to predict zero-day malware attacks effectively.

Our proposed solution is trained using a few-shot learning mechanism, which enables it to adapt to new malware classes with limited samples. The denoising autoencoder is integrated with the SNN to enhance its robustness against obfuscation. The model's architecture is designed to capture the semantic relationships between malware samples using a relation-aware module.

The evaluation of our model on two widely-used malware datasets demonstrates its effectiveness in predicting unseen malware classes, even in the presence of obfuscation techniques. The results show that our model is robust against variations in malware samples due to obfuscation techniques and can distinguish between different malware signatures effectively.

Overall, our proposed solution provides a robust and effective approach to detecting zero-day malware attacks that have been obfuscated using various techniques. By leveraging a Siamese Neural Network and denoising autoencoders, our model can capture the complex nonlinear relationships between features in different malware samples and adapt to new malware classes with limited samples.",0ab61b317b881cc4,4c38c95485b935e4,cs,cs.CR,2411.14029
"You have generated a large preference dataset for training a large language model using RLAIF, with rankings provided by an AI evaluator. However, you are unsure whether to train your model on all available data or to selectively train on a subset of the most consistently ranked responses. Your goal is to determine the most effective approach for improving the model's chat capabilities across multiple languages.","['The solution considers the impact of training data quality on the downstream performance of the language model.'
 'The approach involves comparing the performance of models trained on different subsets of the data, based on the consistency of rankings.'
 'The method involves training models on subsets of the data with varying levels of consistency (e.g., top 25%, 50%, 75%) and comparing their performance.'
 'The approach demonstrates an understanding of the potential benefits of selective training on data quality.'
 'The method involves comparing the performance of the selectively trained models to a baseline model trained on all available data.'
 'The solution highlights the importance of data quality over quantity in RLAIF dataset generation.'
 'The approach is designed to be applicable to other RLAIF datasets, suggesting its broader utility.'
 'The solution considers the potential variability in the optimal balance between consistency and data volume across different tasks.'
 'The solution demonstrates an understanding of the challenges associated with training large language models using AI-generated preference data.'
 'The solution provides insights into the importance of evaluating the consistency of AI-generated rankings in RLAIF.']","To determine the most effective approach for improving a large language model's chat capabilities across multiple languages, we will follow a research plan that involves creating a multilingual preference dataset using the Repeat Ranking method, training models on different subsets of this dataset based on the consistency of rankings, and evaluating their performance on the MT-Bench chat benchmark.

First, we create a multilingual preference dataset by sampling 2,714 prompts in 62 languages from the Tagengo dataset and generating responses to each prompt using seven state-of-the-art multilingual LLMs. We then use GPT-4 to evaluate the relative ranking of each response five times, randomizing the order of responses and the order of explanation for each evaluation to avoid systematic bias.

To quantify the consistency of the rankings, we calculate Kendall's W for each set of rankings. Kendall's W is a measure of the agreement between several judges who have rank-ordered a set of entities. We use this score to generate four training subsets of the dataset: one with all available data (100%), and three others with the top 75%, 50%, and 25% most consistently ranked responses.

We train four models using the ORPO algorithm on these subsets: Suzume-ORPO-100, Suzume-ORPO-75, Suzume-ORPO-50, and Suzume-ORPO-25. The ORPO algorithm is chosen for its demonstrated greater performance compared to other current RLAIF methods like DPO. We train each model for one epoch with an ORPO alpha value set to 0.1, a maximum token sequence length of 8,192, and a learning rate of 8e-6.

To evaluate the effectiveness of our approach, we use the MT-Bench benchmark across six languages: Chinese, English, French, German, Japanese, and Russian. This benchmark tests a model's ability to perform various tasks such as writing, roleplay, extraction, reasoning, math, coding, STEM knowledge, and humanities knowledge in a given language. We compare the performance of our four trained models to two baselines: the base model (Suzume-Base) and GPT-3.5-Turbo.

Additionally, we conduct smaller-scale tests to further probe the effects of ORPO training. These include training a model using responses from the models with the best and worst Borda scores (GPT-4 and GPT-3.5, respectively), directly ORPO training a Llama 3 8B Instruct model on the same dataset as Suzume-ORPO-50, and training a model on a randomly selected half of the entire Mitsu dataset.

By comparing the performance of models trained on different subsets of the data based on the consistency of rankings, we aim to determine whether training on more consistently ranked responses leads to better downstream evaluation performance. This approach allows us to investigate the quality versus quantity trade-off in RLAIF dataset generation and potentially identify a more efficient and effective method for improving the chat capabilities of large language models across multiple languages.",d06b644d38dd04d0,c5e7d15075e01c9f,cs,cs.CL,2405.18952
"You are a researcher tasked with reimagining the TaxiVis system, a landmark urban visualization tool, within an immersive analytics framework to explore large datasets of taxi trips in New York City. The goal is to enhance the analysis of spatio-temporal patterns in the data. TaxiVis currently allows interactive spatio-temporal querying through a visual query language on a 2D map. Your task is to extend this functionality into a 3D immersive environment. You need to propose a novel way to integrate the temporal dimension into the visual query model, making it easier for users to identify complex patterns over space and time. The new design should leverage the additional visual dimension provided by the immersive environment and maintain the core functionality of TaxiVis.","['The proposed solution integrates the temporal dimension into the visual query model using a 3D representation.'
 'The 3D representation is based on the Space-Time Cube (STC) metaphor.'
 'The STC metaphor is used to visualize patterns over space and time simultaneously.'
 'The solution allows users to query both spatial and temporal components simultaneously.'
 'The visual query model supports the creation of atomic queries that can be combined.'
 'The solution includes a mechanism for users to adjust the time granularity dynamically.'
 'The solution maintains the core functionality of the original TaxiVis system.'
 'The immersive environment provides additional depth cues that enhance the understanding of the 3D visualization.'
 'Users can modify queries through direct manipulation of the visual representations.'
 'The proposed solution is designed with the potential to scale to reasonably large datasets.']","To reimagine the TaxiVis system within an immersive analytics framework and explore large datasets of taxi trips in New York City, we will develop a novel 3D immersive environment that integrates the temporal dimension into the visual query model. 

First, we will extend the TaxiVis visual query model to encompass the temporal dimension through a Space-Time Cube (STC) metaphor. The STC view will be used to visualize taxi trips over space and time, enabling a clear visualization of patterns over both dimensions simultaneously. The vertical axis will correspond to time, allowing users to see the progression of taxi trips over time.

To implement the STC view, we will utilize the Immersive Analytics Toolkit (IATK) for data rendering and the Unity game engine as the development platform. The Bing Maps SDK will be used for mapping resources. We will adapt the IATK code to support spatio-temporal queries and brushing, enabling users to interactively query the data.

The visual query model will support the creation of atomic queries that can be combined to form more complex queries. Atomic queries can be defined by drawing regions on a map, selecting time spans on the time walls, or by selecting specific neighborhoods on the choropleth map. Users will be able to adjust the time granularity dynamically according to their needs.

The visual representation of queries will be intuitive, with query prisms indicating the applied space-time filters. The query prisms will be colored according to the query type (origin-only, destination-only, or both). Users will be able to modify queries through direct manipulation of the visual representations.

To avoid clutter and improve the visualization of patterns in the data, we will support on-demand 2D projections of inspected data points onto the map and onto the time walls. This will enable users to explore each component separately and reduce the effort needed to understand the locations and times of mid-air trajectories.

The immersive environment will provide additional depth cues that enhance the understanding of the 3D visualization. Users will be able to inspect urban data at different perspectives and scales, including egocentric room-scale and egocentric views of 360-degree street images.

To support the analysis of transportation hubs, we will enable users to investigate these hubs with the help of pointer brushes or query prisms positioned around these locations. The height of the prisms can be adjusted to specify a period of interest, and recurrent selections can focus on specific parts of the day.

The solution will maintain the core functionality of the original TaxiVis system while providing additional features enabled by the immersive environment. The system will be designed to be flexible and adaptable to different user needs, with the potential to scale to reasonably large datasets.

To evaluate the effectiveness of the immersive environment, we will conduct expert and usability evaluations using different urban datasets. We will also refine the design of our user interface and consider options to improve the system's performance to support larger urban datasets.

Overall, our proposed solution will provide a novel and effective way to explore large datasets of taxi trips in New York City, leveraging the benefits of immersive analytics to enhance the analysis of spatio-temporal patterns in the data.",a7299165ffcca123,5605068c64aba9c5,cs,cs.HC,2402.00344
"You are working on a project to extend a fair reward system for artists whose styles are used in generated images by a generative AI model. The model can now blend the styles of multiple artists in a single image. Your task is to adapt the existing reward distribution method, based on Shapley Values, to this new scenario. You have access to the generated images, the text prompts used (which include the names of multiple artists), and the original artworks by the artists involved. You also have a pre-trained CLIP model for generating image embeddings. How would you modify the existing method to quantify the contribution of each artist when multiple styles are blended?","['The proposed method must adapt the Shapley Value calculation to account for multiple artists and their interactions.'
 'The solution should consider different coalitions of artists and the generative model in calculating contributions.'
 'The approach must utilize the CLIP model embeddings to measure the similarity between generated images and original artworks.'
 'The method should be able to quantify the marginal contribution of each artist to the final generated image.'
 ""The solution must handle scenarios where the order of artists' names in the prompt affects the generated image.""
 'The method must provide a clear and transparent way to calculate rewards for each artist involved in a multi-style generation.'
 ""The approach must consider the potential for synergies or conflicts between different artists' styles.""
 'The solution must be grounded in the principles of cooperative game theory.'
 ""The approach should allow for the evaluation of the generative model's contribution alongside that of the artists.""
 ""The method should be able to identify cases where one artist's style dominates the generated image.""]","To adapt the existing reward distribution method based on Shapley Values to the new scenario where the generative AI model blends the styles of multiple artists in a single image, we will follow a multi-step approach.

First, we need to assess whether the model is familiar with a specific artist's style and can reproduce it. We achieve this by generating images with prompts that include the artist's name and measuring the intra-similarity of these images. If the model is familiar with the artist's style, the generated images will have higher intra-similarity compared to images generated without the artist's name. We use a pre-trained CLIP model to generate image embeddings and calculate the cosine similarity between them.

Next, we categorize artists into different categories based on the model's ability to reproduce their style: overfitting, balanced, underfitting, and untrained. We filter out artists whose styles are not well-reproduced by the model, as their contribution to the final generation is minimal.

To calculate the Shapley Values for multiple artists, we consider each artist's original artworks and the generative model's output as players in a cooperative game. We form different coalitions of these players, such as individual artists, the generative model, and combinations thereof. For example, if we have two artists, A and B, we consider coalitions like A, B, SD (the generative model), A+SD, B+SD, A+B, and A+B+SD.

We then calculate the similarity between the generated images from each coalition and the target image (the result of A+B+SD). Using these similarity scores, we apply the Shapley Value formula to determine each player's contribution to the final output. The Shapley Value formula is given by:
\[ \phi_i(v) = \sum_{S \subseteq N \setminus \{i\}} \frac{|S|! \cdot (|N| - |S| - 1)!}{|N|!} (v(S \cup \{i\}) - v(S)) \]
where $\phi_i(v)$ is the Shapley value for player $i$, $N$ is the set of all players, $S$ is a subset of $N$ without $i$, and $v(S)$ is the value function for coalition $S$.

We also examine how the order of artists' names in the prompt affects the generated image and the calculated Shapley Values. By swapping the order of artists' names, we can determine if the contribution of each style varies based on this order.

Furthermore, we extend our methodology to modified generative models, such as those fine-tuned using Dreambooth. This involves merging the weights of fine-tuned models for different artists and calculating the Shapley Values based on the similarity between the generated images and the original artworks.

Finally, we evaluate the robustness of our approach by testing it on different scenarios, including cases where the generated image closely resembles the style of one artist, and cases where the generative model's contribution is significant. We also test our method on real images, treating them as generated blends of styles, to assess its ability to identify and reward the original artist.

Our approach provides a clear and transparent way to calculate rewards for each artist involved in a multi-style generation, taking into account the interactions between different artists' styles and the generative model's contribution. By utilizing the CLIP model embeddings to measure similarity, our method is grounded in the principles of cooperative game theory and is adaptable to different numbers of artists being blended in the generated images.",ff65f738e7d3c335,d2069272fba1ecbe,cs,cs.CV,2403.09700
"You are working on a project to develop an interpretable rule learning method for subgroup discovery. The dataset contains continuous features, and the goal is to discover subgroups with exceptional target distributions. Traditional rule learning methods rely on pre-discretization of features and are not effective for this task. Your task is to propose a novel rule learning approach that can simultaneously learn the subgroup description and the corresponding discretization.","['The solution proposes a neuro-symbolic rule learner.'
 'The approach simultaneously learns the subgroup description and discretization.'
 'The method introduces a soft predicate function to model the probability of a sample being inside an interval.'
 'The solution uses a soft rule function to combine predicates and represent subgroup membership probability.'
 'The approach avoids the need for pre-discretization of continuous features.'
 'The method provides interpretable subgroup descriptions.'
 'The solution is differentiable and optimizable using gradient descent.'
 'The approach allows for the discovery of complex subgroup descriptions.'
 'The method provides a clear and interpretable representation of the learned rules.'
 'The method demonstrates the ability to discover diverse and exceptional subgroups.']","To develop an interpretable rule learning method for subgroup discovery that can simultaneously learn the subgroup description and the corresponding discretization, we propose a novel approach based on the S YFLOW framework. This framework formulates subgroup discovery as a continuous optimization problem, leveraging normalizing flows to model arbitrary target distributions and introducing a neuro-symbolic rule learner for interpretable subgroup descriptions.

### Step 1: Formulate Subgroup Discovery as a Continuous Optimization Problem

We start by formulating subgroup discovery as a continuous optimization problem based on KL-divergence. This involves defining a differentiable rule function \(s(x)\) that represents the probability of a sample \(x\) belonging to a subgroup. The KL-divergence between the conditional distribution \(P_{Y|S=1}\) and the marginal distribution \(P_Y\) of the target variable is used as the exceptionality measure.

### Step 2: Introduce a Neuro-Symbolic Rule Learner

To learn interpretable subgroup descriptions, we introduce a neuro-symbolic rule learner. This involves defining soft predicates \(\pî(x_i; \alpha_i, \beta_i, t)\) that model the probability of a feature \(x_i\) being within an interval \((\alpha_i, \beta_i)\) with a temperature parameter \(t\) controlling the steepness of the transition. The soft rule function \(s(x; \alpha, \beta, a, t)\) is then constructed by combining these soft predicates using weighted harmonic mean, allowing for differentiable and interpretable subgroup descriptions.

### Step 3: Leverage Normalizing Flows for Density Estimation

We use Normalizing Flows, specifically Neural Spline Flows, to accurately estimate the densities \(p_Y\) and \(p_{Y|S=1}\) of the target variable. This step is crucial for computing the KL-divergence and optimizing the subgroup rule.

### Step 4: Optimize the Subgroup Rule

The subgroup rule \(s(x)\) is optimized using gradient descent to maximize the KL-divergence between \(P_{Y|S=1}\) and \(P_Y\), adjusted for subgroup size and diversity. The objective function \(D_{WKL}(P_{Y|S=1} \| P_Y)\) includes a size correction term \(n_s^\gamma\) and a regularizer to encourage diversity among discovered subgroups.

### Step 5: Evaluate the Approach

We evaluate S YFLOW on both synthetic and real-world datasets, comparing its performance against state-of-the-art methods such as Bump Hunting, subgroup discovery using mean-shift and KL-divergence, and Robust Subgroup Discovery. The evaluation metrics include F1-score for recovering planted subgroups, runtime, and measures of subgroup exceptionality like KL-divergence and Bhattacharyya coefficient.

### Step 6: Case Study on Materials Science Data

To demonstrate the applicability and strength of S YFLOW, we conduct a case study on materials science data, specifically gold nano-clusters. We search for characteristics of gold clusters with certain conductivity and reactivity, showcasing S YFLOW's ability to discover physically plausible and diverse subgroups.

### Implementation Details

- **Soft Predicate Function**: Implement the soft predicate function as defined in Eq. (1), using a temperature parameter \(t\) to control the steepness.
- **Soft Rule Function**: Construct the soft rule function using the weighted harmonic mean of soft predicates, as given in Eq. (2).
- **Normalizing Flows**: Utilize Neural Spline Flows for density estimation of \(p_Y\) and \(p_{Y|S=1}\).
- **Optimization**: Optimize the subgroup rule using the Adam optimizer, gradually decreasing the temperature \(t\) during training to obtain crisp subgroup assignments.

### Justification

The proposed approach is justified as it addresses the limitations of traditional rule learning methods by avoiding pre-discretization, handling complex target distributions, and providing interpretable subgroup descriptions. The use of Normalizing Flows allows for flexible density estimation, and the neuro-symbolic rule learner enables the discovery of diverse and exceptional subgroups.

By following these steps and implementing the S YFLOW framework, we can develop a robust and interpretable rule learning method for subgroup discovery that simultaneously learns subgroup descriptions and their corresponding discretization. This approach is expected to outperform traditional methods and provide valuable insights in various applications, including materials science and census data analysis.",2dd2024ab15de00c,00ef6232da727688,cs,cs.LG,2402.12930
"You are developing a video analytics system for surveillance cameras that operates on edge servers with limited computational resources. The system needs to detect and track objects across video frames. You want to improve the accuracy of object detection by leveraging the features extracted by a weaker model on the edge server. Propose a method to use these features to guide the inference process for object detection, without relying on high-precision models for feature extraction.","['The proposed method uses features extracted by a weaker model on the edge server.'
 'The method is designed to be plug-and-play with various deep learning visual models.'
 'The proposed solution reduces computational complexity compared to manual feature point matching.'
 'The approach is evaluated for its impact on object detection accuracy.'
 'The method is tested on a relevant dataset or real-world video analytics scenario.'
 'The method handles occlusions or rapid target movements.'
 'The approach is designed to be efficient for edge computing environments.'
 'The method does not impose restrictions on the feature extraction model.'
 'The proposed solution is compared against a baseline that does not use feature mining.'
 'The method is integrated with a tracking module for continuous object tracking.']","To improve the accuracy of object detection in a video analytics system for surveillance cameras operating on edge servers with limited computational resources, we propose a method that leverages the features extracted by a weaker model on the edge server to guide the inference process. The approach involves utilizing a high-precision model on a cloud server to provide guidance for object detection on the edge server.

The system, called CloudEye, consists of three main modules: the Fast Inference Module, the Feature Mining Module, and the Quality Encode Module. 

1. **Fast Inference Module**: This module adapts the edge model's structure to accommodate the limited computing resources available on edge servers. It exploits the spatio-temporal correlations in videos to predict image locations based on historical information and performs inference in regions of interest. The module uses a Kalman filter-based tracker to predict the target distribution in the current frame, reducing computational load and achieving greater target position accuracy.

2. **Feature Mining Module**: This module utilizes the high-precision inference results from the cloud server on historical video frames to mine targets in the current frame. It extracts features from the reference frame (obtained from the cloud server's inference) and the current frame (inferred by the edge server) using a deep learning model. The module then matches the features extracted by the edge model with the cloud server's inference results to determine the precise distribution regions of target content in the current video frame. This approach transforms the object detection regression problem into a similarity comparison problem for locating matching regions.

3. **Quality Encode Module**: This module dynamically applies differentiated quality encoding to video frames transmitted to the cloud server. It clusters targets according to their coordinates and encodes the regions of interest (ROI) with higher quality while reducing the encoding precision of background areas. The module uses a weighted clustering algorithm with target sizes as weights to preserve background information around the ROI.

The CloudEye system is designed to be plug-and-play with various deep learning visual models, allowing it to be easily adapted to different object detection tasks. It reduces computational complexity compared to manual feature point matching and achieves robust results despite potential minor disturbances in the video.

The proposed solution is adaptive to different object detection tasks and can handle occlusions or rapid target movements by leveraging the Kalman filter and feature mining techniques. It is designed to be efficient for edge computing environments and does not impose restrictions on the feature extraction model.

To evaluate the effectiveness of CloudEye, we will conduct experiments on a relevant dataset (such as NUSCENES) and in real-world video analytics scenarios. The system's performance will be compared against a baseline that does not use feature mining, and its impact on object detection accuracy will be assessed.

The research plan involves:
1. Implementing the CloudEye system using Python and deploying deep learning models on the edge server using TensorRT.
2. Conducting performance evaluations of CloudEye for object detection tasks in complex network environments.
3. Evaluating the system's latency, accuracy, and bandwidth usage in different modes and scenarios.
4. Comparing CloudEye's performance against a traditional edge-cloud architecture system.

By following this research plan, we aim to demonstrate the effectiveness of CloudEye in improving object detection accuracy while reducing computational complexity and bandwidth usage.",56163ce66be27ca9,a0990f1bffa15bc1,cs,cs.CV,2410.18399
"You are working on developing an online evaluation framework for deep generative models using the multi-armed bandit (MAB) framework. The goal is to identify the best model among a set of available models using the fewest possible generated samples. You need to derive concentration bounds for the Fréchet Distance (FD) and Inception Score (IS) metrics, which are commonly used to assess the quality and diversity of generated data. These metrics do not simplify to the expectation of a random variable and represent a non-linear function of the data distribution.","['The solution derives concentration bounds for the FD and IS metrics.'
 'The solution acknowledges the non-linear nature of the FD and IS metrics.'
 'The solution recognizes the challenge of estimating these metrics from limited data.'
 'The solution provides a theoretical analysis of the estimation errors for the FD and IS metrics.'
 'The solution derives data-dependent bounds for the FD and IS metrics.'
 'The solution uses these bounds to construct optimistic estimates of the scores.'
 'The solution enables the development of UCB algorithms for efficient identification of the best generative model.'
 'The solution is applicable to standard evaluation metrics for deep generative models.'
 'The solution provides a principled approach to addressing the uncertainty in the estimates.'
 'The solution is well-grounded in statistical theory and concentration inequalities.']","To develop an online evaluation framework for deep generative models using the multi-armed bandit (MAB) framework, we need to derive concentration bounds for the Fréchet Distance (FD) and Inception Score (IS) metrics. These metrics are commonly used to assess the quality and diversity of generated data but do not simplify to the expectation of a random variable, representing a non-linear function of the data distribution.

First, we acknowledge that the FD and IS metrics are non-linear and challenging to estimate from limited data. The FD metric involves computing the mean and covariance matrix of the generated data's embeddings, while the IS metric involves calculating the entropy of the marginal class distribution and the conditional class distribution assigned by a pre-trained classifier.

To address the challenge of estimating these metrics, we derive data-dependent concentration bounds. For the FD metric, we assume that the embeddings of the generated images follow a multivariate Gaussian distribution. We then derive an optimistic estimate of the FD score using Theorem 1, which provides a concentration bound involving the effective rank of the covariance matrix and the norm of the mean difference between the generated and real data embeddings.

The concentration bound for FD is given by Theorem 1, which states that with probability at least $1 - \delta$, the true FD is bounded by the empirical FD plus a bonus term that depends on the number of samples, the effective rank of the covariance matrix, and other model-dependent parameters. This bonus term is crucial for constructing an upper confidence bound (UCB) for the FD metric.

For the IS metric, we derive a concentration bound using Theorem 2, which involves the empirical variance of the entropy of the conditional class distribution and the optimistic marginal class distribution. The optimistic IS is defined as the exponential of the difference between the entropy of the optimistic marginal class distribution and the empirical conditional entropy, plus a bonus term that accounts for the uncertainty in these estimates.

Using these concentration bounds, we construct UCB algorithms, namely FD-UCB and IS-UCB, to efficiently identify the best generative model among a set of available models. The FD-UCB algorithm (Algorithm 1) iteratively selects the model with the lowest estimated FD plus a bonus term, while the IS-UCB algorithm (Algorithm 2) selects the model with the highest estimated IS minus a bonus term.

Theoretical analysis of the estimation errors for the FD and IS metrics is provided through Theorems 3 and 6, which bound the regret of the FD-UCB and IS-UCB algorithms, respectively. The regret bounds demonstrate that both algorithms achieve sub-linear regret growth, ensuring that they converge to the best model with high probability.

The solution is grounded in statistical theory and concentration inequalities, leveraging properties of the multivariate Gaussian distribution and the effective rank of the covariance matrix. By acknowledging the non-linear nature of the FD and IS metrics and addressing the challenge of estimating these metrics from limited data, we provide a principled approach to online evaluation and selection of deep generative models.

The proposed research plan involves implementing the FD-UCB and IS-UCB algorithms and evaluating their performance on standard image datasets, such as CIFAR10, ImageNet, and FFHQ, using various pre-trained generative models. The performance will be compared to baseline algorithms, including Naive-UCB, Greedy, and Random selection strategies, using metrics such as average regret and optimal pick ratio.

By following this plan, we aim to demonstrate the efficacy of MAB-based approaches for sample-efficient evaluation and selection of deep generative models, addressing the challenges posed by the non-linear nature of standard evaluation metrics.",556ce8c35ff5e244,4c8b61aa24b232d0,cs,cs.LG,2406.07451
"You are tasked with evaluating the performance of several Large Language Models (LLMs) on a set of qualitative spatial reasoning tasks involving the Region Connection Calculus (RCC-8). The LLMs are required to predict the possible relations between two objects given certain premises. Since the tasks involve multiple possible relations, you need to devise a method to measure the accuracy of the LLMs' responses. The method should account for the similarity between the predicted set of relations and the actual set of relations. Describe a suitable approach to evaluate the accuracy of the LLMs' responses.","['The evaluation method accounts for cases where multiple relations are possible.'
 'The method measures the similarity between the predicted and actual sets of relations.'
 'The approach is based on a well-established metric or index.'
 'The chosen metric is suitable for comparing sets of relations.'
 'The method is able to handle varying numbers of predicted and actual relations.'
 ""The method provides a clear and interpretable score for the accuracy of the LLMs' responses.""
 'The method is able to differentiate between completely correct and partially correct responses.'
 'The chosen metric is able to handle cases where the predicted set is a subset or superset of the actual set.'
 'The approach is generalizable to other qualitative spatial reasoning tasks or calculi.'
 'The evaluation method is clearly described and justified in the context of the task.']","To evaluate the performance of Large Language Models (LLMs) on qualitative spatial reasoning tasks involving the Region Connection Calculus (RCC-8), we need a method that can accurately measure the accuracy of the LLMs' responses when multiple relations are possible between two objects given certain premises.

The evaluation method should account for the similarity between the predicted set of relations and the actual set of relations. To achieve this, we will use the Jaccard Index (JIx), a well-established metric for comparing the similarity between two sets. The Jaccard Index is calculated by dividing the size of the intersection of the predicted and actual sets of relations by the size of their union.

The Jaccard Index is suitable for this task because it can handle cases where multiple relations are possible and can measure the similarity between the predicted and actual sets. It is also able to handle varying numbers of predicted and actual relations, making it robust to minor differences in the predicted and actual relations.

To implement this evaluation method, we will first generate a set of qualitative spatial reasoning tasks involving RCC-8 relations. These tasks will involve determining the possible relations between two objects given certain premises. We will then use the LLMs to predict the possible relations for each task.

For each task, we will calculate the Jaccard Index by comparing the predicted set of relations with the actual set of relations. The Jaccard Index will provide a score between 0 and 1, where 1 indicates a perfect match between the predicted and actual sets, and 0 indicates no overlap.

To measure the accuracy of the LLMs' responses, we will calculate the mean Jaccard Index across all tasks for each LLM. This will provide an overall score for each LLM's performance on the qualitative spatial reasoning tasks.

To account for the stochasticity of the LLMs, we will repeat each task multiple times (n = 30) and calculate the mean and 95% confidence interval of the Jaccard Index for each task. This will provide a robust estimate of the LLMs' performance and allow us to quantify the uncertainty in the results.

The use of the Jaccard Index as the evaluation metric is justified because it is a well-established and widely used metric for comparing sets. It is also suitable for the task at hand, as it can handle cases where multiple relations are possible and can measure the similarity between the predicted and actual sets.

The evaluation approach is consistent with the goals of the qualitative spatial reasoning tasks, as it measures the ability of the LLMs to predict the possible relations between objects given certain premises. The method is also generalizable to other qualitative spatial reasoning tasks or calculi, as the Jaccard Index can be used to compare sets in a wide range of contexts.

Overall, the proposed evaluation method provides a clear and interpretable score for the accuracy of the LLMs' responses and is computationally feasible for the given task. It is also robust to minor differences in the predicted and actual relations and can differentiate between completely correct and partially correct responses.

By using this evaluation method, we can provide a comprehensive assessment of the LLMs' performance on qualitative spatial reasoning tasks involving RCC-8 and gain insights into their strengths and weaknesses in this area.",f29bcb5064b5b4a9,d2cf00abda034dad,cs,cs.CL,2411.19589
"You are tasked with developing a natural language processing model to classify geological borehole descriptions into different lithology classes. The descriptions are in Dutch and come from the Flanders region. You have access to a large corpus of unlabeled borehole descriptions and a smaller set of labeled descriptions. The pre-trained BERTje model is available for Dutch language tasks, but it is not specifically trained on geological texts. How would you adapt this model to improve its performance on the lithology classification task?","['The solution involves using the pre-trained BERTje model as a base.'
 'The approach includes further training the BERTje model on the large corpus of unlabeled geological borehole descriptions.'
 ""The domain adaptation process is applied to enhance the model's understanding of geological terminology.""
 'The masked language model (MLM) objective is used for domain adaptation.'
 'The training process involves randomly masking words in the descriptions and predicting the masked words.'
 'A learning rate schedule is implemented, including a warm-up phase and learning rate annealing.'
 'Early stopping is employed to prevent overfitting during domain adaptation.'
 ""The solution acknowledges the importance of validation loss in assessing the model's generalization ability.""
 'The solution involves fine-tuning the domain-adapted model on the labeled dataset for the classification task.'
 ""The approach recognizes the potential benefits of domain adaptation in improving the model's performance on secondary and tertiary lithology classification.""]","To develop a natural language processing model for classifying geological borehole descriptions into different lithology classes, we will adapt the pre-trained BERTje model, which is a Dutch language model. The adaptation involves two main stages: domain adaptation and finetuning for the classification task.

First, we will perform domain adaptation by further training BERTje on a large corpus of 283,000 unlabeled Flemish borehole descriptions. This step is crucial as it enhances BERTje's understanding of geological terminology and context specific to the Flemish region. We will use the masked language model (MLM) objective for this purpose, where we randomly mask words in the descriptions and predict them. A masking probability of 0.15 will be applied, and the training will be done with a batch size of 32. The learning rate will start with a warm-up phase and then be annealed, with an initial value set at 0.0005. Early stopping will be employed to prevent overfitting by monitoring the validation loss. This process will result in a domain-adapted model, referred to as GEOBERTje.

Next, we will finetune GEOBERTje on a labeled dataset of approximately 2,671 borehole descriptions for the lithology classification task. The labeled data will be split into training (70%), validation (15%), and test sets (15%). We will train three separate classification models for predicting the main, secondary, and tertiary lithologies. Each model will have a classification head attached to GEOBERTje, and they will be trained independently. To address class imbalance, we will use class weights in the cross-entropy loss function. The learning rate strategy will again include a warm-up phase followed by linear annealing, with a maximum learning rate of 0.0005. Training will be stopped when the validation loss starts to increase, indicating overfitting.

To further improve the classifiers' accuracy, we will apply two postprocessing steps. First, we will ensure that a lithology class is not predicted more than once by removing duplicates and replacing them with the next most probable class. Second, we will only consider predictions with a confidence threshold of τ = 0.1 as valid, where τ is determined by maximizing the accuracy score on the validation set.

We will compare the performance of our GEOBERTje classifier with two other approaches: a traditional rule-based scripting method and GPT-4 through prompt engineering. The rule-based script uses a dictionary and regular expressions to classify lithological descriptions. For GPT-4, we will engineer a prompt using our labeled validation set to achieve optimal classification performance without finetuning the GPT model.

By following this plan, we aim to develop a highly accurate lithology classification model that leverages the strengths of the BERTje model and the specific characteristics of the geological borehole descriptions in Dutch from the Flanders region. The domain adaptation step is expected to significantly improve the model's performance, especially for secondary and tertiary lithology classifications. The comparison with other methods will provide insights into the effectiveness of our approach and the potential benefits of using domain-specific large language models in geological applications.",2d83e39d4e7e5127,807fe530e6be83f3,cs,cs.CL,2407.10991
"You are tasked with analyzing the costs associated with different message aggregation schemes in the context of HPC applications using Shared Memory Parallelism (SMP) mode. Your goal is to understand the factors that contribute to the overhead and latency of these schemes. Design a research plan to break down and analyze the costs associated with different aggregation schemes, including memory overhead, number of messages sent, message send cost, and processing delays at the receiver.","['The researcher considers the memory overhead of different schemes and how it is affected by factors like buffer size.'
 'The plan involves analyzing the number of messages sent by different schemes under various conditions.'
 'The researcher evaluates the message send cost using a model like the alpha-beta communication model.'
 'The plan includes an analysis of processing delays at the receiver, including sorting or grouping costs.'
 'The plan involves comparing the costs of node-aware vs. node-unaware aggregation schemes.'
 'The researcher proposes a methodology to measure and compare the costs of different schemes.'
 'The plan involves analyzing the trade-offs between different costs (e.g., memory overhead vs. latency).'
 'The researcher considers the scalability of the cost analysis for different schemes.'
 'The plan includes an evaluation of how application characteristics affect the costs of different schemes.'
 'The plan involves validating the cost analysis through experiments or simulations.']","To analyze the costs associated with different message aggregation schemes in the context of HPC applications using Shared Memory Parallelism (SMP) mode, we design a research plan that breaks down and examines the costs of various aggregation schemes.

First, we identify the key factors that contribute to the overhead and latency of message aggregation schemes. The alpha-beta communication model is used to understand the cost associated with sending a message over the network, which is computed as α + N β, where N is the number of bytes, α is the latency per message, and β is the cost per byte transferred.

We analyze four basic aggregation schemes: WW, WPs, WsP, and PP. In the WW scheme, each worker maintains a buffer for every other worker. The WPs and WsP schemes aggregate messages at the source worker per destination process, with sorting or grouping performed at the destination process and source worker, respectively. The PP scheme aggregates messages at each source process per destination process.

To evaluate the costs associated with these schemes, we consider the following metrics: memory overhead, number of messages sent, message send cost, and processing delays at the receiver.

1. **Memory Overhead**: We calculate the memory overhead for each scheme based on the number of items in the TRAM buffer (g), the size of each item (m), the total number of processes (N), and the number of workers per process (t). The memory overheads are as follows:
   - WW: g ∗ m ∗ N ∗ t per core or g ∗ m ∗ N ∗ t^2 per process
   - WPs, WsP: g ∗ m ∗ N per core or g ∗ m ∗ N ∗ t per process
   - PP: g ∗ m ∗ N per source process

2. **Number of Messages Sent**: For a buffer size g and z items sent from each source PE, we determine the lower and upper bounds for the number of messages sent for each scheme.
   - WW: z/g and z/g + N ∗ t
   - WPs, WsP: z/g and z/g + N
   - PP: z/g and z/g + N

3. **Message Send Cost**: Using the alpha-beta model, we analyze the communication cost for sending z items with and without coalescing. Coalescing reduces the α component in the message cost by g.

4. **Processing Delays**: We examine the delays associated with coalescing messages, including contention, sorting or grouping costs, and buffer fill delays. The sorting or grouping of items by worker results in an additional delay of O(g + t).

To validate our cost analysis, we conduct experiments on the Delta supercomputer at NCSA using the SMP build of Charm++ with OFI as the network layer. We use benchmarks such as histogram, index-gather (IG), Single Source Shortest Path (SSSP), and PHOLD synthetic benchmark to measure overhead, latency, and wasted updates for different aggregation schemes.

We vary the number of worker threads per process and buffer sizes to analyze their impact on performance. For instance, we observe that setting 8 workers per process for the WPs scheme performs on par with the non-SMP implementation for the histogram benchmark.

Our experiments involve weak scaling, where the amount of work per PE remains the same, to assess the scalability of the aggregation schemes. We measure overall execution time, latency, and wasted updates for different schemes and application characteristics.

By comparing the costs of node-aware vs. node-unaware aggregation schemes and analyzing the trade-offs between different costs, we aim to identify the most effective schemes for various HPC applications. Our research plan involves analyzing the impact of buffer size, contention, and application characteristics on the costs associated with different aggregation schemes.

The experiments will provide insights into the benefits and limitations of each scheme, enabling us to propose optimizations to reduce the costs associated with message aggregation in SMP mode. Ultimately, this research will contribute to the development of more efficient message aggregation libraries for HPC applications.",de59b7230de2bc08,8d038d9118800178,cs,cs.DC,2411.03533
"You are responsible for developing a security framework for LLM app stores. Your task is to identify and mitigate the unique security risks associated with LLM apps, which are distinct from traditional mobile apps due to their reliance on proprietary base LLMs and unique prompt engineering strategies. You need to consider the potential for prompt injection attacks, adversarial inputs, and the generation of harmful or misleading content. Your framework should be designed to ensure the integrity and trustworthiness of the LLM app ecosystem.
        You have access to various data types, including LLM app raw data, metadata, and user feedback. However, you must develop a comprehensive understanding of the security challenges posed by LLM apps and propose tailored detection mechanisms and mitigation strategies. Your solution should be grounded in a thorough analysis of the LLM app ecosystem and its operating mechanisms.","['The proposed security framework includes a comprehensive analysis of the unique security risks associated with LLM apps.'
 'The framework identifies potential security threats, such as prompt injection attacks and adversarial inputs, and proposes mitigation strategies.'
 'The approach considers the role of third-party service integration in introducing vulnerabilities or data privacy issues.'
 'The framework includes mechanisms for detecting and preventing the generation of harmful or misleading content by LLM apps.'
 'The framework accounts for the dynamic and adaptive nature of LLMs and their potential to inadvertently collect sensitive user information.'
 'The proposed mitigation strategies are tailored to the distinctive features of LLM apps and the LLM app ecosystem.'
 'The framework is designed to be flexible and adaptable to the rapidly evolving nature of LLM technologies and security threats.'
 'The framework is grounded in a thorough understanding of the LLM app ecosystem and its operating mechanisms.'
 'The approach considers the potential for intellectual property infringement within LLM app stores and includes measures to mitigate this risk.'
 'The framework balances the need for security with the need to promote innovation and user satisfaction within the LLM app ecosystem.']","To develop a comprehensive security framework for LLM app stores, we first conduct a thorough analysis of the unique security risks associated with LLM apps. This involves examining the potential for prompt injection attacks, adversarial inputs, and the generation of harmful or misleading content. We leverage the data collected from LLM app stores, including raw data, metadata, and user feedback, to identify potential security threats.

Our analysis begins with the data collection stage, where we gather LLM app raw data, metadata, and user feedback. LLM app raw data encompasses components such as instructions, knowledge files, conversation starters, and custom temperature settings, which define the behavior and capabilities of LLM apps. We also collect LLM app metadata, including app name, creator, description, capabilities, category, tag, and user review information, which provides insights into app functionality and user engagement. User feedback data, such as the number of conversations, retention rate, daily active users, ratings, and reviews, helps assess app performance and popularity.

In the security and privacy analysis stage, we focus on identifying potential security risks and regulatory compliance issues. We examine risks related to LLM app raw data, such as app cloning, app vulnerabilities, malicious apps, third-party service integration, user tracking and profiling, and advertisement fraud. We also investigate risks associated with LLM app metadata, including fake apps, and user feedback-related risks, such as ranking fraud, malicious ASO, and spam reviews.

To mitigate these risks, we propose tailored detection mechanisms and mitigation strategies. For instance, we develop similarity analysis techniques to combat app cloning, and design novel defense mechanisms to address prompt injection attacks and adversarial inputs. We also implement robust authentication and authorization mechanisms for third-party service integration and employ privacy-preserving techniques to protect user data.

In the ecosystem and market analysis stage, we leverage the collected data to gain insights into developer engagement, market trends, and strategic decision-making within the LLM app ecosystem. We enhance support for LLM app developers by implementing requirements engineering processes and tools, providing comprehensive development assistance, and offering robust analysis and testing tools. We also establish a trend analysis mechanism to uncover and predict LLM app market trends and conduct cross-market/culture comparisons to reveal market differences.

Our framework includes mechanisms for detecting and preventing the generation of harmful or misleading content by LLM apps. We enforce strict privacy policies, obtain explicit user consent, and employ privacy-preserving techniques like differential privacy and data anonymization. We also implement regular monitoring and auditing of third-party services integrated into LLM apps.

To ensure compliance with relevant data protection regulations, we design our framework to be flexible and adaptable to the rapidly evolving nature of LLM technologies and security threats. We include mechanisms for continuous improvement and updating of security measures in response to emerging threats. Our framework is grounded in a thorough understanding of the LLM app ecosystem and its operating mechanisms, ensuring a comprehensive and effective security solution.

By addressing the unique security risks associated with LLM apps and proposing tailored mitigation strategies, our framework ensures the integrity and trustworthiness of the LLM app ecosystem. It balances the need for security with the need to promote innovation and user satisfaction, providing a robust and adaptable security framework for LLM app stores.",dffd02901b8d9d5e,b3fc4f8fb78c5550,cs,cs.SE,2404.12737
"You are evaluating AI code generators for generating security-oriented code and need to assess their performance. Traditional metrics like compilation accuracy are not sufficient due to the complexity and low-level nature of security code. Propose a novel approach to evaluating the performance of AI code generators in the security domain, considering the limitations of existing metrics.","['The proposed approach recognizes the limitations of traditional metrics (e.g., compilation accuracy) for security code.'
 'The plan involves using a metric that assesses the semantic correctness of generated code.'
 'The plan includes a justification for why edit distance is suitable for security-oriented code evaluation.'
 'The proposal considers the complexity and low-level nature of security code in the evaluation approach.'
 'The proposal outlines a method for comparing the performance of different AI code generators.'
 'The plan considers the potential variability in performance across different types of security code.'
 'The proposal suggests analyzing the correlation between the proposed metric and semantic correctness.'
 'The plan involves evaluating the effectiveness of the proposed metric in distinguishing between correct and incorrect code.'
 'The proposal outlines a clear methodology for applying the proposed evaluation metric.'
 'The plan demonstrates an understanding of the challenges in evaluating AI-generated code for security.']","To evaluate AI code generators for generating security-oriented code, we need to develop a novel approach that addresses the limitations of traditional metrics like compilation accuracy. The complexity and low-level nature of security code require a more nuanced evaluation method.

First, we will manually curate a dataset, similar to the ""violent-python"" dataset, which contains security-oriented programs in Python annotated with descriptions in natural language. This dataset will cover various areas of security, including penetration testing, forensic analysis, network traffic analysis, and OSINT and social engineering.

To evaluate the performance of AI code generators, we will use the edit distance (ED) metric, which measures the similarity between the generated code and the ground truth code. We choose ED because it has been shown to be correlated with semantic correctness in security-oriented code. ED ranges between 0 and 1, with higher scores corresponding to smaller distances.

We will fine-tune a pre-trained language model, such as CodeBERT, on our dataset to adapt it to the specific task of generating security-oriented code. We will then compare the performance of the fine-tuned CodeBERT against popular public AI code generators like GitHub Copilot and Amazon CodeWhisperer.

To assess the model's ability to generate security-oriented code, we will consider different levels of detail in the natural language descriptions, including individual lines, code blocks, and entire functions. We will split our dataset into training, validation, and test sets using a common 80%-10%-10% ratio.

Our evaluation will involve comparing the ED scores of the different AI code generators on the same test set. We will analyze the results to understand how the complexity of the code affects the performance of the generators and how fine-tuning impacts the results.

The use of ED as a metric is justified because it assesses the semantic correctness of the generated code, which is crucial for security-oriented applications. By using a manually curated dataset and evaluating the performance of different AI code generators, we can provide a comprehensive understanding of their strengths and weaknesses in generating security-oriented code.

Our approach recognizes the need for a nuanced evaluation method due to the specific requirements of security code. By considering the complexity and low-level nature of security code, we can develop a more effective evaluation framework.

The proposed methodology will provide insights into the effectiveness of AI code generators for security applications and highlight the importance of fine-tuning models for specific tasks. It will also demonstrate the need for domain-specific evaluation metrics in AI code generation.

To further validate our approach, we will analyze the correlation between ED and semantic correctness. This will involve manually reviewing a subset of the generated code to assess its correctness and comparing it with the ED scores.

Overall, our research plan provides a comprehensive approach to evaluating AI code generators for security-oriented code, addressing the limitations of traditional metrics and considering the specific requirements of security applications.",1c6afb713b5d5b65,91bf023b729bc81a,cs,cs.CR,2402.01219
"You are tasked with understanding the theoretical underpinnings of a novel sample retrieval strategy in a proxy-based contrastive continual learning framework. This strategy involves selecting both gradient-conflicting and gradient-aligned samples from a memory buffer to mitigate catastrophic forgetting and proxy drift. Your goal is to provide a theoretical analysis that explains why this balanced retrieval strategy is effective. Specifically, you need to elucidate the roles of gradient-aligned and gradient-conflicting samples in enhancing knowledge retention and model plasticity.","['The analysis explains the role of gradient-aligned instances in finding stable embeddings shared among tasks.'
 'The analysis highlights the importance of gradient-conflicting instances in preserving past knowledge and avoiding catastrophic forgetting.'
 'The theoretical analysis is grounded in the context of proxy-based contrastive continual learning.'
 'The analysis demonstrates how gradient-conflicting samples reduce interference by re-aligning gradients.'
 'The analysis provides a clear understanding of why the combination of both sample types enhances knowledge retention.'
 'The theoretical framework explains the impact of the balanced retrieval strategy on model plasticity.'
 'The analysis is based on the approximation of the loss change criterion used in the sample retrieval strategy.'
 'The analysis considers the implications of the sample retrieval strategy on the overall performance of the continual learning model.'
 'The analysis provides insights into how the balanced retrieval strategy affects the diversity of retrieved instances.'
 'The explanation addresses how the strategy impacts the alignment in parameter space.']","To address the research scenario, we will develop a theoretical analysis that elucidates the effectiveness of a novel sample retrieval strategy in a proxy-based contrastive continual learning framework. This strategy involves selecting both gradient-conflicting and gradient-aligned samples from a memory buffer to mitigate catastrophic forgetting and proxy drift.

First, we will formulate the continual learning problem under the experience replay framework, where a model is trained on a sequence of tasks while maintaining a memory buffer of representative samples from previous tasks. The training objective is to minimize the combined loss over the current task and the memory buffer.

We will analyze the proxy-based contrastive loss, which encourages the model's embeddings to align with their corresponding class proxies while diverging from other class proxies. The proxy drift problem will be examined, where class representations shift unpredictably as new tasks are introduced, leading to increased catastrophic forgetting.

The core of our analysis will focus on the balanced retrieval strategy, which selects samples from both ends of the loss-change distribution from the memory buffer. We will theoretically analyze how gradient-aligned samples reinforce stable, shared representations across tasks, while gradient-conflicting samples reduce interference by re-aligning gradients, thereby preserving past knowledge.

To facilitate this analysis, we will define a sampling method opposite to the Maximum Interference Retrieval (MIR) method, referred to as inverse-MIR (IMIR), which selects samples expected to show the highest decrease in loss. By comparing MIR and IMIR, we will demonstrate how the balanced retrieval strategy boosts the diversity of retrieved instances and offers a better representation of past task distributions.

Theoretical analysis will be grounded in the approximation of the loss change criterion used in the sample retrieval strategy. We will expand the sample loss into a first-order Taylor series and analyze the gradient alignment of selected samples. This will provide insights into how the combination of gradient-aligned and gradient-conflicting samples enhances knowledge retention and model plasticity.

We will also investigate how the balanced retrieval strategy impacts the diversity of retrieved instances and the alignment in parameter space. By analyzing the average distance among embeddings retrieved from the buffer and the average distance between retrieved instances and their corresponding class proxies, we will demonstrate that the proposed sampling strategy selects notably more diverse instances.

To validate the effectiveness of the proposed sample retrieval strategy, we will conduct experiments on popular continual learning benchmarks in computer vision. The results will be evaluated using metrics such as Average End Accuracy, Average Forgetting, and Average Retention Rate. We will compare our method with state-of-the-art continual learning algorithms and buffer instance selection approaches for memory-based methods.

The theoretical underpinnings of our analysis will be clearly connected to the proxy-based contrastive learning framework, addressing the challenges of continual learning, such as catastrophic forgetting and proxy drift. Our analysis will provide a clear understanding of why the combination of both sample types outperforms using a single type, supporting the empirical findings.

By elucidating the roles of gradient-aligned and gradient-conflicting samples in enhancing knowledge retention and model plasticity, our research will contribute to the development of more effective continual learning strategies. The proposed balanced retrieval strategy has the potential to improve the performance of proxy-based contrastive continual learning models, enabling them to better adapt to new tasks while retaining knowledge from previous tasks.",e41604fefcb37bf3,b103c8a04e42d0ce,cs,cs.LG,2412.14430
"You are working on an output-side adaptation framework for a Pre-trained Language Model (PLM) under the Model-as-a-Service (MaaS) setting, and you have decided to use a multi-prompting paradigm to query the PLM with multiple different prompts for each sample. You have also developed a decoding strategy for the PLM's output hidden states using Optimal Transport (OT). However, you want to further improve the performance of your model by utilizing the PLM's output class scores. How can you effectively decode the class scores obtained from the PLM, given that the predictions are biased towards the tokens that are common in the PLM's pre-training distribution?","['The solution involves expanding the set of label words for the verbalizer.'
 'The solution calibrates the class scores for each prompt separately.'
 'The solution averages the calibrated class scores of all prompts.'
 'The solution combines the OT scores and calibrated class scores for joint decoding.'
 ""The solution is designed to mitigate the bias in the PLM's predictions.""
 'The solution assigns a weight to each element in the expanded set of label words.'
 'The solution does not require significant modifications to the PLM.'
 'The solution is used as a supplementary decoding strategy to the OT-based decoding.'
 'The solution involves using a hyper-parameter to balance the OT scores and calibrated class scores.'
 'The solution combines the strengths of different decoding strategies to achieve better performance.']","To effectively decode the class scores obtained from the Pre-trained Language Model (PLM) under the Model-as-a-Service (MaaS) setting, we propose a calibrated multi-prompting decoding strategy. This approach is designed to mitigate the bias in the PLM's predictions towards tokens that are common in its pre-training distribution.

First, we expand the set of label words for the verbalizer using a simple and effective method. Given the prediction layer of the Masked Language Model (MLM) \(W_{mlm} \in R^{|V| \times d}\), we treat each item as a representation of a word. Then, for a given label word, we expand a new set of label words \(S\) based on cosine similarity between words. We use the softmax function over cosine similarity to assign a weight to each element in the set. This step is crucial as it enriches the label words, potentially capturing more nuanced representations of the classes.

Next, we calibrate the class scores for each prompt separately. The PLM's predictions are biased because it tends to predict tokens that are common in its pre-training distribution. To address this, we first calibrate the PLM on a given prompt and then use the calibrated class scores for classification. Specifically, we wrap an empty input \(x_e = ""\)"" with a template \(T_j\) and query the model with \(T_j(x_e)\) to obtain the predictions of label words \(s_{ej} \in R^{N|S|}\) to calibrate. Then, given a prediction \(s_{ij}\) for sample \(x_i\) wrapped by prompt \(T_j\), we calibrate \(s_{ij}\) by \(s̄_{ij} = diag(s_{ej}/mean(s_{ej}))^{-1}s_{ij}\), where \(s̄_{ij} \in R^{N|S|}\) is the calibrated prediction over the expanded set. This calibration step ensures that the predictions for context-independent inputs become uniformly distributed.

After calibrating the class scores for each prompt, we average the calibrated class scores of all prompts. For a sample \(x_i\), we have \(ŝ_i = \frac{1}{P} \sum_{j=1}^{P} ŝ_{ij}\), where \(ŝ_{ij} \in R^N\) are the calibrated class scores for \(x_i\) under prompt \(T_j\), and \(P\) is the number of prompts. This averaging step helps to stabilize the predictions across different prompts.

Finally, we combine the Optimal Transport (OT) scores and the averaged calibrated class scores for joint decoding. The final predictions are given by \(ŷ_i = ŷ_i^{OT} + \beta ŝ_i\), where \(ŷ_i^{OT} = [Dec(x_i, 1), ..., Dec(x_i, N)] \in R^N\) denotes the OT scores, and \(\beta\) is a hyper-parameter that balances the model and prior knowledge inside the PLM. The OT scores are obtained through a multi-prompting decoding strategy with optimal transport for hidden states, which establishes multiple prototypes for each class and identifies the best matching between sample representations and prototypes.

This calibrated multi-prompting decoding strategy is designed to be effective in the few-shot setting and does not require significant modifications to the PLM. It combines the strengths of different decoding strategies to achieve better performance and is evaluated on multiple natural language understanding tasks. By calibrating the class scores and combining them with OT scores, we aim to mitigate the bias in the PLM's predictions and improve the overall performance of the model.

The proposed approach is compared with existing MaaS adaptation methods, including ICL, BBT, BBTv2, RLPrompt, PromptBoosting, and DecT. The experiments are conducted on several common natural language understanding tasks, including sentiment analysis, topic classification, and natural language inference. The results demonstrate that our method achieves state-of-the-art performance and is effective and efficient.

The hyper-parameter \(\beta\) is tuned based on the validation set, and the number of templates \(P\) and the number of prototypes \(Q\) are set to 3. The expanded label words are used for sentiment analysis and topic classification tasks but not for natural language inference tasks due to the smaller number of potential label words.

Overall, the proposed calibrated multi-prompting decoding strategy is a robust and effective approach to decoding class scores obtained from a PLM under the MaaS setting. It addresses the bias in the PLM's predictions and achieves state-of-the-art performance on multiple natural language understanding tasks.",aea464dc6f2268c1,2aa6f60fdb5e77da,cs,cs.CL,2406.06279
"You are tasked with developing a code intelligence model for a low-resource language, such as Romanian. The goal is to create a model that can generate code based on problem definitions written in Romanian. However, you notice that most existing code intelligence models are trained on English data and there is a lack of datasets for non-English languages. How would you approach this problem and what dataset would you create to facilitate the development of code intelligence models for Romanian?","['The dataset should include problem definitions written in Romanian.'
 'The solutions should be written in a programming language relevant to the task, such as C, C++, or Python.'
 'The dataset should include test cases to evaluate the correctness and algorithmic complexity of the solutions.'
 'The dataset should be curated and filtered to ensure quality and relevance.'
 'The dataset should be made publicly available to facilitate further research.'
 'The dataset should include a variety of problem difficulties to test different aspects of code intelligence.'
 'The creation of the dataset should involve collaboration with relevant stakeholders, such as competitive programming platforms.'
 'The dataset should be suitable for fine-tuning pre-trained models for code intelligence tasks in Romanian.'
 'The dataset should include a clear and consistent format for problem statements and solutions.'
 'The dataset should be accompanied by a clear evaluation protocol for testing code intelligence models.']","To develop a code intelligence model for the Romanian language, we need to create a dataset that can facilitate the training and evaluation of such models. The goal is to design a dataset that includes problem definitions written in Romanian, along with corresponding solutions and test cases.

First, we collaborate with InfoArena, a popular Romanian competitive programming platform, to collect a large number of coding problems, solutions, and test cases. InfoArena hosts 3,072 coding problems with varying difficulty levels. We filter out problems that lack submitted solutions, examples, or do not follow the standard problem template, resulting in 2,642 problem statements.

The problem statements are written in native Romanian and follow a common format, including an initial preamble, input/output data specifications, and concrete examples. We clean the problem text by removing markdown formatting, ensuring consistency across all problems.

For solutions, we collect an average of 260.92 submissions per problem, with a total of 653,094 solutions written in C/C++ or Pascal. We keep only C/C++ solutions, remove redundant comments, and format them to a common code style. We provide both the full set of solutions and a curated set of 11,250 top-scoring, shortest solutions for each problem. To increase the diversity of programming languages, we also transpile the C/C++ solutions into Python using the OpenAI API, specifically the ""gpt-3.5-turbo"" model.

The dataset, dubbed RoCode, includes test cases for each problem to evaluate the correctness and algorithmic complexity of the solutions. There are a total of 35,758 tests, with an average of 13 tests per problem. We provide the smallest 5 tests for each problem, as well as an environment to automatically score the generated solutions.

To estimate problem difficulty, we compute the average score of submitted user solutions, divided by the number of unique users, and adjust for recency. We split RoCode into ""easy"", ""medium"", and ""hard"" problems based on the difficulty distribution, resulting in 790, 922, and 934 problems, respectively.

We split the dataset into training, validation, and test subsets, with 2,112, 264, and 266 problems, respectively, to enable researchers to fine-tune code generation models and compare approaches.

To evaluate existing language models on RoCode, we follow the evaluation procedure proposed by Hendrycks et al. (2021), using a specific prompt to generate solutions. We test both Romanian language models (Ro-GPT2 and GPT-Neo-Ro) and English-oriented models (replit-code-v1-3b, LLaMA-7b, OpenLLaMA-7b, and WizardCoder-Python-7b). The results show that current models struggle to solve problems expressed in Romanian, with poor performance across all metrics.

The creation of RoCode addresses the need for a benchmarking dataset for code intelligence in Romanian, providing a challenging testbed for monolingual and multilingual models. By making RoCode publicly available, we facilitate further research in code intelligence for low-resource languages like Romanian.",48941efa725cfdfc,4178558c4762d761,cs,cs.CL,2402.13222
You are working on a multitask learning project and want to develop a method that can adaptively reweight tasks based on their impact on a target task. You have a set of tasks with different training datasets and a shared model architecture. You need to design an algorithm that can optimize task weights during training to maximize the target task's performance.,"['The solution introduces additional parameters (α-variables) associated with task-specific model updates.'
 ""The approach optimizes α-variables with respect to the target task's development loss.""
 'The method uses metaoptimization to adjust task weights.'
 'The approach is end-to-end differentiable.'
 'The solution does not require manual tuning of task weights.'
 'The approach is adaptive and can reweight tasks based on their impact.'
 'The method is designed to handle tasks with different levels of importance.'
 'The method does not rely on a priori knowledge of task relationships.'
 'The solution is designed to minimize negative transfer between tasks.'
 'The method is designed to be computationally efficient.']","To address the given scenario, we need to develop a method that can adaptively reweight tasks based on their impact on a target task in a multitask learning setting. The approach should optimize task weights during training to maximize the target task's performance.

First, we define the target task-oriented multitask learning problem. We have a set of classification tasks T = {t1, t2, ..., tn}, each associated with training and validation datasets, D_train^t and D_dev^t, as well as a target task t* ∈ T. The goal is to find weights W = {w1, w2, ..., wn} capturing the importance of each task such that training the parameters θ of a Deep Neural Network on the weighted sum of losses for each task maximizes the model's performance on the target task's development set.

The proposed method, α-Variable Importance Learning (αVIL), introduces additional parameters – α-variables – into the model, which are associated with the task-specific model updates. The αVIL algorithm works as follows:

1. Initialize all task weights to 1.
2. For each training epoch, perform the following steps:
   a. For each task ti, sample a subset of its training data D_train^t_i, and perform a task-specific model update starting from the current model parameters θ to obtain θ_t_i. The update is done by minimizing the weighted sum of the task's loss.
   b. Compute the task-specific model delta δ_t_i = θ_t_i - θ.
   c. Optimize the α-variables {α1, α2, ..., α|T|} with respect to the target task's development loss L(D_dev^*, θ + α1δ1 + ... + α|T|δ|T|). This step involves finding the optimal mixing factors of the task updates that minimize the target task's loss.
   d. Update the model parameters θ by interpolating the task-specific deltas using the optimized α-variables: θ = θ + α1δ1 + ... + α|T|δ|T|.
   e. Update the task weights W based on the optimized α-variables: wi = wi + (αi - 1).

The α-variables are optimized using gradient descent, leveraging the end-to-end differentiability of the model. The task weight update rule captures the intuition that if a task update was up- or down-scaled during the α-tuning stage, the task's weight should be updated accordingly for the next delta collection phase.

The αVIL method is designed to be flexible and can be used with different optimization methods for α-variables. It does not require manual tuning of task weights and can adaptively reweight tasks based on their impact on the target task. The approach is also designed to minimize negative transfer between tasks.

To evaluate αVIL, we can apply it to different multitask learning scenarios, such as Computer Vision and Natural Language Understanding tasks. For instance, we can use the MultiMNIST dataset, which involves classifying super-imposed digits, and the NLU tasks from the GLUE and SuperGLUE benchmarks.

The model architecture for MultiMNIST consists of a shared convolutional encoder and task-specific heads, while for NLU tasks, we use a RoBERTa-based shared encoder with task-specific classification heads. We compare αVIL to single task and standard multitask baselines, as well as a strong target task-oriented optimization approach, Discriminative Importance Weighting (DIW).

The experiments involve training the models for a specified number of epochs, evaluating their performance on the development sets, and submitting the predictions to the relevant benchmarks for test set evaluation. The results are averaged over multiple random seeds to account for variability.

By following this plan, we can effectively develop and evaluate αVIL, a novel method for target task-oriented multitask learning that adaptively reweights tasks based on their impact on the target task's performance.",9d467603747467d4,0f61d40ec66502a5,cs,cs.LG,2405.07769
"You are tasked with developing a Bayesian neural network (BNN) for image classification that accurately represents the aleatoric uncertainty in the data. The standard Dirichlet prior used to control aleatoric uncertainty diverges when applied directly over model parameters, rendering it impractical. Your goal is to modify the Dirichlet prior to create a valid prior distribution that can be used to control the model's aleatoric uncertainty without tempering the posterior. You need to ensure that the modified prior is practical to sample and achieves performance comparable to posterior tempering.","['The modified prior distribution must be valid (i.e., integrable) over the domain of model parameters.'
 'The modification should directly address the divergence issue of the original Dirichlet prior.'
 'The prior should be practical to sample using gradient-based sampling algorithms like SGHMC.'
 ""The prior should allow for control over the model's aleatoric uncertainty.""
 'The solution should not require significant changes to the existing BNN architecture or training procedure.'
 'The impact of the modification on the prior density and its implications for the posterior distribution should be analyzed.'
 'The solution should include a discussion on the choice of hyperparameters for the modified prior.'
 'A comparison with other methods for controlling aleatoric uncertainty, such as posterior tempering, should be provided.'
 'The computational cost and any potential scalability issues of using the modified prior should be considered.'
 'The solution should be grounded in a theoretical understanding of Bayesian neural networks and prior distributions.']","To develop a Bayesian neural network (BNN) for image classification that accurately represents the aleatoric uncertainty in the data, we need to modify the Dirichlet prior to create a valid prior distribution that can be used to control the model's aleatoric uncertainty without tempering the posterior.

First, we introduce the DirClip prior, a clipped version of the Dirichlet prior. The DirClip prior is defined as c log p(ŷ) = K X (α − 1) max(log ŷ k , v), where v is a clipping value (e.g., v = −10). This modification bounds the prior density, making it a valid distribution over model parameters. The DirClip prior is identical to the Dirichlet prior for log-probabilities between the clipping value v and stays at the clipping value otherwise.

To understand why the Dirichlet prior diverges when applied over model parameters, we analyze its probability density function (PDF). The Dirichlet prior's PDF diverges to ∞ as ŷ approaches either 0 or 1. In contrast, the DirClip prior's density is bounded, making it a valid prior distribution.

We use the DirClip prior to control the level of aleatoric uncertainty in a ResNet20 trained on CIFAR-10 with data augmentation. By varying the concentration parameter α, we can increase the training accuracy from 88% to 99% and test accuracy from 89% to almost 94%. However, we observe that the model trained from random initialization only converges when α > 0.8. For α < 0.8, the accuracy suddenly drops to 10% due to the challenges of gradient-based sampling algorithms.

To mitigate this issue, we fine-tune the model from a checkpoint with 100% training accuracy. We show that fine-tuning stabilizes training and allows the model to converge for α < 0.8. We analyze the gradient field of the Dirichlet posterior and derive a condition for the update of the true class to be positive. We find that for α > 0.8, the probability of the correct class always increases, while for α < 0.8, the update may decrease the probability of the correct class.

In addition to the DirClip prior, we introduce a confidence prior that directly enforces high prediction confidence. The confidence prior is defined as p(ŷ) ∝ max k ŷ k 1/T −1 . We show that when combined with a categorical likelihood, the confidence prior converges to a cold likelihood as T → 0. However, the confidence prior is not practical to sample due to its many local maxima.

We compare the performance of the DirClip prior with posterior tempering and the Noisy Dirichlet Gaussian (NDG) posterior. We show that the DirClip prior achieves similar test accuracy to a cold posterior and outperforms the original posterior. We also examine the effect of the DirClip prior on the model's confidence and uncertainty estimates.

To implement the DirClip prior, we use Stochastic Gradient Hamiltonian Monte Carlo (SGHMC) to sample from the posterior distribution. We generate multiple posterior samples from different random initializations to eliminate autocorrelation. We use a learning rate schedule and temperature schedule to control the sampling process.

Our experiments are implemented in JAX using TPU v3-8 devices. We use a ResNet20 architecture and CIFAR-10 dataset with data augmentation. We evaluate the training accuracy, test accuracy, and test likelihood of various posterior distributions. We show that the DirClip prior achieves high training accuracy and test accuracy while maintaining a reasonable test likelihood.

Overall, our research plan involves modifying the Dirichlet prior to create a valid prior distribution that controls the model's aleatoric uncertainty. We introduce the DirClip prior and confidence prior, analyze their properties, and compare their performance with posterior tempering and NDG posterior. We implement the DirClip prior using SGHMC and evaluate its performance on CIFAR-10. Our approach provides a theoretically grounded solution for controlling aleatoric uncertainty in BNNs.",7e9ab3ea70ea0bf7,922a6c3be81e3b34,cs,cs.LG,2403.01272
"You are developing an image denoising framework that uses a learned variance-stabilizing transformation (VST) to transform real-world noise into a Gaussian-like distribution, allowing the use of pre-trained Gaussian denoisers. During training, you employ a blind-spot denoiser to enable self-supervised learning of the VST. However, you are aware that blind-spot denoisers have limitations, such as not using the information of the pixel being denoised, which can lead to suboptimal performance. Propose a strategy to overcome this limitation and achieve improved denoising performance. Explain how you would modify your training and inference procedures to leverage the strengths of both blind-spot and classic Gaussian denoisers.","['The proposed strategy involves using a blind-spot denoiser during training to learn the VST.'
 'The blind-spot denoiser is used to minimize a self-supervised loss function that does not depend on the clean image.'
 'At inference, the blind-spot denoiser is replaced with a classic Gaussian denoiser for improved performance.'
 'The replacement of the blind-spot denoiser with a classic Gaussian denoiser at inference is justified by the independence of the optimal VST on the denoiser used.'
 'The classic Gaussian denoiser used at inference is pre-trained and has not been fine-tuned during the training of the VST.'
 'The use of a classic Gaussian denoiser at inference avoids the checkerboard artifacts inherent to blind-spot denoisers.'
 'The strategy leverages the strengths of both blind-spot and classic Gaussian denoisers, combining self-supervised training with improved inference performance.'
 'The proposed strategy does not require any additional training data beyond the single noisy input image.'
 'The VST learned during training is expected to generalize well to different denoisers, including the classic Gaussian denoiser used at inference.'
 'The inference procedure is straightforward and does not introduce significant additional computational overhead.']","To overcome the limitation of blind-spot denoisers in the context of image denoising using a learned variance-stabilizing transformation (VST), we propose a strategy that leverages the strengths of both blind-spot and classic Gaussian denoisers. The goal is to achieve improved denoising performance by modifying the training and inference procedures.

First, during training, we employ a blind-spot denoiser to enable self-supervised learning of the VST. The blind-spot denoiser is used to minimize a self-supervised loss function that does not depend on the clean image. This is achieved by ensuring that the denoiser's output for a given pixel does not use the information from that pixel, thus preventing the network from learning the identity function. The self-supervised loss function is based on the quadratic risk between the denoised image and the noisy input image.

To implement this, we start by fixing the parameters of a pre-trained Gaussian denoiser and adapting it to create a blind-spot denoiser. We achieve this by making the denoiser J-invariant, where J is a partition of the pixels such that neighboring pixels are in different subsets. The blind-spot denoiser is then realized by replacing each pixel with an average of its neighbors, using a function η.

Next, we define the VST, denoted as fθ, and its inverse, denoted as fθ,α,β^(-1), using increasing continuous piecewise linear (CPWL) functions. The CPWL functions are parameterized by a vector θ, which is learned during training. The inverse transformation also includes affine parameters α and β to mitigate potential bias.

The training process involves minimizing the self-supervised loss function Lθ,α,β^D̄(z, z) = ∥(fθ,α,β^(-1) ∘ D̄ ∘ fθ)(z) - z∥2^2, where D̄ is the blind-spot denoiser, and z is the noisy input image. This loss function is minimized with respect to the parameters θ, α, and β.

At inference, we replace the blind-spot denoiser D̄ with a classic Gaussian denoiser D. This substitution is justified by the fact that the optimal VST should not depend on the denoiser used. By using a classic Gaussian denoiser at inference, we avoid the checkerboard artifacts inherent to blind-spot denoisers and achieve improved denoising performance.

The final denoised image is obtained by applying the learned VST and its inverse to the noisy input image, using the classic Gaussian denoiser in between: ŝ = (fθ,α,β^(-1) ∘ D ∘ fθ)(z).

The proposed framework, named Noise2VST, is computationally efficient during training and inference. Training is performed on randomly cropped patches of the noisy input image, which accelerates the process. The inference procedure is straightforward and does not introduce significant additional computational overhead.

The Noise2VST framework is designed to be flexible, allowing the use of different pre-trained Gaussian denoisers at inference. It is also robust to variations in the input noisy images and noise characteristics.

Overall, the proposed strategy leverages the strengths of both blind-spot and classic Gaussian denoisers, combining self-supervised training with improved inference performance. It provides a viable solution for real-world image denoising without requiring additional training data beyond the single noisy input image.",e05140350fd266dc,2a731c1a5742fba4,cs,cs.CV,2407.17399
"You are a researcher working on improving mutation testing for safety-critical cyber-physical systems (CPS) software written in C. The current state-of-the-art tool, SEMu, relies on symbolic execution, which has limitations when dealing with complex input generation, such as programs with floating-point instructions. Your goal is to develop a novel approach that overcomes these limitations and effectively generates test cases that can detect faults injected into the software (mutants). You need to design a method that can automatically generate unit test cases in C that detect injected faults in mutants, leveraging existing techniques and tools. The new approach should be able to handle programs where symbolic execution is infeasible and should be guided by a clear understanding of how to measure the effectiveness of the generated test cases.","['The solution proposes using a grey-box fuzzing tool to generate test cases for mutation testing.'
 'The solution explains how to create a fuzzing driver that invokes both the original and mutated functions with the same input data.'
 'The solution describes how to compare the outputs of the original and mutated functions to detect differences.'
 'The solution discusses the role of coverage feedback in guiding the fuzzer to generate effective inputs.'
 'The solution addresses the challenge of handling programs with complex input generation requirements.'
 'The solution explains how to determine if a mutant is killed based on the outputs of the original and mutated functions.'
 'The solution discusses the importance of handling non-deterministic outputs from the functions under test.'
 'The solution outlines a method for generating unit test cases from the inputs that kill mutants.'
 'The solution explains how to run the fuzzer and process the generated logs to identify killed mutants.'
 'The solution proposes a way to compare the effectiveness of the new approach with the state-of-the-art tool, SEMu.']","To address the given research scenario, we will develop a novel approach for mutation testing of safety-critical cyber-physical systems (CPS) software written in C, overcoming the limitations of the current state-of-the-art tool, SEMu, which relies on symbolic execution. The new approach will leverage grey-box fuzzing to generate unit test cases in C that detect faults injected into the software (mutants).

First, we will utilize a grey-box fuzzing tool, AFL++, to generate test cases. AFL++ is chosen for its ability to leverage coverage feedback to guide the generation of inputs that effectively exercise the software under test. This characteristic is crucial for overcoming the limitations of symbolic execution, particularly when dealing with programs that have complex input generation requirements, such as those with floating-point instructions.

The process begins with generating a fuzzing driver for each function under test and its corresponding mutants. The fuzzing driver will have four main responsibilities:
1. Load input data provided by the fuzzer.
2. Declare variables for the parameters and return values of both the original and mutated functions.
3. Invoke both the original and mutated functions with the same input data.
4. Compare the outputs of both functions to detect any differences.

To compare the outputs, we will consider all parameters and return values, as in C, parameters can be used to store outputs due to the use of pointers and reference arguments. If differences are observed, the fuzzing driver will abort its execution, signaling to the fuzzer that the mutant has been killed.

Next, we will generate seed files based on the types of input parameters for the function under test. For each primitive type, we will identify representative seed values that cover basic cases, such as zero, a negative number, and a positive number for numeric types. For each fuzzing driver, we will generate at most three seed files to ensure that every parameter is assigned each seed value at least once.

The fuzzing driver, the mutated function, and the software under test will be compiled using the fuzzer compiler. The compile commands will be specified in a configuration file to ensure flexibility and adaptability to different projects.

After compilation, we will run the fuzzer, which will generate logs and potentially crashing inputs. We will process these logs to identify mutants that have been killed. To validate the killing of mutants, we will execute the inputs that led to the killing with an additional test driver that runs the original function twice to check for non-deterministic outputs. If the outputs differ, the mutant is not considered killed.

Finally, we will generate unit test cases from the inputs that killed the mutants. These test cases will be similar to the fuzzing drivers but will be designed for regression testing, verifying that the original function behaves as expected.

To evaluate the effectiveness of our approach, we will compare it with SEMu, the state-of-the-art tool, on subjects that can be processed by both tools. We will also apply our tool to subjects where SEMu is infeasible, demonstrating its broader applicability.

Our approach addresses the challenges of mutation testing for CPS software written in C by leveraging grey-box fuzzing. It handles programs with complex input generation requirements and provides a clear method for determining the effectiveness of the generated test cases. The plan includes a detailed process for generating fuzzing drivers, seed files, compiling the necessary components, running the fuzzer, and post-processing the results to generate unit test cases.

By following this approach, we aim to develop a tool, MOTIF, that outperforms SEMu and can be applied to a wider range of CPS software, enhancing the mutation testing process for safety-critical systems. Future work will involve extending MOTIF to support C++ and exploring different fuzzing configurations and tools to further improve effectiveness.",0e7df377ae20d9bf,ab39be2b05bef3d6,cs,cs.SE,2406.02398
"You are tasked with designing a spatial filter for real-time video processing on an FPGA. The filter needs to be highly precise, but the available hardware resources are limited. The input video stream is 1080p at 60 FPS, and the filter must be able to process it without any significant latency. You have the option to use either fixed-point or custom floating-point arithmetic. Describe your approach to implementing the spatial filter, considering the tradeoff between precision and hardware compactness.","['The proposed approach considers the use of custom floating-point arithmetic for implementing the spatial filter.'
 'The solution acknowledges the tradeoff between precision and hardware compactness in the design.'
 'The approach is tailored for FPGA implementation, considering its specific constraints and capabilities.'
 'The design aims to achieve high precision as required for the video processing task.'
 'The solution takes into account the limited availability of hardware resources on the FPGA.'
 'The approach considers the latency constraint and aims to minimize it.'
 'The solution involves a comparison or consideration of fixed-point arithmetic as an alternative.'
 'The design is flexible and allows for adjustment of precision based on the available hardware resources.'
 'The proposed approach includes a method for evaluating or testing the precision of the filter.'
 'The solution is pipelined to achieve high performance and meet the real-time requirement.']","To implement a spatial filter for real-time video processing on an FPGA, we will design a highly precise filter that can process 1080p video at 60 FPS while considering the tradeoff between precision and hardware compactness.

First, we will utilize custom floating-point arithmetic to achieve the required precision. The use of custom floating-point allows for a parameterizable dynamic range and precision, making it suitable for applications where high precision is necessary. We will implement the spatial filter using a generic structure that can be applied to various filter types, including linear convolutions and non-linear filters.

The generic filter structure will be based on a window generator that produces a window neighbourhood of dimensions H × W. This will require H − 1 line buffers, which will be efficiently mapped to BRAMs in the FPGA. For a filter of dimension 3 × 3, two line buffers will be used, and for a filter of dimension 5 × 5, four line buffers will be used.

For linear convolutions, we will implement an adder tree structure to accumulate the products of the pixels and kernel coefficients. The adder tree will be pipelined to achieve high performance and minimize latency. The number of stages in the adder tree will be determined by the number of inputs, and the latency will be calculated based on the latency of the floating-point addition.

To handle non-linear filters, such as the median filter, we will use a sorting network to sort the pixels within the window neighbourhood. The median filter will be composed of two SORT 5 networks operating in parallel, and the output will be the mean of the two sorted results.

For more complex non-linear filters with custom functions, we will implement a generic filter structure that can be defined by a user-provided function. The function will be represented as an Abstract Syntax Tree (AST), which will be used to generate the corresponding hardware architecture.

To achieve high performance and meet the real-time requirement, we will pipeline the filter architectures. The pixel clock will be set to 148.5 MHz to process 1080p video at 60 FPS.

To evaluate the tradeoff between precision and hardware compactness, we will implement the spatial filters using different custom floating-point types with varying widths from 16 to 64 bits. We will analyze the resource utilization, including LUTs, flip-flops, BRAMs, and DSP blocks, for each filter implementation.

To simplify the design process and reduce the error-prone tendency of manual hand-written RTL, we will use a Domain-Specific Language (DSL) to generate custom floating-point cores. The DSL compiler will translate code from a high-level language into SystemVerilog instances of pipelined floating-point blocks.

The DSL code will be used to implement the spatial filters, including the linear convolution and non-linear filters with custom functions. The DSL compiler will generate the corresponding SystemVerilog code, which will be synthesized on the Zybo Z7-20 FPGA board.

By using custom floating-point arithmetic and a DSL to generate the hardware architecture, we will be able to achieve a high degree of precision while minimizing hardware resource usage. The pipelined architecture will ensure that the filter can process 1080p video at 60 FPS in real-time.

The final implementation will be evaluated based on its resource utilization, throughput, and latency. The results will demonstrate the effectiveness of the proposed approach in achieving a balance between precision and hardware compactness.

Overall, our approach will provide a flexible and efficient solution for implementing spatial filters on FPGAs, allowing for the rapid prototyping of image processing algorithms while meeting the real-time processing requirements.",2c49e133b3dc88d1,a63c24e483caa7b5,cs,cs.AR,2409.05837
"You are exploring novel neural network architectures that can be trained using a non-traditional method that updates node weights independently. The goal is to create a neural network that can be trained without relying on backpropagation or gradient descent. You want to design a network that can have arbitrary connections between nodes, potentially leading to a closer resemblance to biological neural networks. What would be the key features of your proposed neural network architecture, and how would you train it?","['The proposed neural network architecture should allow for arbitrary connections between nodes.'
 'The training method should update node weights independently without relying on backpropagation.'
 'The training process should not require a fixed or standard layer structure.'
 'The node weights should be updated in parallel without depending on the updates of other nodes.'
 'The method should include a mechanism for evaluating the performance of the network.'
 'The proposed solution should be scalable to larger and more complex neural networks.'
 'The proposed architecture should potentially lead to a closer resemblance to biological neural networks.'
 'The method should not require a specific order or sequence for updating node weights.'
 'The proposed method should be robust to variations in network architecture and connectivity.'
 'The solution should include a way to control or guide the independent weight updates.']","To address the given research scenario, we propose a novel neural network architecture and training method that updates node weights independently without relying on backpropagation or gradient descent. The goal is to create a network that can have arbitrary connections between nodes, potentially leading to a closer resemblance to biological neural networks.

### Neural Network Architecture

The proposed neural network architecture consists of multiple layers with nodes that can have arbitrary connections between them. Each node in the network is treated as an independent entity, and its weights are updated separately. The architecture is not limited to a standard layer structure, allowing for non-standard connectivity between nodes.

### Training Method

The training method is based on the principles of Particle Swarm Optimization (PSO). In this approach, each node in the network is associated with a swarm of particles, where each particle represents a set of weights for that node. The particles update their positions based on the PSO algorithm, which involves updating the velocity and position of each particle using the personal best and global best values.

The key steps in the training method are as follows:

1. **Initialization**: Initialize the network with the required number of layers and nodes. Each node is associated with a swarm of particles, and the weights for each particle are randomly initialized.
2. **Weight Update**: For each batch of data, update the weights of each node independently using the PSO algorithm. The loss function value is computed for each particle in a node while fixing the weights of the other nodes.
3. **Personal Best and Global Best Update**: Update the personal best and global best values for each particle based on the loss function values computed.
4. **Validation Loss Computation**: Combine the global best particle positions for all nodes and compute the validation loss.
5. **Global Best Weights Update**: Update the global best weights for the network based on the validation loss.

### Mechanism for Evaluating Performance

The performance of the network is evaluated using a validation loss function. The validation loss is computed after updating the weights of all nodes, and it is used to guide the independent weight updates.

### Handling Complex Neural Networks

The proposed method can handle complex neural networks with non-standard connectivity. The arbitrary connections between nodes are allowed, and the weights are updated independently.

### Parallel Weight Updates

The weight updates in each node are independent and can be performed in parallel without depending on the updates of other nodes.

### Handling Non-Linear Activation Functions

The proposed method can handle non-linear activation functions. The type of activation function used does not affect the weight update operation.

### Scalability

The proposed method is scalable to larger and more complex neural networks. The independent weight updates and parallel computation allow for efficient training of large networks.

### Adaptability to Different Problem Domains and Datasets

The proposed method can adapt to different problem domains and datasets. The use of a validation loss function guides the weight updates, allowing the network to learn from the data.

### Robustness to Variations in Network Architecture and Connectivity

The proposed method is robust to variations in network architecture and connectivity. The arbitrary connections between nodes are allowed, and the weights are updated independently.

### Controlling Independent Weight Updates

The global best weights for each node constrain and guide the independent weight updates. The validation loss computation ensures that the network is optimized towards the desired objective.

The flowchart of the proposed method is shown in Figure 3 of the document, which illustrates the batch-wise training approach. The algorithm for the proposed method is presented in Algorithm 1, which outlines the steps involved in training a neural network without backpropagation using particles.

By following this research plan, we aim to develop a novel neural network architecture and training method that can potentially lead to a closer resemblance to biological neural networks.",05db985cb5f60d2c,6e47a449a5c68654,cs,cs.NE,2412.05667
"You have applied an interpretable clustering methodology to a large dataset of student behavior in a MOOC and obtained several clusters with varying levels of student engagement and performance. Upon analyzing the clusters, you notice that some clusters have similar academic outcomes but exhibit distinct behavioral patterns. How would you utilize these insights to inform targeted educational interventions and support students more effectively?","['The proposed interventions should be based on the distinct behavioral patterns identified in the clusters.'
 'The approach should take into account the varying levels of student engagement across clusters.'
 'The methodology must consider the academic outcomes associated with each cluster.'
 'The approach should be able to distinguish between clusters with similar outcomes but different behaviors.'
 'The interventions should be designed to support students in clusters with lower performance.'
 'The approach should be able to identify clusters with unique characteristics.'
 'The approach should be able to evaluate the effectiveness of the targeted interventions.'
 'The methodology should be adaptable to different educational settings.'
 'The interventions should be designed to be feasible to implement in a real-world educational context.'
 'The methodology should provide a clear plan for implementing and evaluating the targeted interventions.']","To address the scenario, we will utilize the Interpret3C clustering pipeline to identify distinct behavioral patterns among students in a MOOC and inform targeted educational interventions. The approach involves analyzing the clusters obtained from the Interpret3C methodology, which incorporates interpretable neural networks for individualized feature selection.

First, we analyze the clusters resulting from the Interpret3C pipeline, focusing on the distribution of important features within each cluster. The pipeline identifies six behavioral clusters (A through F) with varying levels of student engagement and performance. We examine the percentage of students in each cluster for whom specific features are deemed important, as well as the distribution of feature values across clusters.

The analysis reveals that while some clusters have similar academic outcomes, they exhibit distinct behavioral patterns. For instance, Clusters D and E have comparable passing rates (16.8% and 15.2%, respectively), but differ significantly in their engagement patterns. Students in Cluster D are highly engaged with quizzes, spending extensive time on problem-solving, whereas students in Cluster E are generally disengaged from both videos and quizzes.

To inform targeted educational interventions, we will:

1. **Identify cluster-specific behavioral patterns**: We will delve deeper into the characteristic behaviors and feature importance within each cluster. This involves understanding the specific actions, engagement levels, and learning strategies employed by students in each cluster.

2. **Analyze academic outcomes associated with each cluster**: We will examine the academic performance of students within each cluster, including their passing rates and overall achievement. This step is crucial for understanding the effectiveness of current instructional strategies and identifying areas where interventions are needed.

3. **Design targeted interventions based on cluster characteristics**: By understanding the distinct behavioral patterns and academic outcomes of each cluster, we can develop interventions tailored to the specific needs of each group. For example, students in Cluster D may benefit from additional support or resources related to quiz content, while students in Cluster E may require more general motivational or engagement strategies to encourage participation.

4. **Consider the varying levels of student engagement across clusters**: The design of interventions will take into account the differing levels of engagement observed across clusters. For highly engaged clusters, interventions might focus on enhancing their engagement further or providing more challenging content. For disengaged clusters, interventions will aim to re-engage students through targeted support or by making the content more appealing.

5. **Evaluate the effectiveness of targeted interventions**: To assess the impact of our interventions, we will implement a systematic evaluation plan. This involves setting clear metrics for success, monitoring student progress over time, and comparing outcomes between intervention and control groups. The evaluation will help refine the interventions and ensure they are meeting their intended goals.

6. **Ensure the interventions are feasible and adaptable**: The proposed interventions will be designed with feasibility and adaptability in mind, considering the constraints and resources available in real-world educational settings. This includes leveraging existing educational technologies, collaborating with educators, and ensuring that interventions are scalable.

By following this approach, we can leverage the insights gained from the Interpret3C clustering pipeline to develop and implement targeted educational interventions that address the specific needs and challenges of different student groups within the MOOC. This will ultimately enhance student support and improve academic outcomes.",914e790e7bbbd36e,0002eb0a6cef9c3d,cs,cs.HC,2407.11979
"You are tasked with developing a system to detect online sexism in a multilingual dataset consisting of Hindi, Tamil, and Indian English text. The dataset contains a mix of explicit and implicit abusive language, with varying linguistic structures and cultural nuances. Your goal is to design a robust classification model that can effectively capture the complexities of abusive language across different languages. You have access to pre-trained word embeddings like GloVe and FastText, and you can experiment with different neural network architectures. However, you need to ensure that your model can handle localized features and sequential dependencies in the text data. How would you approach this task?","['The proposed model should be an ensemble architecture that combines the strengths of CNNs and BiLSTMs.'
 'The CNN component should be used to capture localized features indicative of abusive language.'
 'The BiLSTM component should be used to analyze the sequence for dependencies among words and phrases.'
 'The model should utilize pre-trained word embeddings like GloVe and FastText for the respective languages.'
 'The model should be able to handle varying linguistic structures and cultural nuances across languages.'
 'The use of pre-trained embeddings should be justified by their ability to quantify semantic similarities between linguistic terms.'
 'The model should include a mechanism to combat overfitting, such as dropout.'
 'The model should be able to process textual inputs bidirectionally to comprehensively analyze the text.'
 'The approach should be evaluated using metrics that provide a balanced measure between precision and recall.'
 'The training process should involve a suitable validation strategy (e.g., 5-fold cross-validation) to ensure robustness.']","To develop a system for detecting online sexism in a multilingual dataset consisting of Hindi, Tamil, and Indian English text, we will follow a research plan that leverages the strengths of ensemble architectures, pre-trained word embeddings, and deep learning techniques.

First, we will utilize the dataset provided, which contains annotated Twitter posts in English, Hindi, and Tamil. The dataset is comprehensive, with 7638 posts in English, 7714 in Hindi, and 7914 in Tamil, annotated by 18 activists and researchers with expertise in gender studies. We will calculate the final label for each sentence based on the majority vote among annotators.

To preprocess the data, we will remove stopwords, symbols, tags, and emojis, which is expected to improve the generalization of our models. We will then split the datasets into an 80/20 train-test split for model development and validation.

Our model will be an ensemble architecture that combines the strengths of Convolutional Neural Networks (CNNs) and Bidirectional Long Short-Term Memory (BiLSTM) networks. The CNN component will capture localized features indicative of abusive language through its convolution filters applied on embedded input text. The BiLSTM component will analyze the sequence for dependencies among words and phrases, processing textual inputs bidirectionally to comprehensively analyze the text.

For the initial input layers, we will use pre-trained GloVe and FastText embeddings for the respective languages, representing words as 300-dimensional dense vectors. The sequence length will be capped at 100 words. We will use GloVe embeddings for English and FastText embeddings for Hindi and Tamil, as these embeddings have been shown to effectively quantify semantic similarities between linguistic terms.

The CNN-BiLSTM architecture will be implemented as follows: a one-dimensional convolution layer with 64 filters and a kernel size of 2 will capture localized textual patterns. The output will be passed through a Bidirectional LSTM layer with 128 units and a return sequence setting, coupled with a dropout of 0.1 and recurrent dropout of 0.1. This will be followed by a dense layer with 128 neurons and Global Average Pooling for dimensionality reduction and holistic sequence information aggregation. Finally, a dropout layer will be employed, whose output will be passed through a dense layer with a softmax activation function to generate the classification model.

To combat overfitting, we will use SpatialDropout1D, a dropout variant that selectively drops entire 1D feature maps during training. We will also use a 5-fold cross-validation strategy with a batch size of 32 training patterns for Tasks 1 & 3, and a batch size of 64 training patterns for Task 2. The models will be trained using the Adam optimizer and Categorical Crossentropy as the loss function.

For Task 2, we will utilize transfer learning from other open datasets concerning hate speech and toxic text recognition in Indic languages. We will concatenate the provided dataset with external datasets, such as the Multilingual Abusive Comment Detection (MACD) dataset for Hindi and Tamil, and the MULTILATE dataset for English.

To evaluate our models' performance, we will use metrics such as precision, recall, and the F1 score, which provide a balanced measure between precision and recall. We will generate classification reports for the models of each language across each task and calculate the average macro scores.

By synergistically integrating the CNN-BiLSTM architecture and leveraging pre-trained word embeddings, our approach is designed to capture nuanced patterns in the text data and facilitate robust performance in classifying abusive and sexist language across diverse linguistic contexts.",ec43050becd21dd9,99312c1f13cfbd15,cs,cs.CL,2404.02013
"You are evaluating the effectiveness of a new data synthesis approach, DART-Math, which is designed to improve the mathematical problem-solving abilities of large language models (LLMs) through instruction tuning. DART-Math uses difficulty-aware rejection sampling strategies (Uniform and Prop2Diff) to create synthetic datasets that are less biased towards easy queries compared to traditional vanilla rejection tuning (VRT). You have access to various base models (Mistral-7B, Llama3-8B, DeepSeekMath-7B, and Llama3-70B) and several mathematical benchmarks for in-domain and out-of-domain evaluation. Your task is to compare the performance of DART-Math with VRT and other state-of-the-art instruction-tuned models, and to analyze the scaling behaviors of DART-Math and VRT as the training data size increases.","['The comparison should include DART-Math (both Uniform and Prop2Diff strategies) and vanilla rejection tuning (VRT) across different base models.'
 'The evaluation should be conducted on a variety of mathematical benchmarks, including in-domain (GSM8K and MATH) and out-of-domain tests.'
 'The comparison should also include other state-of-the-art instruction-tuned mathematical models.'
 'The scaling behaviors of DART-Math and VRT should be analyzed by varying the training data size.'
 'The effect of one-response coverage on the performance of DART-Math should be examined.'
 'The synthesis cost, in terms of the total number of raw samples needed, should be considered.'
 'The impact of the maximum allowable raw samples per query (n_max) on the synthesis cost and achieving ratio should be analyzed.'
 'The comparison with state-of-the-art models should consider the size of the training datasets used.'
 'The analysis should discuss the potential bottlenecks for further improvements, such as query coverage versus response quality.'
 'The discussion should touch upon the broader implications of using DART-Math datasets for advancing mathematical problem-solving capabilities.']","To evaluate the effectiveness of DART-Math, a new data synthesis approach designed to improve the mathematical problem-solving abilities of large language models (LLMs) through instruction tuning, we will conduct a comprehensive research plan. The plan involves comparing the performance of DART-Math with vanilla rejection tuning (VRT) and other state-of-the-art instruction-tuned models across various mathematical benchmarks.

### Step 1: Data Synthesis
We will utilize the DART-Math approach to synthesize datasets using the original training queries of the GSM8K and MATH datasets. The synthesis will be performed using the DeepSeekMath-7B-RL model with temperature sampling and adjusted temperature to sample answer-correct responses to difficult queries. We will implement both Uniform and Prop2Diff strategies to create two datasets, DART-Math-Uniform and DART-Math-Hard, each consisting of around 590k samples.

### Step 2: Training
We will perform standard instruction tuning on the synthesized DART-Math datasets using several base models, including Llama3-8B, Mistral-7B, DeepSeekMath-7B, and Llama3-70B. The training will be conducted using the Transformers library with sequence packing to efficiently save computation wasted by padding tokens. We will tune key hyperparameters like learning rate and number of epochs.

### Step 3: Evaluation
For comprehensive assessment, we will adopt 6 benchmarks for both in-domain and out-of-domain evaluation: GSM8K, MATH, CollegeMath, DeepMind-Mathematics, OlympiadBench-Math, and TheoremQA. The evaluation will be conducted using greedy decoding, and results will be reported in terms of accuracy on these benchmarks.

### Step 4: Comparison with Baselines
We will compare DART-Math with state-of-the-art instruction-tuned mathematical models such as MetaMath, MMIQC, KPMath-Plus, and Xwin-Math. Additionally, we will include VRT as a baseline, synthesizing a dataset of the same size (0.59M examples) using vanilla rejection sampling with DeepSeekMath-7B-RL.

### Step 5: Analysis
1. **Scaling Behaviors**: We will analyze the scaling behaviors of DART-Math and VRT by varying the training data size from thousands to nearly 1 million samples and reporting the performance on the MATH test set.
2. **Effect of One-Response Coverage**: We will examine the impact of ensuring at least one synthetic response for each query, especially for easy queries, by comparing the Prop2Diff strategy with and without this coverage constraint.
3. **Synthesis Cost**: We will consider the synthesis cost in terms of the total number of raw samples needed and the achieving ratio (r) of queries that meet the desired number of responses. We will analyze the impact of the maximum allowable raw samples per query (n_max) on the synthesis cost and achieving ratio.

### Step 6: Discussion
The analysis will highlight the improvements of DART-Math over VRT, especially on difficult benchmarks, and discuss the potential bottlenecks for further improvements, such as query coverage versus response quality. We will also touch upon the broader implications of using DART-Math datasets for advancing mathematical problem-solving capabilities.

By following this research plan, we aim to thoroughly evaluate DART-Math and understand its strengths and limitations in improving the mathematical problem-solving abilities of LLMs.",9fec02e39bd81e9b,fc06a6c185e28a0f,cs,cs.CL,2407.13690
"You need to design a control system for robots that can operate effectively with minimal sensory input. The robots in question have diverse morphologies, materials, and actuation mechanisms, and may not be equipped with conventional sensors. Your task is to develop a method that can control these robots using vision as the primary sensory input. The control system should be able to infer the robot's 3D configuration and predict its motion based on visual information alone. How would you design such a system, and what kind of visual information and processing would be required?","['The proposed control system should be able to operate with a single camera as the only sensor.'
 ""The method should be agnostic to the robot's kinematics, dynamics, material, actuation, and sensing capabilities.""
 'The system should infer a 3D representation of the robot from visual input.'
 ""The 3D representation should encode both the robot's geometry and its differential kinematics.""
 'The approach should leverage recent advancements in computer vision and neural scene representation.'
 'The system should be trained using multi-view video data of the robot executing random commands.'
 'The training process should not require human annotation or expert customization.'
 ""The method should be able to predict the robot's motion as a function of control inputs.""
 'The method should enable closed-loop control to execute desired motions.'
 'The approach should be able to handle occlusions and visual perturbations.']","To design a control system for robots that can operate effectively with minimal sensory input, specifically using vision as the primary sensory input, we will follow a multi-step research plan. This plan is based on the Neural Jacobian Fields architecture introduced in the provided document.

### Step 1: Dataset Collection
We will start by collecting a multi-view video dataset of the robot executing random commands. This involves setting up 12 consumer-grade RGB-D cameras to observe the robot from different perspectives. The cameras will be calibrated to obtain their intrinsics and poses using 3 cm April tags. For each data sample, we will randomly select a command within a safe range for each command line, execute it, and wait for the robot to settle. We will then capture images with all 12 cameras. This process will be repeated to generate a large dataset.

### Step 2: Neural 3D Reconstruction and Scene Representation
We will leverage a deep learning architecture to reconstruct a 3D representation of the robot from a single image. This 3D representation will include both a Neural Radiance Field to encode the robot's 3D geometry and appearance, and a Neural Jacobian Field to encode the robot's differential kinematics. The Neural Jacobian Field will map any 3D point to a linear operator that expresses its 3D motion as a function of robot actuator commands.

### Step 3: Training via Differentiable Rendering
The Neural Jacobian Field and Neural Radiance Field will be trained self-supervised using the collected multi-view video dataset. We will use differentiable rendering to predict both the image and optical flow observed by a target camera given the input view and robot action. The training process will involve minimizing losses for RGB, depth, and 2D motion to supervise the reconstruction of the robot's geometry and kinematics.

### Step 4: Closed-Loop Control
After training, we will use the Neural Jacobian Field to enable closed-loop control of the robot using a single camera. Given a desired 2D motion trajectory, we will use a gradient-based optimizer to solve for the robot command that generates the prescribed motion at interactive speeds. The control process will involve tracking the robot's motion in real-time and adjusting the commands to achieve the desired trajectory.

### Step 5: Validation and Robustness Testing
We will validate the control system on diverse robotic platforms, including a 3D-printed pneumatic hand, a compliant wrist-like robotic platform, a rigid Allegro hand, and a low-cost educational robot arm. We will test the system's robustness against changes in the robot's dynamics, occlusions, and visual perturbations.

### Justification and Details
The Neural Jacobian Fields approach is chosen because it makes no assumptions about the robot's materials, actuation, or sensing capabilities, and it can learn to control the robot from vision alone. The use of multi-view video data at training time allows the system to learn the robot's 3D configuration and kinematics without expert intervention. The differentiable rendering technique enables the training of the Neural Jacobian Field and Neural Radiance Field in a self-supervised manner.

By following this research plan, we aim to develop a control system that can effectively control diverse robots using vision as the primary sensory input, without requiring extensive expert modeling or customization. This approach has the potential to broaden the design space of robotic systems and lower the barrier to entry for robotic automation.",8f171f7a82d02b00,f9da430b14076ad4,cs,cs.RO,2407.08722
You are working on enhancing the performance of LLM-involved agents in a text-based educational environment. These agents are used for diagnostic conversations and are required to balance diagnostic accuracy with conversation quality. You are considering the use of reflective prompting to improve their performance. Investigate the effect of reflective prompting on the efficacy of these agents and propose a strategy to optimize their performance.,"['The investigation considers the impact of reflective prompting on both LLM-based and LLM-assisted RL agents.'
 'The effect of reflective prompting is evaluated on diagnostic accuracy and conversation quality.'
 'The study differentiates between none-reflective and reflective agents.'
 'Reflective agents are given multiple attempts with opportunities for reflection between attempts.'
 'The investigation acknowledges that reflective prompting may have different impacts on different agent types.'
 'The performance of reflective and none-reflective agents is compared across various metrics.'
 'The investigation highlights the importance of considering the agent type when applying reflective prompting.'
 'The study suggests that the reliance on LLM suggestions influences the effectiveness of reflective prompting.'
 ""The proposed strategy involves tailoring the use of reflective prompting based on the agent's architecture and its reliance on LLM.""
 'The investigation contributes to understanding how to optimize the performance of LLM-involved agents through reflective prompting.']","To investigate the effect of reflective prompting on the efficacy of LLM-involved agents in a text-based educational environment, we will follow a structured research plan.

First, we will utilize the PharmaSimText benchmark, a text-based interactive environment derived from the PharmaSim virtual pharmacy environment. This benchmark includes multiple scenarios with diverse patient profiles, allowing us to assess the agents' generalizability across different tasks.

We will develop and evaluate three types of agents: RL-based agents, LLM-based agents, and LLM-assisted RL agents. The RL-based agents will be trained using Deep Q-Networks (DQN) with a state-of-the-art Deep Reinforced Relevance Network (DRRN) architecture. The LLM-based agents will be prompted to interact with the environment, with and without reflective prompting. The LLM-assisted RL agents will integrate LLMs with RL, using two methods: Suggestion-Assisted RL (SA-RL) and Decision-Assisted RL (DA-RL).

To assess the impact of reflective prompting, we will compare the performance of none-reflective and reflective agents across various metrics, including Post-test Performance Score, Trajectory Quality Score, and Combined Score. The none-reflective agents will be limited to a single attempt, while the reflective agents will be given multiple attempts with opportunities for reflection between attempts.

We will evaluate the agents' performance on rephrased versions of the scenarios, measuring their ability to generalize across different wordings. The agents will be trained separately for each patient, with different wordings of subtasks split into training, validation, and test sets.

The investigation will focus on three research questions: 
1. Which agent type demonstrates overall superior performance in conducting effective diagnostic conversations and achieving accurate diagnoses for all available patients?
2. How does reflective prompting influence the diagnostic performance and conversation quality of LLM-involved agents?
3. How do diagnostic performance and conversation quality vary among different agent types across diverse patients?

To address these questions, we will analyze the agents' performance across the defined metrics, comparing the results for none-reflective and reflective agents. We expect to observe that reflective prompting has a nuanced impact on the performance of LLM-involved agents, potentially enhancing the diagnostic accuracy of hybrid LLM-assisted RL agents.

The study will provide insights into the effectiveness of reflective prompting for different agent types and highlight the importance of considering the agent's architecture and its reliance on LLM when applying reflective prompting. By tailoring the use of reflective prompting based on the agent's characteristics, we can optimize the performance of LLM-involved agents in text-based educational environments.

The SA-RL and DA-RL agents will be evaluated to determine which one benefits more from reflective prompting. The results will contribute to understanding how to optimize the performance of LLM-involved agents through reflective prompting.

By following this research plan, we will be able to comprehensively investigate the effect of reflective prompting on LLM-involved agents and provide a thorough understanding of its impact on their performance in text-based educational environments.",ffce18eef0e5fa01,9eafccf161d208bc,cs,cs.LG,2404.18978
"You are working on a project to develop a data selection strategy for instruction tuning of large language models. The goal is to identify a subset of high-quality data that can improve the model's performance while reducing training costs. You have a large dataset with varying levels of complexity and diversity. You need to devise a method to measure the complexity and diversity of the samples in the dataset. The complexity measurement should capture the connection between the instruction and the response, and the diversity measurement should ensure that the selected samples are informative and not redundant.","['The proposed method must be able to measure the complexity of samples based on the connection between the instruction and the response.'
 'The approach should be able to measure the diversity of samples based on their informativeness.'
 'The method should be able to handle varying levels of complexity and diversity in the dataset.'
 'The approach should be able to ensure that the selected samples are not redundant.'
 'The method should be computationally efficient.'
 'The proposed approach should be well-motivated and grounded in the relevant literature.'
 'The method should be able to provide a way to test its effectiveness.'
 'The proposed approach should be able to handle domain-specific datasets.'
 'The method should be able to balance the complexity and diversity of the selected data.'
 'The approach should be able to adapt to the dynamic changes of the model during fine-tuning.']","To address the given scenario, we propose a research plan based on the I TER IT approach, which is designed for instruction tuning of large language models by iteratively selecting high-quality data. The goal is to identify a subset of data that can improve the model's performance while reducing training costs.

### Complexity Measurement
We will measure the complexity of samples using the instruction-following difficulty (IFD) score, which quantifies the connection between the instruction and the response. The IFD score is calculated as the ratio of the perplexity of the response conditioned on the instruction to the perplexity of the response without the instruction. This score assesses how well the model can generate a response based on the given instruction.

### Diversity Measurement
To measure the diversity of samples, we will employ a greedy approach based on the TF-IDF scores of n-grams present in the responses. The TF-IDF score is calculated for each n-gram in the response, and the diversity score is defined as the sum of the TF-IDF scores weighted by the importance of each n-gram. The importance of an n-gram is dynamically adjusted during the selection process by reducing the weight of n-grams that have already been covered in previously selected samples.

### Iterative Data Selection Algorithm
The I TER IT algorithm will be used to integrate both complexity and diversity metrics for data selection. The algorithm works as follows:
1. Calculate the complexity score for all samples in the dataset.
2. Filter out samples with a complexity score greater than or equal to 1.
3. For the remaining samples, calculate the diversity score and the comprehensive score (product of complexity and diversity scores).
4. Greedily select the sample with the highest comprehensive score.
5. Update the diversity scores of the remaining samples by reducing the weight of n-grams covered in the selected sample.
6. Repeat steps 3-5 until the desired number of samples (M) is selected for the current epoch.
7. Update the complexity scores for the top-ranked samples (a × M) after each epoch.

### Experimental Setup
We will conduct experiments on four different instruction-tuning datasets: Alpaca, Alpaca-GPT4, WizardLM, and Dolly. The performance of the models will be evaluated on a range of benchmarks, including GSM8K, MMLU, TruthfulQA, BBH, HumanEval, ARC, and Hellaswag. We will compare our approach with five baselines: Vanilla, Longest, Deita, Superfiltering, and GraphFilter.

### Hyperparameter Tuning
We will investigate the sensitivity of hyperparameters in I TER IT, including the selection size (M), the candidate size for re-calculation (a × M), and the weight decay coefficient (b) for diversity measurement.

### Analysis and Evaluation
We will analyze the characteristics of the selected data, including response lengths and semantic diversity. We will also evaluate the performance of the models trained on the selected data and compare it with the baselines.

### Generalization Ability
To assess the generalization capability of our approach, we will conduct experiments on domain-specific datasets (CodeAlpaca) and other backbone models (Qwen-2.5-7B).

By following this research plan, we aim to demonstrate the effectiveness of the I TER IT approach in selecting high-quality data for instruction tuning of large language models, and to provide insights into its generalization ability across different datasets and models. The I TER IT approach is well-motivated and grounded in the relevant literature, and it addresses the key challenges of measuring complexity and diversity, handling varying levels of complexity and diversity, and adapting to the dynamic changes of the model during fine-tuning.",52608afde71ed09f,9a406e1ae3bb8b77,cs,cs.CL,2412.17365
"You are developing a task-adaptive routing strategy for all-in-one medical image restoration and need a method to generate task-relevant instructions that can guide the routing process. However, you want to avoid using additional supervision or labeled data for this purpose. Describe a novel approach to generate task-relevant instructions without relying on extra supervision.","['The proposed method should generate task-relevant instructions from the input image.'
 'The approach should not require additional supervision or labeled data.'
 'The generated instructions should be discriminative between different MedIR tasks.'
 'The instructions generated should help the network better understand the current task.'
 'The approach should be able to adjust the direction of restoration based on the generated instructions.'
 'The approach should be able to work within the constraints of the all-in-one MedIR model.'
 'The solution should be computationally efficient and not add significant overhead.'
 'The generated instructions should be able to guide the task-adaptive routing process effectively.'
 'The method should be robust to variations in input image quality and degradation.'
 'The approach should be able to handle multiple MedIR tasks simultaneously.']","To generate task-relevant instructions for guiding the routing process in the all-in-one medical image restoration (MedIR) model without relying on additional supervision or labeled data, we propose a novel approach based on the Routing Instruction Network (RIN).

The RIN adaptively generates task-relevant instructions from the input image. It consists of a five-layer CNN encoder that extracts features from the input image, followed by a global average pooling layer. The output of the global average pooling layer is used to predict weights for a learnable instruction dictionary through a fully connected layer and softmax activation. The instruction dictionary contains N learnable instructions, and the weighted sum of these instructions based on the predicted weights generates the task-relevant instruction.

The mechanism of RIN is formulated as: 
I_IR = ∑(α_i * D_i) from i=1 to N, 
where α_i = Softmax(GAP(E(I))), 
E(·) is the CNN encoder, GAP(·) denotes the global average pooling layer, and D = [D_1, D_2, ..., D_N] is the instruction dictionary.

The generated task-relevant instruction I_IR is then used to guide the routing of network features at both spatial and channel levels through Spatial Routing Modules (SRMs) and Channel Routing Modules (CRMs), respectively.

SRMs route input features to different expert networks based on the task-relevant instruction. For a local spatial token x_i of the input feature X, SRM computes a routing function G(x_i, I_IR) = Top-K(Softmax(FC([x_i, FC(I_IR)]))), 
where FC(·) indicates a fully connected layer, and Top-K(·) operator sets all values to be zero except the largest K values. The output x'_i is then computed as a weighted sum of the outputs from different expert networks: 
x'_i = ∑(G(x_i, I_IR)_e * E_e(x_i)) from e=1 to M, 
where E_e refers to the e-th expert in the expert bank E.

CRMs, on the other hand, dynamically route data flow from different tasks to different channels without introducing excessive additional parameters. Given an input feature X, CRM computes a channel-wise binary mask m = Sigmoid(FC(I_IR)), 
and the output X' is obtained by element-wise multiplication of X and m: 
X' = X ⊙ m.

The proposed task-adaptive routing strategy, comprising RIN, SRMs, and CRMs, enables the all-in-one MedIR model to handle multiple tasks simultaneously while mitigating task interference.

To validate the effectiveness of the proposed approach, we conduct extensive experiments on three MedIR tasks: MRI super-resolution, CT denoising, and PET synthesis. We evaluate the performance of the all-in-one MedIR model under both single-task and all-in-one settings and compare it with state-of-the-art baseline models.

Ablation studies are performed to analyze the components of the task-adaptive routing strategy and their impact on the model's performance. We also visualize the task relevance of the generated instructions using t-SNE, demonstrating that the learned instructions are discriminative between different MedIR tasks.

The proposed approach is computationally efficient, as it does not introduce significant overhead. The RIN and routing modules are designed to be lightweight, and the number of parameters added is minimal compared to the overall model size.

Overall, the proposed task-adaptive routing strategy with RIN provides a novel and effective solution for generating task-relevant instructions in the all-in-one MedIR model, enabling it to handle multiple tasks simultaneously while maintaining state-of-the-art performance.",29fbbde66569cb6a,4a690334b5be2329,cs,cs.CV,2405.19769
"You have fine-tuned several LLMs using your large, unified Text2Cypher dataset and observed significant performance gains compared to their baseline versions. However, you are aware that fine-tuning also comes with potential risks and pitfalls, such as the possibility of models memorizing training data or the impact of data distribution shifts on performance. Your goal is to critically evaluate the fine-tuning process and identify potential limitations and areas for improvement. How would you analyze the fine-tuned models and the dataset to understand these risks and potentially mitigate them?","['The solution involves analyzing the dataset for instances with the same ""question"" but different ""cypher"" outputs.'
 'The approach considers the potential for memorization and its impact on model performance.'
 'The solution acknowledges the risk of artificially inflated performance due to training on paraphrased examples of the test set.'
 'The analysis includes checking for data distribution shifts and their potential impact on model performance.'
 'The approach involves planning to clean the test set of instances that may cause inflated performance.'
 'The solution considers the importance of dataset curation and its impact on fine-tuning.'
 'The solution acknowledges the limitations of the current dataset and fine-tuning process.'
 'The analysis includes evaluating the potential for overfitting or underfitting during fine-tuning.'
 'The solution considers the generalizability of the fine-tuned models to different datasets or tasks.'
 'The solution shows a nuanced understanding of the interplay between dataset quality, fine-tuning, and model performance.']","To critically evaluate the fine-tuning process and identify potential limitations and areas for improvement, we will analyze the fine-tuned models and the dataset used for fine-tuning.

First, we will examine the dataset for instances where the same ""question"" appears with different ""cypher"" outputs. This is crucial because if such instances are split between the training and test sets, a fine-tuned model could memorize the ""cypher"" output for a question during training and then appear to perform well on the same question in the test set, even if the generated ""cypher"" output is incorrect. To address this, we plan to clean the test set by removing or adjusting such instances and re-evaluate the fine-tuned models to assess any performance differences.

Next, we will consider the potential for artificially inflated performance due to training on paraphrased examples of the test set. Since our dataset is constructed by combining publicly available datasets, it may include paraphrased versions of the same questions. Training on these paraphrased examples can make the fine-tuned model appear more effective than it actually is. We will analyze the dataset to identify paraphrased questions and assess their impact on the model's performance.

We will also investigate the risk of data distribution shifts and their potential impact on model performance. The training and test sets are drawn from the same data distribution, and if this distribution shifts in the future, the results may not hold up. To mitigate this, we will analyze the dataset to understand its distribution and consider strategies for adapting to potential shifts, such as continuous data updating or domain adaptation techniques.

Another critical aspect is the risk that foundational models may gain access to both the training and test sets over time, potentially achieving similar or better performance results in the future. To address this, we will consider creating new, independent test sets or using techniques like data perturbation to continuously challenge the models.

Furthermore, we will evaluate the potential for overfitting or underfitting during fine-tuning. This involves analyzing the fine-tuning process and the models' performance on both the training and test sets to identify any signs of overfitting or underfitting. Adjustments to the fine-tuning process, such as regularization techniques or early stopping, may be necessary to optimize performance.

In addition to these analyses, we will assess the generalizability of the fine-tuned models to different datasets or tasks. This will involve testing the models on external datasets or tasks related to Text2Cypher to evaluate their robustness and adaptability.

Our analysis will be transparent and reproducible, with clear documentation of the methods used and the results obtained. We will also plan for future work to refine the dataset further, analyze challenging cases, and explore the effects of model size and prompt engineering on performance.

By addressing these challenges and limitations, we aim to provide a comprehensive understanding of the fine-tuning process and identify areas for improvement, ultimately enhancing the performance and reliability of Text2Cypher models.

The steps involved in our research plan include:
1. Analyzing the dataset for instances with the same ""question"" but different ""cypher"" outputs and cleaning the test set accordingly.
2. Investigating the impact of paraphrased questions in the training data on model performance.
3. Assessing the risk of data distribution shifts and planning strategies to adapt to such shifts.
4. Evaluating the potential for overfitting or underfitting during fine-tuning and adjusting the fine-tuning process as needed.
5. Testing the generalizability of the fine-tuned models to different datasets or tasks.
6. Documenting the analysis and results transparently and reproducibly.
7. Planning future work to refine the dataset and explore model size and prompt engineering effects.

These steps will help us understand the limitations of the current dataset and fine-tuning process, improve the performance and reliability of Text2Cypher models, and demonstrate an awareness of the need for ongoing evaluation and improvement.",050df3b5a8b08d31,726ae3a34e60a262,cs,cs.LG,2412.10064
"Design a goal sampling strategy for an autonomous ego vehicle (EV) to determine the target longitudinal and lateral goal positions for multiple free-end homotopic trajectories in a receding horizon planning manner. The strategy should account for the current state vector of the EV, state limits, and future motion of surrounding human-driven vehicles (HVs) to facilitate driving consistency and safety. The EV operates in dense traffic scenarios with HVs exhibiting multi-modal behaviors, and the planning problem is complicated by the need to balance task accuracy with interaction safety.","['The goal sampling strategy must consider the current state vector of the EV.'
 'The approach should account for the state limits of the EV.'
 'The strategy should incorporate the future motion of surrounding HVs.'
 'The method should facilitate driving consistency in dense traffic scenarios.'
 'The approach must ensure safety during interactions with surrounding HVs.'
 'The strategy should balance task accuracy with interaction safety.'
 'The method should be capable of handling multi-modal behaviors of HVs.'
 'The method should be robust to uncertainties in the motion of surrounding HVs.'
 'The method should ensure that the sampled goal positions are safe and feasible.'
 'The approach should be designed to work in a receding horizon planning framework.']","To address the given research scenario, we design a goal sampling strategy for an autonomous ego vehicle (EV) to determine target longitudinal and lateral goal positions for multiple free-end homotopic trajectories in a receding horizon planning manner. The strategy accounts for the current state vector of the EV, state limits, and future motion of surrounding human-driven vehicles (HVs) to facilitate driving consistency and safety.

First, we parameterize each trajectory using Bézier curves, which facilitates continuous differentiable and optimized trajectories for the EV. The Bézier curve representation is given by $C^{(j)}(\nu) = \sum_{i=0}^{n} B_{i,n}(\nu)P_{i}^{(j)}$, where $P_{i}^{(j)} \in R^{m}$ represents control points or Bézier coefficients to be optimized for the j-th trajectory.

To ensure safety interactions between the EV and surrounding HVs, we develop a spatiotemporal control barrier that enables proactive collision avoidance. The safety constraints are formulated as $d_{k}^{(i)} \geq 1$, where $d_{k}^{(i)}$ is a scaling factor influencing the size of the safety region associated with the i-th surrounding HV at time instant k. We further formulate a barrier function $h(x_{k}, O_{k}^{(i)}) = d_{k}^{(i)} - 1$ and a BF constraint $\Delta h(x_{k}, O_{k}^{(i)}) + \alpha_{k}h(x_{k-1}, O_{k-1}^{(i)}) > 0$ to facilitate proactively collision avoidance.

The task-oriented motion for autonomous driving is achieved by enforcing the final longitudinal position $p_{x,N}^{(j)}$ and lateral position $p_{y,N}^{(j)}$ of each trajectory to align with target sampling points. The target lateral goal vector $P_{y,g}$ is updated based on the last optimal trajectory and maneuver as $P_{y,g} = p_{y,g}^{*} + \delta y$, where $\delta y$ is a maneuver adjustment vector. The target longitudinal goal position vector $P_{x,g}$ is determined based on reachability analysis, task accuracy, and interaction safety between the EV and HVs.

To generate parallel free-end homotopic trajectories, we reformulate the initial NLP into a bi-convex optimization problem. The bi-convex optimization problem is solved using the over-relaxed ADMM algorithm by introducing slack vectors $Z_{x}$ and $Z_{y}$ and applying an infinite penalty to their negative components. The associated dual variables are updated in parallel to accelerate the computation speed.

The BPHTO approach is validated through various cruise control driving tasks using both real-world and synthetic datasets. The results demonstrate improved task accuracy, driving stability, and consistency. The EV can adjust its driving lane while maintaining a stable cruise speed and respond to abrupt cut-in by HVs with safety recovery capabilities.

The computational efficiency of the BPHTO framework is evaluated by manipulating the number of free-end homotopic trajectories $N_{c}$ and the nearest M HVs considered in cruise tasks. The average optimization time increases linearly with respect to the number of homotopic candidate trajectories. The average computation time of BPHTO is less than 100 ms with the prediction length $N = 50$, indicating real-time performance.

The decision-making process illustrates the evolution of the target lane during the cruise, showcasing enhanced driving consistency achieved by BPHTO. The target lane is updated based on the optimal trajectory and maneuver, ensuring driving consistency and safety.

In summary, the proposed goal sampling strategy for BPHTO addresses the research scenario by considering the current state vector of the EV, state limits, and future motion of surrounding HVs. The approach facilitates driving consistency and safety in dense traffic scenarios while balancing task accuracy with interaction safety. The method is capable of handling multi-modal behaviors of HVs and provides a warm initialization strategy for determining maneuver homotopy. The strategy enables the EV to adjust its driving lane while maintaining a stable cruise speed and is robust to uncertainties in the motion of surrounding HVs.",3b083d3a61d48c0d,4a0a1b38289a07d7,cs,cs.RO,2402.10441
"You are a researcher working on a continual learning project using pre-trained transformers. Your goal is to develop a method that can learn a sequence of tasks without suffering from catastrophic forgetting. You have been exploring various approaches, including prompt-based methods, but are concerned about their limitations. You want to investigate alternative methods that can leverage the knowledge gained from pre-trained models while adapting to new tasks. Propose a novel continual learning method that can learn task-adaptive representations from pre-trained transformer parameters, minimizing catastrophic forgetting.","['The proposed method should be based on the concept of ""Well-initialized Lottery Ticket Hypothesis"" (WLTH).'
 'The method should involve learning task-adaptive soft-networks or subnetworks from pre-trained transformer parameters.'
 ""The approach should mask the pre-trained network's parameters to minimize catastrophic forgetting.""
 'The method should be applicable to various continual learning scenarios, including Class-Incremental Learning (CIL) and Task-Incremental Learning (TIL).'
 'The proposed method should be theoretically grounded, with a convergence rate analysis for convex-Lipschitz functions.'
 'The approach should be able to handle task-specific fine-tuning and gradient-based task identification.'
 'The method should be flexible and adaptable to different pre-trained models, such as ViT and CLIP.'
 'The proposed method should be able to learn compact task-specific representations.'
 'The approach should minimize inter-task interference via newly designed architectural components.'
 'The method should be able to handle sequential task learning with minimal catastrophic forgetting.']","To address the research scenario, we propose a novel continual learning method based on the concept of ""Well-initialized Lottery Ticket Hypothesis"" (WLTH). The goal is to develop a method that can learn a sequence of tasks without suffering from catastrophic forgetting.

Our proposed method, referred to as Soft-TransFormers (Soft-TF), leverages learnable soft-networks to train sequential tasks while keeping the well-pre-trained model parameters fixed. The Soft-TF consists of a conventional neural network, like a multilayer transformer with multihead attention and forward networks. Using well-trained transformer parameters, we discover task-specific soft-networks.

The Soft-TF incrementally learns model weights and task-adaptive soft-masks with well-pre-trained and soft-network parameters m. Given a pre-trained parameter θ and learnable soft-parameters m, Soft-ViT is represented as f θ⊙m , consisting of N consecutive soft-MSA layers. The input embedding feature of the l ∗ -th learnable soft-MSA layer is denoted as h (l ∗ ) , where l ∗ = 1, 2, . . . , N , and l ∗ can refer to either the G-Prompt layer l g or the E-Prompt layer l e .

To address task-specific fine-tuning of the pre-trained model, such as ViT, we propose a new Soft-TransFormer (Soft-TF). The Soft-TF learns compact task-specific soft-networks or subnetworks from well-pre-trained parameters for each task. The G-prompt g ∈ R L g ×D is a shared parameter for all tasks, attached to the l g -th MSA layer to transform h (l g ) via a prompting function. The E-prompt e = {e t } T t=1 is a set of task-dependent parameters, where e t ∈ R L e ×D has a sequence length of L e and the same embedding dimension D as the G-prompt.

The prompting function f θ⊙m determines how prompts (p) are combined with fine-tuned soft (θ ⊙ m) embedding features. The soft-MSA layer is defined by the equation MSA(h Q , h K , h V ) = Concat(h 1 , · · · , h i , · · · , h n )w O ⊙ m O , where h i = Attention(h Q (w i Q ⊙ m Q ), h K (w i K ⊙ m K ), h V (w i V ⊙ m V )). The learnable soft-networks m are updated to provide task-specific solutions while keeping the pre-trained parameters θ frozen.

The overall process of Soft-TF during training and testing is described in Algorithm 1 and Algorithm 2. We train the two prompts, the task keys, the soft-attention parameters, and the newly-initialized classification head in an end-to-end manner using the loss function min g,e t ,m t ,k t ,ϕ L(f ϕ (f g,e t ,m t (x)), y) + λL match (x, k t ), x ∈ D t .

To analyze the convergence rate of Soft-TF, we focus on the case of convex-Lipschitz functions. We derive an upper bound on the sub-optimality of our solution relative to any vector w ∗ = {g ∗ , e ∗ t , m ∗ t }. The analysis demonstrates that Soft-TF converges to an optimal solution with a rate of O(1/√T).

We evaluate Soft-TF on several benchmark datasets, including 10/20-Split-CIFAR100 and 10-Split-ImageNet-R, against various continual learning baselines in Class-Incremental Learning (CIL) and Task-Incremental Learning (TIL). Our results demonstrate that Soft-TF significantly outperforms all baselines, including L2P and DualPrompt, in both accuracy and forgetting measurements.

The task inference is performed using two methods: Prompt ID and Gradient ID. Prompt ID simply chooses the best-matched task index via argmin t γ(q(x), k t ), while Gradient ID assigns each learned subnetwork m t a weight α t such that t α t = 1 and α t = 1/T > 0 when evaluating all seen tasks.

Our ablation studies reveal that the layer-wise performance of Soft-TF varies depending on the configuration. In L2P-PGP, the best performance is achieved with Soft-TF applied to the lower layers, whereas in DualPrompt, the higher layers yield the best results. The results also demonstrate that task-identity inference using Gradient-ID is crucial for achieving full fine-tuning results in CIL.

In conclusion, our proposed Soft-TF method addresses the challenges of continual learning by leveraging learnable soft-networks and task-adaptive fine-tuning. The approach demonstrates state-of-the-art performance on various benchmark datasets and is theoretically grounded with a convergence rate analysis. Soft-TF is flexible and adaptable to different pre-trained models, such as ViT and CLIP, and can handle sequential task learning with minimal catastrophic forgetting.",b26addf5795b507b,c67a169b34b6eb93,cs,cs.LG,2411.16073
"You are developing a code generation framework that needs to plan API invocation tasks for complex programming problems. The large language model (LLM) used in the framework has not been trained on the specific library APIs, making it challenging to coordinate task planning with the typical usage patterns of these APIs. You have access to a condensed library overview and a small number of code examples that demonstrate the usage of the library. Design an effective task planning approach that leverages the in-context learning capabilities of the LLM.","['The solution leverages the in-context learning capabilities of the LLM for task planning.'
 'The approach utilizes a condensed library overview to inform the task planning process.'
 'The framework uses a small number of planner examples to guide the LLM in planning API invocation subtasks.'
 'The task planning module decomposes complex problems into simpler API invocation subtasks.'
 ""The approach is designed to handle cases where the library is absent from the model's training data.""
 ""The framework's task planning approach is adaptable to different libraries and APIs.""
 'The solution generates a series of simple API invocation subtasks based on the library overview and examples.'
 'The approach ensures that the subtasks are feasible with the available APIs.'
 ""The task planning module is designed to work with the LLM's limitations and capabilities.""
 'The approach is well-suited for handling complex programming problems involving multiple APIs.']","To address the given research scenario, we propose a research plan that leverages the ExploraCoder framework to empower large language models (LLMs) to generate code that invokes multiple unseen APIs for complex programming problems. The plan is structured around the key components of ExploraCoder: task planning, API recommendation, and chain of API exploration.

1. **Task Planning**: We start by planning the complex programming problem into simpler API invocation subtasks. To achieve this, we utilize the in-context learning capabilities of LLMs by providing a condensed library overview and a small number of planner examples derived from code examples. The LLM, specifically GPT-3.5-turbo-0125, is prompted to summarize the library overview and extract few-shot planners from the provided code examples. This step enables the LLM to understand high-level usage patterns of the library and decompose the complex problem into n API invocation subtasks.

2. **API Recommendation**: For each subtask generated in the task planning phase, we recommend relevant API documents. This involves transforming API documents into a tabular style and using a dense retriever to retrieve an initial subset of APIs based on the similarity between the subtask description and API descriptions. We then prompt the LLM to re-rank and refine the retrieved APIs, ensuring that the most relevant APIs are selected for each subtask. Additionally, we conduct inter-task reranking to recommend a subset of APIs from a global perspective.

3. **Chain of API Exploration (CoAE)**: After preparing the subtasks and recommending relevant APIs, we implement CoAE to explore the correct API usage for each subtask. CoAE involves generating diversified experimental code snippets for each subtask, executing these codes in a sandbox environment, and capturing the execution output. The observed execution experience is then used to select the most valuable experience for each subtask, forming an API exploration trace. This trace serves as a chain-of-thought instruction to guide the LLM in generating the final code solution.

4. **Enhancing CoAE with Self-Debugging**: To further improve the performance of ExploraCoder, we integrate a self-debug mechanism into CoAE. When all candidate codes for a subtask fail to execute, the LLM is prompted to autonomously repair the failed codes, thereby enriching its execution experience.

5. **Evaluation**: We evaluate the performance of ExploraCoder on two benchmarks: Torchdata-Github and Torchdata-Manual. Torchdata-Github consists of 50 programming problems adapted from GitHub client code, each involving 3-8 API invocations. Torchdata-Manual is a newly constructed benchmark comprising 50 manually crafted programming problems, each involving 8-14 distinct Torchdata APIs. We use pass@k and success@k as evaluation metrics to assess the performance of ExploraCoder against baseline approaches.

6. **Comparison with Baseline Approaches**: We compare ExploraCoder with other advanced RAG-based approaches, including DocPrompting, CAPIR, and EpiGen. We also adapt a SOTA debugging framework, Self-Repair, with retrieval augmentation for a fair comparison with ExploraCoder*.

The proposed research plan is designed to address the challenge of generating code that invokes multiple unseen APIs by leveraging the strengths of LLMs in task planning, API recommendation, and exploratory programming. By following this plan, we aim to demonstrate the effectiveness of ExploraCoder in handling complex programming problems involving multiple APIs, without relying on extensive training data for the specific library APIs. The plan is adaptable to different libraries and APIs, making it a versatile solution for library-oriented code generation tasks.",afa3080aa4ca21af,f5cc49b874aa9569,cs,cs.SE,2412.05366
"You are designing a blockchain oracle system that needs to aggregate data from multiple sources while ensuring the reliability and diversity of the data. The system must operate in an environment where data sources may be untrustworthy, and the oracle nodes are required to access data in a way that minimizes resource consumption and response times. Your task is to develop a novel off-chain data aggregation protocol that can guarantee data source diversity and reliability with low resource expenditure. The protocol should be able to work with oracle nodes accessing only one data source. How would you design this protocol, and what features would it include to ensure the desired outcomes?","['The protocol must integrate a mechanism to ensure data source diversity.'
 'The protocol must include a method for oracle nodes to generate non-repudiable proof for the data source.'
 'The protocol should be designed to work with oracle nodes accessing only one data source.'
 'The protocol must verify the diversity of data sources during the aggregation process.'
 'The protocol should minimize resource consumption and response times.'
 'The protocol must be resistant to malicious data sources.'
 'The protocol must ensure the integrity of the data being aggregated.'
 'The protocol should involve a data aggregation phase where nodes verify data and proofs from other nodes.'
 'The protocol should be able to handle cases where oracle nodes fail to verify the submission or detect discrepancies.'
 'The protocol must be designed with security assumptions in mind, such as the majority of nodes and data sources being honest.']","To address the given research scenario, we design a novel off-chain data aggregation protocol for a blockchain oracle system that ensures data source diversity and reliability while minimizing resource consumption and response times. The proposed framework, SEMSO, integrates a new off-chain data aggregation protocol, TBLS, with a data source selection strategy based on a Bayesian game model and reinforcement learning.

### TBLS Protocol

The TBLS protocol is designed to ensure data source diversity and reliability with low resource overhead. It involves three main phases: data request, data aggregation, and data submission and verification.

1. **Data Request Phase**: Oracle nodes select a data source either randomly or strategically based on the task published on the blockchain. They use the TLS-N protocol to communicate with the data source, generating non-repudiable proof for the data source. This proof ensures that the data indeed originates from a specific data source. The node then signs the retrieved data with its private key.

2. **Data Aggregation Phase**: Nodes broadcast the data and its proof to other nodes and verify the data and proofs received from them. The system checks if the group signature from t nodes meets the threshold requirements for successful aggregation and if the associated data source proofs meet the diversity requirement K. This ensures that the final aggregated data is diverse and reliable.

3. **Data Submission and Verification Phase**: Once data aggregation and source diversity validation are successful, a node submits the group signature to the blockchain and broadcasts it. Other nodes verify the submission, and if successful, the task is considered complete. If discrepancies are detected, a data correction request can be initiated, and the incorrect submitter is penalized.

### Data Source Selection Strategy

To maximize the chances of successful aggregation and receiving rewards, oracle nodes must carefully select data sources. The data source selection problem is modeled as a Bayesian game under incomplete information, where nodes aim to select a data source that is most likely to be successfully aggregated.

1. **Bayesian Game Model**: The game is constructed as a quintuple (N, A, Θ, P, U), representing the set of participants (oracle nodes), strategy space (data sources), type set (possible types of nodes based on their advantages), type probability distribution (prior probability of each node's type), and utility function (benefit or utility of each node given its type and strategy selection).

2. **Markov Decision Process (MDP)**: Due to the dynamic nature of the game and incomplete information, the problem is converted into a Partially Observable Markov Decision Process (POMDP) and simplified to an MDP. The MDP is represented as (S, A, T, R, γ), where S is the state (advantage matrix representing node performance across data sources), A is the action (data source selection), T is the state transition function, R is the reward (utility function), and γ is the discount factor.

3. **Double Deep Q-Network (DDQN) Algorithm**: The DDQN algorithm is employed to find the optimal action decision policy π*. It learns the state-action value function Q(s, a) that satisfies the Bellman equation. The algorithm involves initializing main and target Q-networks, selecting actions using an ϵ-greedy policy, storing experiences in a replay buffer, and updating the Q-network parameters using gradient descent.

### Security Assumptions

The security assumptions are that the majority of nodes and data sources are honest. Malicious actors can compromise at most P(D) of the data sources and P(O) of the nodes, where P(D) + P(O) < (N+M)/2, P(D) < M/2, and t < M. This ensures that the system remains secure against collusion between malicious data sources and nodes.

### Experimental and Security Analysis

The proposed solution is implemented using Python 3.9, simulating an oracle network with 50 oracle nodes and 20 data sources. The results show that SEMSO achieves comparable response times to the IoT approach without requiring TEE support or increased on-chain computation and storage costs, while ensuring higher data source diversity. The security analysis verifies that SEMSO guarantees the accuracy of the final aggregated data under the given security assumptions.

By integrating the TBLS protocol with a strategic data source selection mechanism, SEMSO effectively addresses the challenges of ensuring data source diversity and reliability in a blockchain oracle system while minimizing resource consumption and response times.",2c5d941f0242de9e,65e12c3395620b76,cs,cs.CR,2410.12540
"You are tasked with developing a low-light image enhancement model that can effectively handle issues like noise, color distortion, and detail loss. Traditional methods have been inadequate, often resulting in subpar image quality. Your goal is to design a model that can accurately estimate illumination and reflectance components to improve image clarity and color fidelity. The model must be computationally efficient to be suitable for real-time applications on standard consumer hardware. Propose a method to achieve this, considering the limitations of existing techniques and the requirements for a lightweight yet effective solution.","['The proposed method effectively integrates the Retinex theory with modern deep learning techniques.'
 'The method includes a Retinex-based illumination estimator that separates an image into its illumination and reflectance components.'
 'The proposed model is lightweight and suitable for real-time applications on standard consumer hardware.'
 'The method addresses the limitations of traditional low-light image enhancement techniques.'
 'The method includes a clear plan for estimating illumination and reflectance components.'
 'The approach considers the trade-off between computational efficiency and image enhancement quality.'
 'The method is designed to handle complex lighting conditions.'
 'The proposed model is compared to existing techniques, highlighting its advantages.'
 'The approach includes a discussion on how to validate its effectiveness.'
 'The method is free of major conceptual flaws in its application of the Retinex theory.']","To develop a low-light image enhancement model that effectively handles issues like noise, color distortion, and detail loss, we will follow the approach outlined in the DARK model. This involves designing a lightweight computational framework that leverages insights from the Retinex theory and recent advances in image restoration networks.

First, we will implement a Retinex-based illumination estimator to separate an image into its illumination and reflectance components. This estimator will be inspired by the Retinexformer model, which revises the traditional Retinex model to effectively handle image corruptions like noise and color distortion. The illumination estimator will use convolutional layers to extract key features from the input image, generating a light-up map and feature crucial for modeling real-world lighting conditions.

The architecture of the illumination estimator will consist of three principal convolutional layers: an initial 1 × 1 convolution layer to expand the input features, a depthwise convolution layer with a 5 × 5 kernel to process each channel independently, and another 1 × 1 convolution layer to reduce the dimensionality of the feature space. This design will enable the estimator to accurately estimate illumination while minimizing computational complexity.

Next, we will develop a Simplified Residual Contextual Block (SRCB) to enhance feature maps with context-sensitive information. The SRCB will incorporate a Simplified Context Block (SCB) and a convolutional body. The SCB will efficiently model contextual information within feature maps by computing a context mask, reshaping and normalizing it using a softmax function, and applying it to the original input through element-wise multiplication and summation.

We will also utilize a Selective Kernel Feature Fusion (SKFF) module to perform aggregation based on self-attention. The SKFF module will operate on features from different resolution streams, enabling the model to emphasize informative features while suppressing less useful ones. This will be achieved through adaptive average pooling, dimensionality reduction, and fully connected layers to generate attention maps.

The overall architecture of the DARK model will be designed to be lightweight and computationally efficient, making it suitable for real-time applications on standard consumer hardware. The model will comprise an input and output of 3 channels each, processing RGB images with 80 base features scaled by a factor of 1.5. The total number of parameters will be approximately 187,123, significantly fewer than other models in the field.

To train the model, we will employ a combination of weighted loss functions, including L1, MSE, PSNR, and Charbonnier loss. The DataLoader will be configured to shuffle data and utilize a batch size of 4, with progressive training employed to handle larger image patches. The Adam optimizer will be used with an initial learning rate of 2e-4, and a cosine annealing strategy will be applied to decrease the learning rate to 1e-6 over 100,000 iterations.

The performance of the DARK model will be evaluated using Peak Signal-to-Noise Ratio (PSNR) and Structural Similarity Index Measure (SSIM) metrics. These metrics will provide insights into the technical and perceptual effectiveness of the low-light enhancement model, ensuring that it meets both objective and subjective quality standards.

By following this approach, we aim to develop a low-light image enhancement model that effectively addresses the limitations of traditional techniques, improves image clarity and color fidelity, and is computationally efficient for real-time applications on standard consumer hardware.",d85108380ad7b5f0,a9a94674c46447d9,cs,cs.CV,2405.12891
"You are a researcher working on a project to improve the cybersecurity testing of vehicle systems. One of the challenges you face is the limited availability of world-class vehicle penetration testers, who are often constrained by their physical location. You need to devise a method that enables remote penetration testing specialists to collaborate with local test engineers to perform tests that require hands-on support. Describe a novel approach that facilitates this collaboration and enables effective penetration testing.","['The proposed approach enables remote penetration testing specialists to access the test bed and control hardware remotely.'
 'The approach allows for collaboration between remote specialists and local test engineers through a shared platform.'
 'The platform provides a secure environment for remote access, with features such as user authentication and access control.'
 'The approach enables the remote specialist to focus on their testing strategies while the local test engineer handles hardware setup and physical controls.'
 'The platform allows for the integration of software-defined radios and other specialized hardware for penetration testing.'
 'The approach enables the capture and analysis of communication between devices, such as between a key fob and a vehicle.'
 'The platform provides a user-friendly interface for remote specialists to script and execute tests, as well as check on test status.'
 'The platform allows for the deployment of custom scripts and tools for penetration testing.'
 'The platform is designed to reduce the logistical challenges associated with penetration testing, such as travel and hardware setup.'
 ""The platform's security features ensure the confidentiality and integrity of test data and results.""]","To address the challenge of enabling remote penetration testing specialists to collaborate with local test engineers for vehicle cybersecurity testing, we propose a novel approach using the Vehicle Security Engineering Cloud (VSEC) Test platform. This platform is designed to facilitate remote access to test beds, allowing multiple users to collaborate on the same project simultaneously.

First, we establish a web-based remote access interface through VSEC Test, which enables users to register and connect hardware test benches or vehicles to the cloud. Authorized users can schedule benches, access available interfaces via a Linux terminal, and control multiple power sources to individual configured targets. The platform ensures user access control and configuration via lab orchestration software.

To support various testing methodologies, we set up a configurable test bed with ECUs sourced from real vehicles, engineering samples, or off-the-shelf automotive-grade microcontrollers. The test bed includes a configurable CAN bus network system that supports multiple bus speeds and OEMs, with the ability to switch on/off the power of each ECU on-demand via VSEC Test. We achieve this by attaching the power supply of each ECU to a 16-port relay board controlled by an Arduino Due MCU, which is commanded by a script on the tester PC.

For research testing, we enhance the test bed functionality by including an automotive-grade MCU to launch attacks or implement defenses. This allows researchers to rapidly establish and experiment with numerous ECU networks, fine-tuning attacks or defenses in a realistic environment.

The VSEC Test platform enables ""Partner Pentesting,"" where a remote penetration testing specialist collaborates with a local test engineer to perform tests that require hands-on support. The remote specialist can access the test bed, control hardware remotely, and script and execute tests from VSEC Test, while the local test engineer handles physical interactions with the component.

To demonstrate the effectiveness of Partner Pentesting, we set up a scenario where a remote wireless penetration testing specialist works with a local test engineer to control a software-defined radio connected to the cloud. They capture communication between the key fob and the car, study and decode the traffic, create scripts to attack the communication, and validate findings together.

The platform also supports the deployment of custom scripts and tools for penetration testing, and it includes a test management system for tracking test results and scheduling tests. This allows remote specialists to work on multiple projects simultaneously, improving efficiency and reducing logistical challenges associated with penetration testing.

By providing a secure, user-friendly, and configurable remote testing platform, we enable the automotive cybersecurity industry to access a larger pool of talent for testing, reduce costs, and increase participation in global hacking competitions and Bug Bounty programs. The VSEC Test platform is designed to be flexible and adaptable to different penetration testing scenarios, ensuring the confidentiality and integrity of test data and results.

The key features of our approach include:
- Managed remote access to test beds via a web interface
- Configurable test beds with multiple ECUs from different OEMs
- Support for various testing methodologies, including penetration testing and research testing
- ""Partner Pentesting"" for collaboration between remote specialists and local test engineers
- Deployment of custom scripts and tools for penetration testing
- Test management system for tracking test results and scheduling tests

By implementing these features, the VSEC Test platform addresses the challenges faced by the automotive cybersecurity industry in terms of limited access to world-class vehicle penetration testers and the need for more efficient and widespread cybersecurity testing.",661a194c46547a7a,c9ddb4eabf34ed38,cs,cs.CR,2404.02291
"You are developing a visual odometry system using a panoramic camera with multiple synchronized surround-view cameras. However, each camera has a limited horizontal FOV and a low frame rate, resulting in limited overlap between consecutive frames from the same view. This limited overlap leads to insufficient information for constructing constraints, which in turn affects the accuracy of pose estimation. How would you address this issue and improve the accuracy of pose estimation using the available information from the panoramic camera?","['The proposed solution must address the issue of limited overlap between consecutive frames from the same view.'
 'The solution should utilize the views from different historical moments to construct constraints with the current moment.'
 'The solution must be able to handle the 360-degree FOV panoramic images.'
 'The solution should be able to construct constraints between different views at the same moment.'
 'The solution must take into account the limited horizontal FOV of each camera.'
 'The solution should be able to handle the low frame rate of the cameras.'
 'The solution must be able to utilize the available information from the panoramic camera.'
 'The solution should be able to handle varying lighting conditions.'
 'The solution should be able to handle motion blur and insufficient texture.'
 'The solution should be able to utilize the information from multiple cameras.']","To address the issue of limited overlap between consecutive frames from the same view in a visual odometry system using a panoramic camera with multiple synchronized surround-view cameras, we propose a panoramic direct LiDAR-assisted visual odometry system. The system is designed to fully associate 360-degree FOV LiDAR points with 360-degree FOV panoramic image data, thereby enhancing the robustness and accuracy of pose estimation.

The proposed system consists of five main modules: data association, direct pose estimation utilizing multiple cameras, new keypoint extraction, bundle adjustment utilizing multiple cameras, and transform integration. 

1. **Data Association Module**: This module assigns sparse depth observations from LiDAR to image pixels. The implementation is the same as in our previous work, SDV-LOAM.

2. **Direct Pose Estimation Utilizing Multiple Cameras**: When the current frame arrives, we track it with respect to the newest keyframe by projecting extracted keypoints of the keyframe to the current frame and calculating the photometric error between them. Unlike monocular camera frames, each panoramic frame consists of five surround-view images with limited horizontal resolutions. To prevent the issue of insufficient available information due to minimal overlap between the current frame and the latest keyframe from the same view, we allow images from different views to construct photometric errors. The pose of the current body frame relative to the latest body keyframe is estimated, while other pose variables are expressed as a function of this pose and camera extrinsic parameters.

3. **Bundle Adjustment Utilizing Multiple Cameras**: Sliding window-based bundle adjustment is used to refine the poses of keyframes to reduce accumulative errors in pose estimation. Given that bundle adjustment involves more frames than direct pose estimation, we only consider constraints between images of keyframes from the same view to avoid high computation overhead.

4. **New Keypoint Extraction and Transform Integration Modules**: These modules are the same as in the monocular DSO system.

The proposed system addresses the issue of limited overlap between consecutive frames from the same view by utilizing images from different views to construct constraints. This approach takes full advantage of the available information from the panoramic camera, thereby improving the accuracy and robustness of pose estimation.

The system is evaluated on two public datasets, nclt and ijrr, which consist of challenging outdoor and indoor environments with varying lighting conditions, motion blur, and insufficient texture. Experimental results demonstrate that the proposed panoramic direct LiDAR-assisted visual odometry system outperforms state-of-the-art approaches, including LIMO, PAN-SLAM, and SDV-LOAM, on most segments of the selected sequences.

The ablation study demonstrates the significant improvement of utilizing panoramic FOV for LiDAR-assisted VO and the effectiveness of constructing constraints between different views.

By utilizing the information from multiple cameras and constructing constraints between different views at the same moment, the proposed system is able to reduce the impact of limited overlap on pose estimation and provide robust and accurate pose estimation in challenging environments.

The overall performance of the visual odometry system is improved by integrating panoramic camera with 3D LiDAR and utilizing the available information from the panoramic camera.",f7d2820e90ec251a,5fc7abadcaa9f131,cs,cs.RO,2409.09287
"You are developing a GWAP that collects annotations for linguistic bias detection. However, you face the ""cold start problem"" for new sentences without established ground truth. You need to devise a strategy to provide feedback to players for these sentences and keep them engaged. How would you address this challenge and ensure continuous data collection?","['The solution involves using delayed feedback for sentences without established ground truth.'
 'Players receive notifications when the ground truth is established for sentences they annotated.'
 'The delayed feedback mechanism includes higher rewards when players match the eventually established ground truth.'
 'The solution aims to incentivize players to return and collect rewards, promoting recurring interaction.'
 'The solution ensures continuous data collection by keeping players engaged.'
 'The game mechanics are designed to handle the uncertainty of annotations for new sentences.'
 'The solution involves accumulating annotations from multiple players to establish ground truth.'
 'The game provides a mechanism for players to revisit and collect feedback on previously annotated sentences.'
 'The delayed feedback mechanism is designed to promote extrinsic motivation through unpredictability.'
 'The game mechanics ensure that players are motivated to annotate new sentences.']","To address the ""cold start problem"" for new sentences without established ground truth in the GWAP for linguistic bias detection, we employ a delayed feedback mechanism. This approach is designed to provide feedback to players for these sentences and keep them engaged, ensuring continuous data collection.

The game, News Ninja, utilizes two types of feedback: direct feedback and delayed feedback. Direct feedback is used when the ground truth of a sentence or word is known, which occurs when the sentence originates from the baseline dataset BABE or has at least five annotations by players that determine labels via majority vote. Successful matches to the ground truth are rewarded with a green card outline, currency, skill, experience points, and sound effects.

For sentences without established ground truth, News Ninja employs delayed feedback. This is visualized through yellow visual cues indicating that players can revisit the game at a future point when sufficient data is available. The card outline turns yellow for delayed sentence-level feedback, and a yellow dash icon appears. On the word level, selected word cards turn yellow. The sentence then moves to the Paper section, where players can later collect feedback.

When a ground truth is eventually established for sentences with prior delayed feedback, players receive push notifications and see a yellow dot as a signifier on the navigation bar on the Paper section icon. If players correctly annotated the sentence, they receive a higher reward upon collecting the feedback. This mechanism incentivizes players to return and collect rewards, promoting recurring interaction and sustaining player engagement.

The game accumulates annotations from multiple players to establish ground truth. A sentence or word receives a bias label based on a majority vote. For word-level annotations, a word receives a bias label if identified as such by a minimum of two players or by 25% of the players who encountered the sentence. This threshold is set low due to the challenges of identifying bias at the word level and the lower agreement reported in prior research.

News Ninja's design includes various motivational game elements to sustain player engagement. Players can buy new topics in the shop with in-game currency, and collecting experience points allows them to progress through levels and unlock new game modes. The game also features a Progress bar on the home screen, visualizing players' skill levels to increase intrinsic motivation. The Breaking News tile refreshes daily, offering higher rewards on daily completion and encouraging consecutive play streaks.

To further enhance player engagement and data quality, the game includes a discussion feature where players can discuss bias annotations of sentences with other players. This fosters reflection and motivation through social interactions.

The solution is scalable and can handle a large volume of new sentences. By leveraging crowdsourced players over experts, News Ninja mitigates the risk of dataset obsolescence by periodically updating contents to capture changes in news, context, and perception over time.

To ensure a diverse and balanced dataset, News Ninja queries demographic metrics, such as political leanings, and includes data from players exhibiting unique annotation patterns or perspectives. A more sophisticated latent class model can be applied to account for the noisy data caused by individual biases.

The next steps in the research plan include studying learning effects by conducting tests pre- and post-gameplay, comprehensively evaluating player experience, fun, and motivation, launching an online version of the game to measure unpaid player interactions, and applying a more sophisticated latent class model to create labels.

By implementing these strategies, News Ninja addresses the ""cold start problem"" and ensures continuous data collection while maintaining player engagement.",47d4c46466ea9224,ab1266420eba0cc5,cs,cs.HC,2407.17111
"You have generated pseudo-samples using both paraphrasing and generating approaches for a Relation Extraction (RE) task in the scientific domain. You want to combine these pseudo-samples with the original training data to fine-tune your RE model. However, you are concerned that combining both types of pseudo-samples may not always lead to improved performance. Investigate the potential effects of combining both types of pseudo-samples on the performance of the RE model and speculate on the reasons for any observed degradation in performance.","['The investigation should evaluate the performance of the RE model using a suitable metric such as F1 score.'
 'The investigation should compare the performance of the RE model with and without the combined pseudo-samples.'
 'The speculation should consider the potential introduction of noisy entities and relations in the generated pseudo-samples.'
 'The investigation should analyze the quality of the generated pseudo-samples and their relevance to the RE task.'
 'The speculation should discuss the potential impact of the quality of the pseudo-samples on the performance of the RE model.'
 'The speculation should consider alternative explanations for any observed degradation in performance.'
 'The investigation should discuss the implications of the findings for future work on data augmentation for RE tasks.'
 'The investigation should analyze the results in the context of the scientific domain and its specific challenges.'
 ""The speculation should discuss the potential impact of the LLM's understanding of the scientific domain on the quality of the pseudo-samples.""
 'The investigation should provide recommendations for future work on improving the quality of generated pseudo-samples.']","To investigate the potential effects of combining both types of pseudo-samples on the performance of the RE model and speculate on the reasons for any observed degradation in performance, we will follow the research plan outlined below.

First, we will utilize the PGA framework, which has been proposed for enhancing RE in scientific domains. The PGA framework uses GPT-3.5 to synthesize paraphrased and generated pseudo-samples. We will combine both types of pseudo-samples with the original training data to fine-tune the RE model.

We will evaluate the performance of the RE model using the F1 score, as well as other metrics such as precision and recall. To do this, we will use the SciERC dataset, which collects 500 abstracts of AI papers and labels them with relation and entity information. The performance of the RE model will be compared with and without the combined pseudo-samples.

To analyze the quality of the generated pseudo-samples and their relevance to the RE task, we will remove the original dataset and use only the pseudo-samples alone to fine-tune each backbone model. We will then compare the performance of the RE model with the paraphrased and generated pseudo-samples.

To investigate the impact of the size of the combined dataset on the performance of the RE model, we will vary the number of pseudo-samples involved in training and evaluate the performance of the RE model. We will also analyze the distribution of the embeddings of the pseudo-samples and the sentences of the original dataset in the vector space to measure the fidelity of the pseudo-samples.

Furthermore, we will speculate on the potential introduction of noisy entities and relations in the generated pseudo-samples and discuss the potential impact of the quality of the pseudo-samples on the performance of the RE model. We will also consider alternative explanations for any observed degradation in performance.

The results will be analyzed in the context of the scientific domain and its specific challenges. We will discuss the implications of the findings for future work on data augmentation for RE tasks and provide recommendations for improving the quality of generated pseudo-samples.

To achieve this, we will follow these steps:
1. Combine both paraphrased and generated pseudo-samples with the original training data.
2. Fine-tune the RE model using the combined dataset.
3. Evaluate the performance of the RE model using F1 score, precision, and recall.
4. Compare the performance of the RE model with and without the combined pseudo-samples.
5. Analyze the quality of the generated pseudo-samples by removing the original dataset and using only the pseudo-samples alone to fine-tune each backbone model.
6. Vary the number of pseudo-samples involved in training and evaluate the performance of the RE model.
7. Measure the fidelity of the pseudo-samples by analyzing the distribution of their embeddings in the vector space.
8. Speculate on the potential introduction of noisy entities and relations in the generated pseudo-samples and discuss the potential impact of the quality of the pseudo-samples on the performance of the RE model.

By following this research plan, we aim to provide a comprehensive understanding of the effects of combining both types of pseudo-samples on the performance of the RE model and to identify potential areas for improvement in data augmentation for RE tasks.",516b4faf8cab0c8a,53d5332f85e747d2,cs,cs.CL,2405.20787
"You are tasked with designing a novel Federated Learning (FL) framework that protects data privacy by preventing Gradient Inversion Attacks (GIA). The framework should enable clients to collectively train machine learning models without sharing their raw data, while also ensuring that the shared parameters do not directly expose local private data. Your goal is to propose a framework that achieves a favorable privacy-utility trade-off without relying on existing defense mechanisms like Secure Multi-party Computing (SMC), Homomorphic Encryption (HE), or Differential Privacy (DP). The framework should be flexible and scalable to cater to diverse FL demands.","['The proposed FL framework should effectively ""break the direct connection"" between the shared parameters and the local private data.'
 'The framework should utilize hypernetworks to generate the parameters of the local model.'
 'Only the hypernetwork parameters should be shared with the server for aggregation.'
 'The local model should be decoupled into a shared feature extractor and a private classifier.'
 'The hypernetwork should generate the feature extractor parameters based on private client embeddings.'
 'The framework should be flexible and scalable to cater to diverse FL demands.'
 'The proposed framework should not rely on existing defense mechanisms like SMC, HE, or DP.'
 'The framework should achieve a favorable privacy-utility trade-off.'
 'The client embeddings should be private and not shared with the server.'
 'The classifier should be trained locally and not shared with the server.']","To address the given research scenario, we design a novel Federated Learning (FL) framework that protects data privacy by preventing Gradient Inversion Attacks (GIA). The proposed framework, termed HyperFL, effectively ""breaks the direct connection"" between the shared parameters and the local private data.

1. **Problem Formulation**: 
The FL problem is formalized with $m$ clients and a central server. Each client $i$ has its own data distribution $P_{XY}^{(i)}$ on $X \times Y$, where $X$ is the input space and $Y$ is the label space. The goal is to minimize the global loss function, which is a weighted sum of the local loss functions $L_i(\Theta_i)$, where $\Theta_i$ represents the local model parameters.

2. **Main Configuration HyperFL**:
In HyperFL, each client's classification network is decoupled into a feature extractor $f(; \theta_i)$ and a classifier $g(; \phi_i)$. An auxiliary hypernetwork $h(; \phi_i)$ generates the feature extractor parameters $\theta_i$ based on a private client embedding $v_i$, i.e., $\theta_i = h(v_i; \phi_i)$. The hypernetwork parameters $\phi_i$ are shared with the server for aggregation, while the classifier parameters $\phi_i$ and client embedding $v_i$ are kept local.

3. **Local Training Procedure**:
- **Step 1**: Fix $\phi_i$ and $v_i$, update $\phi_i$ by training the classifier parameters using gradient descent.
- **Step 2**: Fix the new $\phi_i$, update $\phi_i$ and $v_i$ by training the hypernetwork parameters and client embedding for multiple epochs.

4. **Global Aggregation**:
The server performs weighted averaging of the hypernetwork parameters $\phi_i$ to obtain the global $\bar{\phi}$, using weights determined by the local data size.

5. **HyperFL for Large Pre-trained Models (HyperFL-LPM)**:
For complex tasks, HyperFL-LPM uses pre-trained models as fixed feature extractors and generates trainable adapter parameters via a hypernetwork. This configuration is particularly useful for handling large models.

6. **Privacy Protection Analysis**:
The HyperFL framework safeguards data privacy by making it challenging for an attacker to recover private data from the shared hypernetwork parameters. The bi-level optimization problem formulated for an attacker to recover $x$ and $v$ is difficult to solve due to the absence of classifier information and the high dimensionality of the hypernetwork output.

7. **Convergence Analysis**:
Under certain assumptions (smoothness, bounded variance, and bounded gradients), HyperFL achieves an $O(\frac{1}{\sqrt{T}})$ convergence rate towards a stationary solution, comparable to FedAvg. For Polyak-Lojasiewicz functions, HyperFL achieves a faster convergence rate.

8. **Experiments**:
- **Datasets**: Evaluate HyperFL on EMNIST, Fashion-MNIST, CIFAR-10, and CINIC-10 for the Main Configuration, and on EMNIST and CIFAR-10 for HyperFL-LPM.
- **Model Architectures**: Use CNNs for the Main Configuration and pre-trained ViT and ResNet for HyperFL-LPM.
- **Compared Methods**: Compare HyperFL with Local-only, FedAvg, pFedHN, and DP-based FL methods.
- **Training Settings**: Use mini-batch SGD with specific learning rates, batch sizes, and number of local training epochs.
- **Privacy Evaluation**: Assess privacy preservation using IG, ROG, and a tailored attack method.

The proposed HyperFL framework effectively protects data privacy by preventing GIA, achieves a favorable privacy-utility trade-off, and maintains competitive performance compared to existing FL methods. By utilizing hypernetworks to generate local model parameters and sharing only the hypernetwork parameters, HyperFL provides a flexible and scalable solution for diverse FL demands without relying on existing defense mechanisms like SMC, HE, or DP.",3d6bdcee7b7f6bb4,8fdaabce3081e614,cs,cs.LG,2412.07187
"In the context of optimizing the order of test examples in ZS-ICL using MCTS, you are faced with the challenge of effectively estimating the Q values for state-action pairs. The traditional updating method for Q values through simulation and back-propagation is too costly due to the large state space and the need for LLM inference for reward calculation. Your task is to propose a method to initialize the Q values that leverages the contextual information available in the current state and action. Specifically, you need to integrate the information from the pseudo-demonstration set into the Q-value estimation to achieve more accurate initial Q values. The pseudo-demonstration set contains previously solved examples along with their predicted labels and confidence scores. Develop a demonstration-aware Q-value initialization method that enhances the effectiveness and efficiency of MCTS in the ZS-ICL setting.","['The proposed Q-value initialization method integrates information from the pseudo-demonstration set.'
 'The method retrieves a subset of pseudo-demonstrations that are most semantically similar to the next test example to be solved.'
 'The quality of the retrieved pseudo-demonstrations is evaluated based on their confidence scores and similarity to the next test example.'
 'The initial Q value is calculated as an aggregation (e.g., sum or average) of the confidence and similarity scores of the retrieved pseudo-demonstrations.'
 'The demonstration-aware Q-value function is used to enhance the selection phase of MCTS by guiding the choice of the next action.'
 'The demonstration-aware Q-value function is also used to accelerate the expansion and simulation phases of MCTS.'
 'The method avoids relying solely on the costly simulation and back-propagation for Q-value estimation.'
 'The proposed method is designed to be efficient and effective within a limited computational budget.'
 'The Q-value initialization method is tailored to the specifics of the ZS-ICL problem, considering the role of pseudo-demonstrations.'
 'The demonstration-aware Q-value function is integrated into the MCTS algorithm in a way that balances exploration and exploitation.']","To address the challenge of effectively estimating Q values for state-action pairs in the context of optimizing the order of test examples in Zero-Shot In-Context Learning (ZS-ICL) using Monte Carlo Tree Search (MCTS), we propose a demonstration-aware Q-value initialization method. This method integrates the information from the pseudo-demonstration set into the Q-value estimation to achieve more accurate initial Q values.

The proposed method involves several key steps:

1. **Retrieval of Pseudo-Demonstrations**: For a given state and action (i.e., the next test example to be solved), we retrieve a subset of pseudo-demonstrations from the pseudo-demonstration set that are most semantically similar to the next test example. This is done using a semantic similarity model, such as the BGE model, to measure the similarity between the pseudo-demonstrations and the test example.

2. **Evaluation of Pseudo-Demonstrations**: The quality of the retrieved pseudo-demonstrations is evaluated based on two criteria: their confidence scores and their similarity to the next test example. The confidence score of a pseudo-demonstration is derived from the Large Language Model's (LLM) prediction confidence for that example. The similarity score is obtained from the semantic similarity model used in the retrieval step.

3. **Calculation of Initial Q Value**: The initial Q value for a state-action pair is calculated as an aggregation (specifically, an average) of the confidence and similarity scores of the retrieved pseudo-demonstrations. The formula for the initial Q value, $Q_0(s, a)$, is given by:
\[ Q_0(s, a) = \frac{1}{k_d} \sum_{i=1}^{k_d} (C(d_i) + S(d_i, x_{i+1})) \]
where $d_i$ is a retrieved pseudo-demonstration, $C(d_i)$ is its confidence score, $S(d_i, x_{i+1})$ is its similarity score with the next test example $x_{i+1}$, and $k_d$ is the number of retrieved pseudo-demonstrations.

4. **Demonstration-Aware Q-Value Function**: The demonstration-aware Q-value function, $DQ(s, a)$, is then defined as:
\[ DQ(s, a) = Q_0(s, a) + w_Q \cdot Q(s, a) \]
where $Q(s, a)$ is the updated Q value from the MCTS algorithm, and $w_Q$ is a balance constant that weighs the importance of the initial Q value versus the updated Q value.

5. **Integration with MCTS**: The $DQ(s, a)$ function is used to enhance the selection phase of MCTS by guiding the choice of the next action. It is also used to accelerate the expansion and simulation phases. In the selection phase, a modified Upper Confidence bounds applied to Trees (UCT) algorithm, termed $DUCT(s, a)$, is used, which incorporates $DQ(s, a)$:
\[ DUCT(s, a) = DQ(s, a) + w_a \sqrt{\frac{\ln N(s)}{N(c(s, a))}} \]
where $N(s)$ is the number of times state $s$ has been visited, $c(s, a)$ is the child node resulting from taking action $a$ in state $s$, and $w_a$ is a constant that balances exploration and exploitation.

6. **Acceleration of Expansion and Simulation**: During expansion, the top-$k_a$ actions with the highest $DQ(s, a)$ values are selected for further exploration. In the simulation phase, a cache mechanism is employed based on the $DQ(s, a)$ function to avoid redundant computations and accelerate the process.

7. **Calibration-Enhanced Aggregation**: Finally, the predictions from multiple iterations of MCTS are aggregated using a calibration-enhanced method. This involves calculating the average probabilities for each label and selecting the one with the highest calibrated probability as the final answer. Calibration is done by dividing the predicted probability by the prior probability of the label, which is estimated from the LLM's zero-shot predictions on all test examples.

By integrating the information from the pseudo-demonstration set into the Q-value estimation, the proposed demonstration-aware Q-value initialization method enhances the effectiveness and efficiency of MCTS in the ZS-ICL setting. This approach strategically plans the problem-solving trajectory, improving the performance of ZS-ICL without relying on costly simulation and back-propagation for Q-value estimation.",04a6bf162734d2d9,31f864722adc99cf,cs,cs.CL,2410.20215
"You are a researcher aiming to enhance the robustness of deep neural networks against adversarial attacks. You have developed a novel data augmentation method and need to demonstrate its efficacy across various computer vision tasks, neural network architectures, and datasets. Design an experimental setup to test the effectiveness of your method in improving model robustness, particularly against adversarial attacks.","['The experimental setup includes a variety of computer vision tasks.'
 'Multiple neural network architectures are considered in the experiments.'
 'The experiments are conducted across multiple datasets.'
 'The method is evaluated for its impact on model robustness against adversarial attacks.'
 'The experimental setup includes testing against various types of adversarial attacks.'
 'The method is compared against baseline models or existing data augmentation techniques.'
 ""The experiments assess the method's compatibility with different data augmentation strategies.""
 'The evaluation includes metrics relevant to model robustness and performance.'
 'The experimental setup includes a plan for statistical analysis of the results.'
 ""The method's impact on model generalization is assessed.""]","To enhance the robustness of deep neural networks against adversarial attacks using the proposed You Only Need hAlf (YONA) data augmentation method, we will conduct a comprehensive experimental setup. The goal is to demonstrate YONA's efficacy across various computer vision tasks, neural network architectures, and datasets.

First, we will evaluate YONA on image classification tasks using the CIFAR-10 and CIFAR-100 datasets. We will assess its performance with six different neural network architectures: ResNet-18, Xception, DenseNet-121, ResNeXt-50, WRN-28-10, and ViT. For each architecture, we will test YONA with eight data augmentation techniques: Horizontal Flip, Vertical Flip, Color Jitter, Random Erasing, Cutout, Grid, Random Augmentation, and Auto Augmentation. This will involve training models for 300 epochs with an initial learning rate of 0.1, decayed by a factor of 0.1 at epochs 100 and 200, using the SGD optimizer with a momentum of 0.9 and a weight decay of 0.0001.

Next, we will investigate YONA's impact on object detection tasks using the YOLOv7 architecture on the MS-COCO dataset. We will train YOLOv7 from scratch for 300 epochs with a batch size of 16 and an initial learning rate of 0.01, using the Adam optimizer with a momentum of 0.937 and a weight decay of 0.0005. We will evaluate YONA with four data augmentation methods (Horizontal Flip, Color Jitter, Random Erasing, and Random Augmentation) across four metrics: Precision, Recall, mAP@0.5, and mAP@0.5:0.95.

To assess YONA's effectiveness in enhancing model robustness against adversarial attacks, we will conduct experiments using the PGD adversarial attack on the CIFAR-10 and CIFAR-100 datasets with the ResNet-18 architecture. We will train models using PGD adversarial training with epsilon values of 8/255 for L∞ bound and 0.25 (for attacking) or 0.5 (for training) for L2 bound, for 200 epochs with a learning rate schedule.

We will also perform an ablation study to validate the effectiveness of masking half of an image's content within the YONA framework. This will involve evaluating classification accuracy on CIFAR-10 with ResNet-18 using four data augmentations (Horizontal Flip, Color Jitter, Erasing, and Grid) and two different masking rates (1/4 and 3/4).

Furthermore, we will evaluate YONA's impact on calibration, corruption robustness, and contrastive learning. For calibration, we will use the RMS calibration error with a 40-4 Wide ResNet architecture on CIFAR-10 and CIFAR-100. For corruption robustness, we will test image classifiers on corrupted test sets created by replacing the background with a random image and adding Gaussian noise to the background. For contrastive learning, we will apply YONA to Horizontal Flip and pre-train MoCo v2 and SimSiam with YONA for 200 and 100 epochs, respectively, and evaluate the learned embedding on VOC detection, COCO detection, and COCO instance segmentation tasks.

Throughout these experiments, we will compare YONA against baseline models or existing data augmentation techniques and assess its compatibility with different data augmentation strategies. We will also evaluate YONA's efficiency in terms of computational cost and its ease of implementation. The experimental design will control for potential confounding variables, and we will plan for statistical analysis of the results to ensure reproducibility.

By following this comprehensive experimental setup, we aim to thoroughly assess YONA's effectiveness in enhancing the robustness of deep neural networks against adversarial attacks across various computer vision tasks, neural network architectures, and datasets.",7c59b57ee2daedc1,93c85590a6776f21,cs,cs.CV,2405.02830
"You are tasked with designing a coordination mechanism for a complex industrial automation system consisting of multiple electro-mechanical components. The system is subject to frequent reconfigurations and changes in its operational requirements. Your goal is to develop a decentralized and adaptive coordination approach that enables the components to interact with each other seamlessly, without relying on manual re-engineering or hard-coded coordination plans. The system components are controlled by software agents that have access to semantic descriptions of the system's physical processes, control strategies, and component interactions. Propose a novel approach to enable adaptive coordination among the agents, ensuring loose coupling and dynamic adaptation to changing system configurations.","['The proposed approach utilizes hypermedia environments to facilitate agent interactions.'
 'The solution involves agents publishing their profiles and navigating through semantic links to discover potential collaborators.'
 'The approach enables agents to discover affordances offered by other agents to set up and enact coordination dynamically.'
 'The approach ensures loose coupling among agents, allowing for flexibility and adaptability.'
 'The proposed solution can handle dynamic changes in the system configuration without manual re-engineering.'
 'The solution incorporates semantic descriptions of physical processes and component interactions.'
 ""The agents can autonomously determine their coordination needs based on the system's goals and dependencies.""
 'The solution avoids hard-coding coordination plans, allowing for flexibility and adaptability.'
 'The proposed approach is decentralized, allowing for distributed decision-making among agents.'
 'The solution provides a clear mechanism for testing and validating the adaptive coordination approach.']","To develop a decentralized and adaptive coordination approach for a complex industrial automation system, we will utilize a hypermedia environment to facilitate interactions among software agents controlling electro-mechanical components. The system is subject to frequent reconfigurations and changes in operational requirements, necessitating a flexible and dynamic coordination mechanism.

First, we will integrate various ontologies that describe different aspects of the system, including physical processes, control strategies, and component interactions. This integrated system description will enable agents to infer their coordination responsibilities based on the system's goals and dependencies. The ontologies used will include BRICK, OntoCAPE, PhySys, Elementary, CTRLOnt, and GORE, which provide a comprehensive representation of the system's knowledge.

Agents will publish their profiles, which include their coordination responsibilities, goals, and affordances, to a hypermedia environment. These profiles will be described using the Web of Things (WoT) Thing Description (TD) standard, allowing agents to discover and interact with each other's affordances dynamically. The WoT TD will enable agents to expose their interfaces and reveal their affordances in a machine-understandable manner.

To discover potential collaborators, agents will navigate through semantic links in the hypermedia environment. They will search for affordances offered by other agents that can help fulfill their coordination responsibilities. The hypermedia environment will support dynamic updates and notifications of changes, ensuring that agents can adapt to changing system configurations.

Once agents have discovered potential collaborators, they will set up and enact coordination plans dynamically. They will search for coordination protocols created by human experts, which will be made available as Web resources in the hypermedia environment. These protocols will be described using a novel semantic description that embeds knowledge about the physical pre- and post-conditions of interactions.

The coordination protocols will enable agents to communicate with each other in a standardized way, ensuring interoperability and loose coupling among agents. The protocols will also allow agents to reason about the physical processes and component interactions, enabling context-aware coordination plans that can be applied across different domains.

The proposed approach is decentralized, allowing for distributed decision-making among agents. It avoids hard-coding coordination plans, enabling flexibility and adaptability in the face of changing system configurations and operational requirements. The use of standardized technologies and protocols, such as WoT TD, ensures interoperability among agents and components.

To validate the adaptive coordination approach, we will test it in a simulated environment, such as a chilled water production system. We will evaluate the ability of agents to discover and interact with each other's affordances, set up and enact coordination plans dynamically, and adapt to changing system configurations.

The proposed research plan addresses the challenges of developing a decentralized and adaptive coordination approach for complex industrial automation systems. By utilizing hypermedia environments, integrating various ontologies, and enabling agents to discover and interact with each other's affordances, we can create a flexible and dynamic coordination mechanism that can handle uncertainties and changes in the system's operational requirements.

The key steps in the research plan are:
1. Integrate various ontologies to describe the system knowledge.
2. Enable agents to infer their coordination responsibilities based on the system's goals and dependencies.
3. Use WoT TD to describe agent profiles and affordances.
4. Implement a hypermedia environment to facilitate agent interactions.
5. Develop a mechanism for agents to discover potential collaborators and set up coordination plans dynamically.
6. Create coordination protocols with embedded knowledge about physical pre- and post-conditions.
7. Test and validate the adaptive coordination approach in a simulated environment.

By following this research plan, we can develop a novel decentralized and adaptive coordination approach that meets the needs of complex industrial automation systems.",0e372874e7bd8606,4f452395f62d3474,cs,cs.MA,2406.17816
"You are tasked with developing a reinforcement learning (RL) algorithm for a robotic reaching task using a Baxter robot. The task involves controlling the robot's right arm to reach a goal area as quickly as possible. The state space is continuous and six-dimensional, representing the position of the robot's right tip in 3D space and the angular positions of three joints. The action space is also continuous and three-dimensional, representing the changes in the angular positions of the three controlled joints. The reward function is designed to encourage the robot to reach the goal area quickly. However, the sparse reward signal makes it challenging for the RL agent to learn an effective policy. You need to propose a method to accelerate the learning process of the RL agent by incorporating a potential-based reward shaping (PBRS) framework. The challenge is to adapt the PBRS framework to the continuous state space. How would you modify the PBRS framework to make it suitable for this task?","['The proposed method should involve a state mapping function to project the continuous state space to a discrete potential state space.'
 'The state mapping function should simplify the representation of states, making it possible to count and distinguish good and bad states.'
 'The discrete potential state space should be lower-dimensional than the original continuous state space.'
 'The method should be able to capture the underlying structure of the task and provide a useful shaping reward to guide the RL agent.'
 'The state mapping function should be designed such that it does not lose critical information about the task.'
 ""The discrete potential states should be defined based on the task requirements, such as the position of the robot's right tip.""
 'The method should not require significant additional computational resources or complex additional machinery.'
 'The state mapping function should be able to handle the continuous nature of the state space.'
 'The proposed method should not assume prior knowledge of the task or the environment beyond what is provided.'
 'The method should be able to learn the potential function concurrently with the training of the RL agent.']","To address the given research scenario, we will develop a reinforcement learning (RL) algorithm for a robotic reaching task using a Baxter robot. The task involves controlling the robot's right arm to reach a goal area as quickly as possible. The state space is continuous and six-dimensional, representing the position of the robot's right tip in 3D space and the angular positions of three joints. The action space is also continuous and three-dimensional, representing the changes in the angular positions of the three controlled joints.

The proposed method involves incorporating a potential-based reward shaping (PBRS) framework to accelerate the learning process of the RL agent. To adapt the PBRS framework to the continuous state space, we define a state mapping function $Z : S \rightarrow S_p$ to project the continuous six-dimensional state space $S$ to a discrete three-dimensional state space $S_p$. Each mapped state $s_p \in S_p$ is defined as the rounded position of the robot's right tip $s_p = (\lfloor x_{tip} \rfloor, \lfloor y_{tip} \rfloor, \lfloor z_{tip} \rfloor)$, where the floor operator $\lfloor \cdot \rfloor$ rounds Baxter's tip position to a discrete space by a scale of 0.1 meter.

The state mapping function simplifies the representation of states from six-dimensional vectors to three-dimensional vectors for two reasons: (i) Learning the adaptive potential function (APF) needs the operation of counting states, but counting continuous states is not meaningful as most of them will only occur once. (ii) As the goal state does not require specific angles of the controlled joints, discrete position information of the right tip is enough for building a potential space to guide the agent in a high-level direction.

We employ the Deep Deterministic Policy Gradient (DDPG) algorithm as the underlying RL algorithm because it is designed for environments with continuous action spaces. The APF is learned concurrently with the training of the DDPG networks. The APF network is updated every episode, while the four DDPG networks (critic, target critic, actor, and target actor) are updated every time step.

The APF network takes a state as input and outputs the potential value of that state. To generate the potential value, we define a neural network with parameter $\phi$ to approximate the APF $\Phi$. During training, the agent records the sequence of all potential states visited in each episode in a trajectory $t_i = (s_{p1}, s_{p2}, ...)$. We store trajectories in a priority queue, ordered by the corresponding episodic reward $R_{ei}$ of each trajectory $t_i$. The first 50% trajectories are defined as good trajectories, and the other 50% are bad trajectories.

After each episode, a set of half-batch-size good trajectories ($T_g$) and a set of half-batch-size bad trajectories ($T_b$) are randomly sampled. For each state $s_p$ appeared in $T_g$ and $T_b$, we define its occurrence in $T_g$ as $N_g[s_p]$ and its occurrence in $T_b$ as $N_b[s_p]$, respectively. The APF network is updated by minimizing the loss function $L_\phi = E[(\Phi(s_p; \phi) - \frac{N_g[s_p] - N_b[s_p]}{N_g[s_p] + N_b[s_p]})^2]$.

The APF-DDPG algorithm incorporates the APF into the DDPG algorithm. When the APF-DDPG agent takes an action $a$ at state $s$ and is transferred to the next state $s'$, the environment returns a reward $r$, and the APF network returns a shaping reward $f = \gamma\Phi(s'_p) - \Phi(s_p)$. The agent collects the shaped reward $r' = r + f$ into the experience buffer to update DDPG networks and collects the mapped potential state $s_p = Z(s)$ into the trajectory buffer to update the APF network.

We will train the APF-DDPG agent and the DDPG agent in the CoppeliaSim simulation platform for 2000 episodes with a maximal 100 steps in each episode. The average episodic rewards over 20 experimental runs will be compared to evaluate the performance of the two agents. The trained models will also be tested on a real Baxter robot to examine their robustness.

The experimental results will be analyzed using the Student's t-test to confirm the significance of the difference between the performances of the DDPG agent and the APF-DDPG agent. The steps employed by the real Baxter robot to reach the goal area using the trained APF-DDPG model will be recorded to further test the robustness of the APF-DDPG agent.",ece532c77f1d29a4,c455de3b9193ac15,cs,cs.RO,2402.04581
"Compare the performance of Memory Mosaics and transformers on language modeling tasks, particularly focusing on out-of-distribution tasks and in-context learning. Describe how you would design an experiment to test their performance on these tasks and what metrics you would use to evaluate their in-context learning abilities.","['The experiment should involve training both Memory Mosaics and transformers on a specific language modeling dataset.'
 'The experiment should include out-of-distribution evaluation using a different dataset.'
 'In-context learning abilities should be evaluated using a benchmark that constructs random artificial languages.'
 'The performance metric for in-context learning should include prediction accuracy and total variation distance.'
 'The experiment should involve hyper-parameter searching for both Memory Mosaics and transformers.'
 'The hyper-parameter search space should be the same for both architectures.'
 'The comparison should ensure that both architectures have the same parameter count for the same architectural hyper-parameters.'
 'The training process should be the same for both architectures, including the optimizer and learning rate scheduler.'
 'The performance on out-of-distribution tasks should be evaluated as a function of the position of the generated token in the input window.'
 'The results should be analyzed to determine if Memory Mosaics outperform transformers on in-context learning tasks.']","To compare the performance of Memory Mosaics and transformers on language modeling tasks, particularly focusing on out-of-distribution tasks and in-context learning, we design an experiment that involves training both architectures on a specific dataset and evaluating their performance on various tasks.

First, we use the BAbIStories dataset, which is generated using the Mixtral-8x7B open language model. This dataset is designed to study large language modeling questions with small language models, allowing us to train relatively small models while still addressing broader language modeling challenges. The BAbIStories dataset is used for training both Memory Mosaics and transformers.

We design a Memory Mosaic architecture that closely matches the classic GPT2-small transformer architecture, using the same GPT2 tokenizer, embedding dimension (d = 768), and number of heads (N_h = N_c = N_p = 12). Both architectures are trained and tested using sequences of length 512. The key differences between the architectures are that Memory Mosaics do not use positional encoding, and they replace the attention heads with contextual memory units and the feed-forward networks with persistent memory units.

To ensure a fair comparison, we perform hyper-parameter searching for both Memory Mosaics and transformers using the same search space, ensuring that both architectures have the same parameter count for the same architectural hyper-parameters. We sweep over depth N_b ∈ {2, 4, 8}, number of heads N_h = N_c = N_p ∈ {2, 4, 8}, embedding dimension d ∈ {64, 128, 256}, weight decay in {10^−2, 10^−1}, and training epochs in {1, 2, ..., 200}. The training process is the same for both architectures, including the optimizer (AdamW) and learning rate scheduler (cosine with minimum learning rate 1e−4).

We evaluate the performance of both models on the BAbIStories dataset by reporting their training and validation losses. We also perform out-of-distribution evaluation using the Simple English Wikipedia dataset, which is more sophisticated and longer than the BAbIStories data. We plot the per-token average loss as a function of the position of the generated token in the input window to assess the models' ability to handle out-of-distribution data.

To evaluate in-context learning abilities, we use the REGBench benchmark, which constructs random artificial languages defined by probabilistic finite automata (PFA). We train both models on a variable number of input sequences and evaluate their ability to predict the last token of testing sequences generated from held-out languages. We report the prediction accuracy and total variation distance between the predicted and true distributions.

By following this experimental design, we can comprehensively compare the performance of Memory Mosaics and transformers on language modeling tasks, out-of-distribution tasks, and in-context learning. This will allow us to determine if Memory Mosaics outperform transformers on in-context learning tasks and provide insights into their relative strengths and weaknesses.",19c9a8ea68196847,2e228c0f6212f3bf,cs,cs.LG,2405.06394
"You are tasked with evaluating the misuse potential of a set of AI models before releasing them. 
        The models are designed to be safe individually, with robust refusal mechanisms to prevent malicious outputs. 
        However, you suspect that adversaries might find ways to combine these models to achieve malicious goals. 
        Your task is to investigate whether combinations of these safe models can be misused, and if so, how. 
        You need to identify a core strategy that adversaries might employ to misuse these model combinations without jailbreaking them.","['The response identifies task decomposition as a core strategy for misusing model combinations.'
 'The response explains that task decomposition involves breaking down malicious tasks into subtasks.'
 'The response notes that subtasks are assigned to models based on their comparative strengths.'
 'The response mentions that a frontier model can handle complicated but benign subtasks.'
 'The response states that a weaker model can handle simple but malicious subtasks.'
 ""The response clarifies that this approach enables misuse without circumventing the models' safety mechanisms.""
 'The response acknowledges that evaluating individual models in isolation is insufficient.'
 'The response avoids suggesting that jailbreaking is necessary for misuse.'
 ""The response does not imply that the models' safety mechanisms are foolproof.""
 'The response considers the potential for different types of subtasks (benign vs. malicious).']","To evaluate the misuse potential of a set of AI models before releasing them, we need to investigate whether combinations of these safe models can be misused, and if so, how. The models are designed to be safe individually with robust refusal mechanisms to prevent malicious outputs. However, we suspect that adversaries might find ways to combine these models to achieve malicious goals.

The core strategy that adversaries might employ to misuse these model combinations without jailbreaking them is task decomposition. Task decomposition involves breaking down malicious tasks into subtasks and assigning these subtasks to models based on their comparative strengths. A frontier model, which is very capable but refuses to produce malicious outputs, can handle complicated but benign subtasks. In contrast, a weaker model, which is less capable but can be prompted to produce malicious outputs, can handle simple but malicious subtasks.

To study this, we will first formalize a threat model that captures model combinations. The adversary aims to produce an output that satisfies some malicious condition using a set of models at its disposal. The adversary combines models by querying them sequentially, selecting a model and a prompt at each turn, and receiving the output. The adversary wins if it eventually produces an output that satisfies the original malicious condition.

We will study two classes of decomposition patterns within this framework: manual and automated decomposition. For manual decomposition, a human identifies a natural decomposition of a task into subtasks that different models are better suited for. The adversary allocates each subtask to the best-suited model. For example, to generate vulnerable code, the adversary might use a frontier model to generate secure code and a weak model to edit it to include a vulnerability.

For automated decomposition, a weak model generates related but benign tasks when the original task is hard to manually decompose. The frontier model solves these related tasks, and the weak model uses the solutions in-context to solve the original malicious task. For instance, to generate a malicious python script for hacking, the weak model might generate related benign tasks, the frontier model solves them, and the weak model uses these solutions to generate the malicious script.

We will evaluate the success rate of adversaries in misusing model combinations for various tasks, including vulnerable code generation, explicit image generation, generating malicious python scripts for hacking, and personalized manipulation. We will compare the success rates of combining models against single-model baselines and study the scaling behavior of misuse as the quality of the weaker and stronger models improves.

To conduct these experiments, we will use a variety of models, including frontier models like Claude 3 and DALL-E 3, and weaker open-source models like Llama 2 and Mistral. We will generate datasets for each task using LLMs to create challenging examples. For evaluation, we will use a combination of human judgment and LLM evaluation, ensuring that the evaluation is both accurate and cost-effective.

By following this plan, we will be able to assess the misuse potential of combinations of models and identify potential risks associated with their deployment. This will help in developing more comprehensive red-teaming efforts that extend beyond individual models in isolation.

Our approach will involve:
1. Formalizing a threat model that captures model combinations and the adversary's strategy.
2. Studying manual and automated decomposition patterns.
3. Evaluating the success rate of adversaries in misusing model combinations for various tasks.
4. Comparing the success rates against single-model baselines.
5. Studying the scaling behavior of misuse as model quality improves.
6. Using a variety of frontier and weaker models.
7. Generating datasets for each task using LLMs.
8. Evaluating outcomes using a combination of human judgment and LLM evaluation.

This comprehensive approach will provide insights into the potential misuse of combinations of safe models and inform strategies to mitigate these risks.",0c5ae658fba288ee,00600c5a3a9efabb,cs,cs.CR,2406.14595
"You are tasked with enhancing the revocability of a BTP framework that uses a deep hashing model to map biometric data to stable codes. The framework needs to allow for the generation of new protected templates when existing ones are compromised, without retraining the deep hashing model. You can introduce additional components or modifications to the existing framework. How would you achieve revocability in the BTP framework without compromising its security?","['The solution should introduce an application-specific XOR string to achieve revocability.'
 'The XOR string should be used to convert the stable code generated by the deep hashing model into a cancelable template.'
 'The XOR string should be independent of the biometric data to prevent any privacy risks.'
 ""When a user's template is compromised, a new XOR string should be generated to create a new cancelable template.""
 'The use of the XOR string should not require retraining the deep hashing model.'
 'The XOR string should be used as a salt value to defend against rainbow table attacks.'
 'The solution should ensure that the protected templates are unlinkable across different applications.'
 'The XOR string should be kept secret to prevent attacks.'
 'The framework should be able to handle multiple revocations and regenerations of templates.'
 'The framework should be designed to accommodate different applications with different XOR strings.']","To enhance the revocability of the BioDeepHash framework that uses a deep hashing model to map biometric data to stable codes, we introduce an application-specific XOR string. This approach allows for the generation of new protected templates when existing ones are compromised without retraining the deep hashing model.

The BioDeepHash framework employs a deep fuzzy hashing (DFH) model to map different biometric data of the same user to a stable code. The DFH model is designed to eliminate noise among biometric data by integrating three loss functions: class-wise loss, class label regression loss, and quantization loss. This ensures that similar biometric data are mapped to identical binary strings.

To achieve revocability, we introduce an application-specific XOR string that is independent of the biometric data. This XOR string is used to convert the stable code generated by the DFH model into a cancelable template. Specifically, when a user enrolls, a random XOR string of length 2L is generated, where L is the length of the stable code. The cancelable template is then generated by performing an XOR operation between the stable code and the first L bits of the XOR string, and concatenating the result with the last L bits of the XOR string.

The use of the XOR string does not require retraining the DFH model, thus maintaining the efficiency of the framework. Moreover, the XOR string is used as a salt value to defend against rainbow table attacks. Since the XOR string is independent of the biometric data and is kept secret, it does not pose any additional privacy risks.

When a user's template is compromised, a new XOR string is generated to create a new cancelable template. This process can be repeated multiple times without requiring retraining of the DFH model, thus achieving revocability.

The protected templates generated using the XOR string and cryptographic hashing are stored in the database. The use of cryptographic hashing ensures that the protected templates do not leak any information related to the original biometric data. Moreover, the protected templates are unlinkable across different applications due to the use of different XOR strings for different applications.

The framework maintains its security properties, including irreversibility and unlinkability, after introducing the XOR string. The length of the XOR string is set to 2L, which is appropriate for the security requirements. The generation of the XOR string using a secure random string generator ensures its randomness and security.

The BioDeepHash framework is designed to accommodate different applications with different XOR strings, making it versatile and secure for various biometric authentication scenarios.

The specific steps to achieve revocability in the BioDeepHash framework are as follows:

1. **Enrollment Phase**: 
   - Collect biometric data from users and preprocess it to generate a training set.
   - Train the DFH model using the preprocessed data to map biometric data to stable codes.
   - Generate an application-specific XOR string for each user.
   - Use the XOR string to convert the stable code into a cancelable template.
   - Process the cancelable template using a cryptographic hash function to obtain the final protected template.
   - Store the protected template and the XOR string in the database.

2. **Verification Phase**:
   - Input the biometric data into the DFH model to obtain the stable code.
   - Use the stored XOR string to generate the cancelable template.
   - Process the cancelable template using the cryptographic hash function.
   - Compare the resulting hash value with the stored protected template to verify the user.

3. **Revocability**:
   - When a template is compromised, generate a new XOR string.
   - Use the new XOR string to create a new cancelable template from the stable code.
   - Process the new cancelable template using the cryptographic hash function to obtain a new protected template.
   - Store the new protected template and the new XOR string in the database.

By following these steps, the BioDeepHash framework achieves revocability without compromising its security properties, making it suitable for biometric template protection applications.",fd399c12be160f41,dab9ec034e5b85f3,cs,cs.CR,2408.03704
"You are tasked with fine-tuning a large language model (LLM) for machine translation. The goal is to improve the model's translation quality as measured by metrics like COMET. However, you are concerned that fine-tuning on parallel data might affect other desirable properties of LLMs, such as their ability to perform formality steering, translate technical domains through few-shot examples, and handle document-level translation. Your task is to investigate how fine-tuning on parallel data impacts these qualitative advantages and identify the factors that influence the extent of any degradation.","['The solution acknowledges the potential risk of catastrophic forgetting when fine-tuning LLMs on parallel data.'
 'The solution proposes an experimental setup to investigate the impact of fine-tuning on various LLM abilities.'
 'The solution includes a diverse range of LLMs (e.g., LLaMA and Falcon) with varying parameter counts.'
 'The solution considers multiple translation directions (e.g., de-en, en-de, ru-en, en-ru, zh-en, en-zh).'
 'The solution evaluates the impact of fine-tuning on general translation quality using a test set like WMT22.'
 'The solution assesses the degradation of formality steering ability using a dataset like CoCoA-MT.'
 'The solution examines the effect on technical translation capabilities through few-shot examples using test sets like Law, Medical, and TICO-19.'
 'The solution investigates the impact on document-level translation capabilities using a test set like ctxpro.'
 'The solution analyzes the effect of varying the size of the fine-tuning dataset on the degradation of LLM abilities.'
 'The solution reports the correlation between the size of the fine-tuning dataset and the degradation of LLM abilities.']","To investigate how fine-tuning on parallel data impacts the qualitative advantages of large language models (LLMs) for machine translation, we will follow a multi-step research plan.

First, we will select a range of LLMs with varying parameter counts, including LLaMA (7B, 13B, 30B, 65B) and Falcon (7B, 40B) models. This diversity in model architectures and sizes will help us understand the generalizability of our findings.

Next, we will fine-tune these models on parallel data in six translation directions: German, Russian, and Chinese into and out of English. We will use two types of parallel data: human-written translations from WMT17 to WMT20, and web-scraped data from OPUS. The human-written data will provide high-quality translations, while the web-scraped data will offer a larger and more diverse dataset.

To evaluate the impact of fine-tuning on LLM abilities, we will assess general translation quality using the WMT22 test set and COMET scores. We will also investigate the degradation of formality steering ability using the CoCoA-MT dataset, technical translation capabilities through few-shot examples using Law, Medical, and TICO-19 test sets, and document-level translation capabilities using the ctxpro test set. Additionally, we will introduce a novel evaluation dataset, IdiomsInCtx-MT, to measure non-literalness performance.

We will analyze the effect of varying the size of the fine-tuning dataset on the degradation of LLM abilities. For human-written data, we will use 18K, 36K, 54K, 71K, and 89K examples, while for web-scraped data, we will use up to 1.4M examples. This will help us understand how the amount of fine-tuning data influences the retention of LLM abilities.

To mitigate the degradation of LLM abilities, we will explore a fine-tuning strategy that combines monolingual and parallel data. We will construct a monolingual dataset from WMT22 News-Commentary data, preserving document-level information, and merge it with parallel data from OPUS. We will then compare the performance of models fine-tuned on this mixed data with those fine-tuned on parallel data alone.

Throughout the experiment, we will track the correlation between the size of the fine-tuning dataset and the degradation of LLM abilities. We will also control for the domain composition of the fine-tuning data and its impact on the results.

By following this research plan, we aim to provide a comprehensive understanding of the impact of fine-tuning on parallel data on LLM abilities and identify strategies to preserve these abilities while improving general translation quality. Our findings will have implications for the development of fine-tuning strategies that balance the trade-off between translation quality and the retention of LLM abilities.",1b299b01999367b8,caf4990a7fad3b1c,cs,cs.CL,2405.20089
"You are working on a project to develop a Graph Neural Network (GNN) based node classifier for identifying potential ""mutagenic"" structures in molecular graphs. Domain experts require explanations for the GNN's predictions in the form of subgraphs that are not only responsible for the classification result but also remain relevant under minor structural changes to the graph. Your task is to devise an explanation structure that captures these requirements and is applicable to GNN-based classification tasks. The explanation should be factual (contributes to the classification result), counterfactual (removing it changes the result), and robust (remains valid under small graph disturbances). How would you approach this problem and what explanation structure would you propose?","['The proposed explanation structure is defined in terms of subgraphs of the input graph.'
 ""The explanation structure is required to be factual, meaning it preserves the GNN's classification result.""
 ""The explanation structure is required to be counterfactual, meaning removing it changes the GNN's classification result.""
 'The explanation structure is required to be robust, meaning it remains valid under small disturbances to the graph.'
 'The explanation structure is applicable to GNN-based node classification tasks.'
 'The approach considers the specific requirements of domain experts for interpretable explanations.'
 'The proposed explanation structure is formally defined.'
 'The explanation structure is designed with the understanding that GNNs are deterministic and fixed.'
 'The approach acknowledges the need for the explanation to be an ""invariant"" structure across similar graphs.'
 'The explanation structure is not trivial (e.g., not the entire graph or a single node).']","To address the task of developing a Graph Neural Network (GNN) based node classifier for identifying potential ""mutagenic"" structures in molecular graphs and providing explanations for the GNN's predictions, we propose a research plan based on the concept of Robust Counterfactual Witnesses (RCWs).

First, we formalize the notion of RCWs for GNN-based node classification. An RCW is a subgraph in G that preserves the result of a GNN-based classifier if tested with RCW alone, remains counterfactual (i.e., the GNN gives different output for the remaining fraction of the graph if RCW is excluded), and robust (such that it can preserve the result even if up to k edges in G are changed).

To verify if a given subgraph G_s is a k-RCW for test nodes V_T w.r.t. GNN M, we introduce a configuration C = (G, G_s, V_T, M, k) and study the verification problem. We establish that the verification problem for k-RCW is NP-hard. However, for APPNPs, a class of Personalized PageRank based GNNs, under (k, b)-disturbance (where at most k edges are disturbed and at most b edges for each involved node), the verification problem becomes tractable. We develop a PTIME algorithm, verifyRCW-APPNP, which verifies if a given subgraph G_s is a k-RCW for a single node v ∈ V_T w.r.t. M under (k, b)-disturbance.

For generating RCWs, we propose an algorithm, RoboGExp, which ensures to output a k-RCW in general cases and is in PTIME for APPNPs under (k, b)-disturbance. RoboGExp processes a set of test nodes V_T one node at a time and iteratively grows G_s with an ""expand-verify"" strategy for each node. It approximates the optimal set of node pairs E_k^* that can minimize the worst-case margin m_l,c^* of v and augments G_s to contain E_k^*, such that it ""secures"" G by preventing disturbances from E_k^*. The algorithm always terminates with either a non-trivial k-RCW or trivial cases.

To improve scalability for large graphs, we introduce a parallel algorithm, paraRoboGExp. It parallelizes the verification into smaller manageable tasks <G_i, G_s, j>, each checking if there is a disturbance from G_i alone that disproves G_s to be a j-RCW of M(v, G)=l. The algorithm works with a coordinator site and n workers, each processing one fragment G_i of G. It ensures an ""inference preserving partition"" such that local verification and inference can be conducted without expensive data communication.

We will experimentally evaluate our algorithms using three real-world and one synthetic dataset, assessing the quality of the k-RCWs generated by RoboGExp in terms of robustness and fidelity measures, the impact of critical factors (test node size |V_T| and degree of disturbances k) on the quality, the efficiency of RoboGExp and paraRoboGExp for large graphs, and the scalability of paraRoboGExp. We will also perform case study analyses to showcase real applications of RoboGExp.

Our research plan is designed to provide a comprehensive solution for GNN-based node classification tasks, addressing the need for explanations that are factual, counterfactual, and robust to minor structural changes in the graph. By developing and evaluating RCWs, we aim to improve the efficiency of identifying relevant structures across a family of similar graphs and provide understandable explanations for domain experts.",4c94017ecfa8b4c3,4b94837de36b8c85,cs,cs.LG,2404.19519
"You are tasked with developing a machine learning model to screen glass compositions for their glass transition temperature (Tg). The dataset available contains a large number of glass compositions with their corresponding Tg values, but the Tg labels are noisy due to measurement errors. Moreover, the dataset suffers from class imbalance, with certain Tg ranges being more frequent than others. Your goal is to develop a model that can accurately predict whether a given glass composition has a Tg within a specific predefined range. How would you reformulate this task to make it more tractable for a machine learning model, and what type of model would you use?","['The reformulation involves changing the task from regression to classification.'
 'The classification task involves predicting whether Tg falls within a predefined range.'
 'The approach eliminates the need to predict exact Tg values.'
 'The reformulation reduces the impact of noisy Tg labels.'
 'The task simplification is mentioned as a key benefit.'
 ""The reformulation reduces the demands on the model's fitting capability.""
 'The approach leverages the strengths of classification models.'
 'The model should be able to handle class imbalance issues.'
 'The solution involves labeling samples based on whether they fall within the target Tg range.'
 'The reformulation is aimed at minimizing the impact of Tg label noise.']","To develop a machine learning model that screens glass compositions for their glass transition temperature (Tg) within a specific predefined range, we reformulate the task as a classification problem. The goal is to predict whether the Tg of a given glass composition falls within the specified range, rather than predicting the exact Tg value. This approach simplifies the task and reduces the impact of noisy Tg labels in the dataset.

First, we collect and clean the dataset sourced from the SciGlass database, version 7.12. The initial dataset contains approximately 442,000 glass compositions with their corresponding Tg values. We filter the samples to include only those with total mass fractions between 0.95 and 1.05, resulting in a cleaned dataset of 35,176 samples. The cleaned dataset is then divided into a training set (80%) and a validation set (20%).

To address the issue of noisy Tg labels and class imbalance, we propose a data augmentation strategy rooted in asymptotic theory. We apply small perturbations with a normal distribution to each component of the glass composition to emulate measurement errors. For each training sample, we perform perturbation before feeding it into the model, effectively multiplying the size of the training set. The validation set remains unperturbed to ensure stable evaluation results.

We design a specialized neural network architecture, DeepGlassNet, to capture the complex interactions between different glass components. DeepGlassNet comprises four key modules: proportion-modulated embedding, interaction feature extraction, self-attention, and nonlinear projection. The proportion-modulated embedding layer adjusts the embedding of each component based on its proportion within the glass composition. The interaction feature extraction module, which includes a graph convolution layer and a self-attention layer, captures the second-order and high-order interactions between components.

To optimize the model's performance, we employ a self-supervised learning framework that maximizes the consistency of feature representations among samples within the same class and minimizes it among samples from different classes. We organize the data into triplets (anchor, positive sample, negative sample) based on their class labels and compute a contrastive loss. This learning paradigm mitigates class imbalance issues and relieves the model from accurately reconstructing Tg labels.

During training, we feed the augmented and normalized training triplets into DeepGlassNet, optimizing the model parameters using the Adam optimizer. We evaluate the model's performance on the validation set using metrics such as AUC (Area Under the Curve) and Precision@k. AUC assesses the model's ability to distinguish between target and non-target samples, while Precision@k evaluates the classification accuracy among the top-ranked samples.

To fine-tune the hyperparameters of DeepGlassNet, we assess its performance on the validation set and adjust parameters such as the dimensions of latent factors, embedding dimensions, and learning rate. Once the optimal model is identified, we use it to screen potential glass compositions from the test set, selecting the top samples whose feature representations are closest to the target class center.

The screened samples are then prepared and characterized experimentally to validate the model's predictions. By comparing the predicted Tg ranges with the experimentally measured Tg values, we assess the effectiveness of DeepGlassNet in identifying glass compositions with desired properties.

This research plan provides a comprehensive approach to developing a machine learning model for screening glass compositions based on their Tg values. By reformulating the task as a classification problem, employing data augmentation, and designing a specialized neural network architecture, we aim to create a robust model that can accurately identify promising glass compositions within a predefined Tg range.",2ba6c0a3c456586e,4efb952eea03ba1d,cs,cs.CE,2410.24083
"You have found that AI models for power flow prediction are not robust under the N-1 security criterion, particularly when lines connected to highly connected nodes are disconnected. Your task is to improve the robustness of these models by developing a training strategy that incorporates N-1 instances. You need to decide how to generate or select N-1 instances for training and how to integrate them into the training process. Develop a research plan to enhance the robustness of AI models using mixed training with N and N-1 instances.","['The research plan clearly states the objective of enhancing AI model robustness through mixed training.'
 'The plan describes the method for generating or selecting N-1 instances for training, considering factors like node connectivity.'
 'The plan outlines how to integrate N-1 instances into the existing training dataset, including the proportion of N-1 instances to use.'
 'The plan includes a description of how to evaluate the performance of the models trained with mixed data under N-1 scenarios.'
 'The plan considers the potential impact of the proportion of N-1 instances on model robustness and how to optimize this proportion.'
 'The plan includes a discussion on how to ensure that the N-1 instances used for training are representative of real-world scenarios.'
 'The research plan suggests ways to analyze the sensitivity of model performance to different types of N-1 instances.'
 'The plan addresses potential challenges or limitations in implementing mixed training, such as increased computational cost.'
 'The plan includes a consideration of how the findings could be generalized to other AI models or power grid configurations.'
 'The research plan is feasible with the available data, computational resources, and timeframe.']","To enhance the robustness of AI models for power flow prediction under the N-1 security criterion, we will develop a training strategy that incorporates N-1 instances into the training dataset. The objective is to improve the models' performance and reliability when faced with topological changes in the power grid.

First, we will generate N-1 instances using the Grid2op framework, which is a Python library for simulating power grid operations. We will utilize the IEEE 14 and IEEE 118 datasets, which are standard datasets in the Power Engineering community. To generate N-1 instances, we will employ a grid agent that randomly cuts one line from the grid based on a predefined probability p. The new state of the grid will be computed using the Newton-Raphson method.

We will then mix the generated N-1 instances with the original N instances to create a mixed training dataset. The proportion of N-1 instances to be included in the training dataset will be determined by the probability p, which will be set to either 0.01 or 0.1. This will allow us to assess the impact of different proportions of N-1 instances on the model's robustness.

The AI models to be used in this study are PowerFlowNet, LeapNet, and ResNet, which are state-of-the-art models for power flow prediction. We will train these models using the mixed dataset and evaluate their performance on unseen N-1 cases. The performance metric used will be the Mean Squared Error (MSE) between the predicted and actual power flow values.

To evaluate the effectiveness of the mixed training strategy, we will compare the performance of the models trained with and without N-1 instances. We will also analyze the sensitivity of the models' performance to different types of N-1 instances of the grid. To do this, we will cluster the test set instances based on the degree of the node with the highest degree (D max) and the node with the median degree (D median).

The training process will involve using the Adam optimizer with a learning rate of 0.001 and a linear scheduler with a step size of 5. The batch size will be set to 128, and the models will be trained for 25 epochs.

To ensure that the N-1 instances used for training are representative of real-world scenarios, we will use a grid agent that randomly cuts lines from the grid based on a probability p. This will simulate the occurrence of line failures in real-world power grids.

The criteria for assessing the improvement in model robustness will be the MSE on the N-1 test dataset. We will compare the MSE of the models trained with and without N-1 instances to determine the effectiveness of the mixed training strategy.

The potential challenges or limitations in implementing mixed training include increased computational cost due to the additional N-1 instances. However, this can be mitigated by optimizing the proportion of N-1 instances used in the training dataset.

The findings of this study will have implications for the practical deployment of AI models in power grid operations. By enhancing the robustness of these models to topological changes, we can improve the reliability and efficiency of power grid operations.

To validate the robustness of the trained models under various N-1 scenarios, we will evaluate their performance on multiple N-1 test datasets. This will involve assessing their performance on different grid topologies and line failure scenarios.

In conclusion, our research plan involves generating N-1 instances using a grid agent, mixing them with the original N instances, and training AI models using the mixed dataset. We will evaluate the performance of the models on unseen N-1 cases and compare their performance with and without N-1 instances. The findings of this study will contribute to the development of more robust AI models for power flow prediction under the N-1 security criterion.",2eed117373aa4b75,2867863890347587,cs,cs.AI,2406.14361
"You are working on a Multi-objective Reinforcement Learning (MORL) problem where the goal is to learn a set of policies that can trade-off between multiple conflicting objectives. The MORL problem is formulated as a multi-objective Markov Decision Process (MOMDP) with a vector-valued reward function. You want to use a decomposition-based approach to MORL, where the problem is decomposed into several single-objective sub-problems using linear scalarisation vectors. However, the space of linear scalarisation vectors is very large, and you need to efficiently search for the most promising vectors to condition your policies on. Your goal is to develop a method that can balance exploration and exploitation during policy learning to maximise the hypervolume of the resulting Convex Coverage Set (CCS). How would you approach this problem?","['The solution proposes a method to efficiently search for the most promising linear scalarisation vectors.'
 'The method balances exploration and exploitation during policy learning.'
 'The solution uses a surrogate model to predict the expected change in objective values.'
 'The solution employs an acquisition function to select the scalarisation vectors to train on.'
 'The UCB acquisition function trades off between exploring new scalarisation vectors and exploiting current knowledge.'
 'The solution maximises the hypervolume of the resulting CCS.'
 'The method is designed to work with a decomposition-based MORL approach.'
 'The solution is applicable to MORL problems with linear utility functions.'
 'The method does not require systematic enumeration of the entire space of linear scalarisation vectors.'
 'The solution involves training a policy conditioned on the selected scalarisation vectors.']","The research plan involves developing a method to efficiently search for the most promising linear scalarisation vectors in a Multi-objective Reinforcement Learning (MORL) problem. The goal is to learn a set of policies that can trade-off between multiple conflicting objectives.

To achieve this, we will adopt a decomposition-based MORL approach, where the problem is decomposed into several single-objective sub-problems using linear scalarisation vectors. The space of linear scalarisation vectors is very large, so we need to efficiently search for the most promising vectors to condition our policies on.

The proposed method, UCB-MOPPO, involves a two-layer decomposition of the MORL problem into scalar RL sub-problems. At the first layer, a set of K evenly distributed scalarisation vectors (pivots) are defined within the scalarisation vector space W, dividing it into K sub-spaces. At the second layer, for each sub-space W_k, a number of M evenly distributed scalarisation vectors are defined.

We will use a scalarisation-vector-conditioned Actor-Critic network, where both the policy network πθ(s, w) and the value network vϕπ(s, w) are conditioned on the scalarisation vector w. This allows for a single policy to express different trade-offs between objectives by generalising to a neighbourhood of scalarisation vectors.

To maximise the hypervolume of the resulting Convex Coverage Set (CCS), we will employ a surrogate-assisted optimisation approach. A data-driven uncertainty-aware surrogate model will be built in the scalarisation vector space to predict the expected change in each objective after training πk conditioned on a scalarisation vector w for C iterations. The surrogate model takes the form of Bagging of linear models with elastic net regularisation.

An Upper Confidence Bound (UCB) acquisition function will be used to select those scalarisation vectors to train on from each sub-space W_k. The UCB acquisition function balances exploration and exploitation during search by considering both the predicted improvement in hypervolume and the uncertainty of the surrogate model's predictions.

The algorithm will proceed in stages of C iterations each. At every stage, K pivot policies πk will be trained in parallel using Proximal Policy Optimisation (PPO), each conditioned on a subset of N scalarisation vectors out of M in total that are defined for each corresponding sub-space W_k.

The performance of UCB-MOPPO will be evaluated on six multi-objective RL benchmark problems drawn from the MuJoCo test suite. The results will be compared to other baseline methods, including PGMORL, Fixed-MOPPO, Random-MOPPO, and Mean-MOPPO.

The key characteristics of the proposed algorithm are: 
1. A two-layer problem decomposition that allows different policies to specialise in different sub-spaces of the scalarisation vector space.
2. The use of a UCB acquisition function for selecting scalarisation vectors to balance exploration and exploitation.

The proposed method is designed to work with MORL problems with linear utility functions and does not require systematic enumeration of the entire space of linear scalarisation vectors. By using a surrogate model to predict the expected change in objective values and an acquisition function to select the scalarisation vectors to train on, UCB-MOPPO efficiently searches for the most promising linear scalarisation vectors while balancing exploration and exploitation during policy learning.",b8a95ec987cdf717,993f5d343ff90d2f,cs,cs.LG,2405.00410
"You are given the task of simplifying the calculation of the outage probability of OTFS in lossy communications, which involves a multi-fold integral with respect to the PDFs of the instantaneous channel coefficients. The exact calculation is computationally expensive, and you need to derive a lower bound for the outage probability without requiring heavy computational complexity. Propose a method to simplify the expression of the outage probability by analyzing the properties of the effective DD domain channel matrix H_DD.","['The proposed method should involve the decomposition of H_DD^H H_DD into H_A, H_B1, and H_B2.'
 'The solution should prove that det(I_MN + E_s/N_0 (H_A + H_B1)) ≤ det(I_MN + E_s/N_0 H_A).'
 'The derivation should show that det(I_MN + E_s/N_0 (H_A + H_B1 + H_B2)) ≤ det(I_MN + E_s/N_0 (H_A + H_B1)).'
 'The lower bound of the outage probability should be derived based on the simplified expression of det(I_MN + E_s/N_0 H_A).'
 'The solution should involve the calculation of Pr(H_b^{-1}(1 - log_2(1 + E_s/N_0 ∑|h_i|^2)/K) > D).'
 'The Chi-squared distribution with 2P degrees of freedom should be used to simplify the derivation.'
 'The final expression for the lower bound should be in a closed form.'
 'The derivation should be valid for i.i.d. complex Gaussian channel coefficients h_i.'
 'The impact of the number of resolvable paths P on the lower bound should be considered.'
 'The solution should be applicable to OTFS systems with different frame lengths (M × N).']","To simplify the calculation of the outage probability of OTFS in lossy communications, we need to derive a lower bound for the outage probability without requiring heavy computational complexity. The exact calculation involves a multi-fold integral with respect to the PDFs of the instantaneous channel coefficients, which is computationally expensive.

First, we analyze the properties of the effective DD domain channel matrix $H_{DD}$. We start by expressing $H_{DD}$ as $H_{DD} = \sum_{i=1}^{P} h_i (F_N \otimes I_M) \Pi^{l_i} \Delta^{k_i} (F_N^H \otimes I_M)$, where $h_i$ represents the complex fading coefficient, $\Pi$ is a forward cyclic shift permutation matrix describing the delay effect, and $\Delta$ is a diagonal matrix describing the Doppler effect.

We then decompose $H_{DD}^H H_{DD}$ into three components: $H_A = \sum_{i=1}^{P} |h_i|^2 I_{MN}$, $H_{B1} = \sum_{i=1}^{P-1} \sum_{i'=i+1, l_{i'} = l_i}^{P} (F_N \otimes I_M) (h_i^* h_{i'} \Lambda + h_i h_{i'}^* \Lambda^H) (F_N^H \otimes I_M)$, and $H_{B2} = \sum_{i=1}^{P-1} \sum_{i'=i+1, l_{i'} \neq l_i}^{P} (F_N \otimes I_M) (h_i^* h_{i'} \Lambda + h_i h_{i'}^* \Lambda^H) (F_N^H \otimes I_M)$, where $\Lambda = \Delta^{-k_i} \Pi^{l_{i'} - l_i} \Delta^{k_{i'}}$.

To derive the lower bound, we first prove that $\det(I_{MN} + \frac{E_s}{N_0} (H_A + H_{B1})) \leq \det(I_{MN} + \frac{E_s}{N_0} H_A)$. This is achieved by analyzing the structure of $H_{B1}$ and showing that the product of its diagonal elements is less than or equal to zero. Specifically, we show that the diagonal elements of $\Xi = \xi_1 I_{MN} + \diag\{\xi_{2,0}, \cdots, \xi_{2,MN-1}\}$ satisfy $\xi_{1} + \xi_{2,b} \leq \xi_1$ when paired with their counterparts $\xi_{1} + \xi_{2,b + \frac{MN}{2a_2}}$, due to the property that $\beta_{b + \frac{MN}{2a_2}} = -\beta_b$. This results in $\det(I_{MN} + \frac{E_s}{N_0} (H_A + H_{B1})) \leq \det(I_{MN} + \frac{E_s}{N_0} H_A)$.

Next, we prove that $\det(I_{MN} + \frac{E_s}{N_0} (H_A + H_{B1} + H_{B2})) \leq \det(I_{MN} + \frac{E_s}{N_0} (H_A + H_{B1}))$. We achieve this by showing that the diagonal elements of $\Omega = \sum_{i=1}^{P-1} \sum_{i'=i+1, l_{i'} \neq l_i}^{P} (F_N \otimes I_M) (h_i^* h_{i'} \Lambda + h_i h_{i'}^* \Lambda^H) (F_N^H \otimes I_M)$ are zero, and that $\det(\Xi + \Omega) \leq \det(\Xi)$ due to the property that the determinant of a semi-positive definite matrix is not greater than the product of its diagonal elements.

By combining these two results, we obtain $\det(I_{MN} + \frac{E_s}{N_0} H_{DD}^H H_{DD}) \leq \det(I_{MN} + \frac{E_s}{N_0} H_A)$. We then use this to derive the lower bound of the outage probability: $P_{out} \geq \Pr(H_b^{-1}(1 - \frac{\log_2(1 + \frac{E_s}{N_0} \sum_{i=1}^{P} |h_i|^2)}{K}) > D)$.

To simplify the derivation, we define $h_i' = \sqrt{2P} h_i$, so that $h_i'$ follows a complex Gaussian distribution with zero mean and unit variance per dimension. Therefore, $\sum_{i=1}^{P} |h_i'|^2$ follows a Chi-squared distribution with $2P$ degrees of freedom. Using this, we can rewrite the lower bound as $P_{out} \geq \Pr(\sum_{i=1}^{P} |h_i|^2 < \frac{2^K - 2^{KH_b(D)}}{\frac{E_s}{N_0}})$.

Finally, we calculate the lower bound using the PDF of the Chi-squared distribution: $P_{out} \geq 1 - \exp(-\frac{2^{K-KH_b(D)}-1}{\frac{E_s}{N_0}}) \sum_{i=0}^{P-1} \frac{(\frac{2^{K-KH_b(D)}-1}{\frac{E_s}{N_0}})^i}{i!}$.

This lower bound provides a performance limit under the optimal condition as a reference, and its calculation is much simpler than the exact outage probability. The derivation is valid for i.i.d. complex Gaussian channel coefficients $h_i$, and it considers the impact of the number of resolvable paths $P$ and the frame length ($M \times N$) on the outage probability.",d2ec4b1a40b63093,c37ba0ddebeb0970,cs,cs.IT,2410.01564
"You are developing a deep learning-based Visual SLAM system that uses a frontend for odometry estimation and a backend for global optimization. However, you've noticed that the frontend and backend are competing for GPU resources, causing the framerate to fluctuate wildly. Your goal is to design a loop closure mechanism that can run on a single GPU without significantly impacting the frontend's performance. The mechanism should be able to detect loops and perform global optimization without requiring a separate GPU. You are constrained by the fact that CUDA operations on the same device typically run sequentially, and you need to minimize the additional computational cost and memory usage.","['The solution acknowledges the sequential nature of CUDA operations on the same device.'
 'The proposed mechanism detects loops based on camera proximity to previously visited locations.'
 'The loop closure mechanism is integrated into the existing odometry system.'
 'The solution optimizes a single, shared scene graph with both odometry and loop closure factors.'
 'The mechanism is described as being inexpensive and fast to run.'
 'The solution addresses the challenge of fluctuating framerate due to frontend and backend competition for GPU resources.'
 'The solution minimizes additional computational cost.'
 'The mechanism minimizes additional memory usage.'
 ""The loop closure mechanism is evaluated for its impact on the overall system's framerate.""
 'The solution considers the trade-off between accuracy and computational efficiency.']","To address the challenge of developing a loop closure mechanism for a deep learning-based Visual SLAM system that runs on a single GPU without significantly impacting the frontend's performance, we follow the approach outlined in the Deep Patch Visual (DPV) SLAM research.

First, we extend the DPVO visual odometry system to a full SLAM system by introducing a proximity loop closure mechanism. This mechanism detects loops via the camera's proximity to previously visited locations, improving global consistency by periodically inserting long-range edges into the patch graph, updating their optical flow, and performing global bundle adjustment to update all camera poses and depth.

To minimize the number of deep features stored in memory, we construct the patch graph by permanently storing only the patch features for all previous time-steps and creating uni-directional edges connecting these patches to recently observed frames. This approach reduces the storage overhead from the patch features to approximately 0.6G per 1K frames.

For efficient global optimization, we mix both odometry and loop-closure factors in the same optimization. We implement a CUDA-accelerated block-sparse bundle adjustment that is compatible with DPVO's ""patch graph"" scene representation. This block-sparse implementation is significantly faster and more memory-efficient for large patch graphs compared to the dense implementation used in DPVO.

In addition to the proximity loop closure, we also support a classical loop closure mechanism based on image retrieval and pose graph optimization, which runs on the CPU. This secondary backend is better equipped to recover from scale drift and is referred to as DPV-SLAM++ when used in conjunction with the proximity loop closure.

Our approach is designed to be efficient, accurate, and robust. We evaluate DPV-SLAM on various datasets, including EuRoC, KITTI, TUM-RGBD, and TartanAir, demonstrating its ability to generalize well across different domains and achieve comparable or better accuracy than state-of-the-art methods while running faster and using less compute.

The proximity loop closure mechanism is designed to be inexpensive and fast, running considerably faster than DROID-SLAM's backend on EuRoC (0.1-0.18s vs 0.5-5s). By optimizing a single, shared scene graph with both odometry and loop closure factors, we minimize the additional computational cost and memory usage.

Our solution addresses the challenge of fluctuating framerate due to frontend and backend competition for GPU resources by running the loop closure mechanism on the same GPU as the frontend, leveraging the block-sparse bundle adjustment implementation to reduce the computational overhead.

The distribution of inference speed on EuRoC and KITTI datasets shows that the loop closure causes a minor drop in framerate, from 58 to 42 FPS on EuRoC and a brief dip below real-time on KITTI before returning to 40 FPS. The average speed on EuRoC and KITTI are 50 FPS and 39 FPS, respectively, indicating that our method is capable of real-time performance.

Overall, our research plan involves implementing the DPV-SLAM system with its proximity loop closure mechanism and classical loop closure backend, evaluating its performance on various datasets, and demonstrating its efficiency, accuracy, and robustness in different environments.",008fa2f91976424e,19b6985589cd5ff7,cs,cs.CV,2408.01654
"You are tasked with developing a training process for a novel representation learning framework that utilizes multiple encoders to capture a more comprehensive representation of the input data. The framework is based on the Information Bottleneck (IB) principle and aims to improve the mutual information between the compressed representation and the target variable. The primary encoder is trained using the IB Lagrangian, and you need to design a training process for the auxiliary encoders that ensures they capture complementary information while being distinct from the primary encoder. Propose a detailed training process for the auxiliary encoders.","['The training process should involve multiple stages.'
 'The primary encoder and decoder should be trained first using the IB Lagrangian.'
 'Each auxiliary encoder should be trained to capture information missed by the primary encoder and previously trained auxiliary encoders.'
 'The training objective for auxiliary encoders should include maximizing their mutual information with the target variable.'
 ""The training objective should also include a term to ensure the auxiliary encoders' features are distinct from the primary encoder's feature.""
 ""A mechanism should be proposed to minimize the mutual information between the current auxiliary encoder's feature and the concatenation of previously extracted features.""
 'The weights for aggregating features from different encoders should be optimized.'
 'The optimization of weights should be done using the IB Lagrangian.'
 ""The proposal should ensure that the decoder's parameters remain fixed during the training of auxiliary encoders.""
 'The proposal should discuss how to handle the computational challenges associated with estimating mutual information.']","The research plan involves developing a training process for a novel representation learning framework that utilizes multiple encoders to capture a more comprehensive representation of the input data. The framework is based on the Information Bottleneck (IB) principle and aims to improve the mutual information between the compressed representation and the target variable.

To achieve this, we will follow a multi-stage training process. First, we train the primary encoder and decoder using the IB Lagrangian. This involves optimizing the primary encoder to learn the optimal probabilistic mapping p(Z|X) and the decoder to approximate the conditional distribution p(Y|Z) accurately. The objective is to maximize the mutual information I(Z, Y) while constraining I(X, Z) through minimizing the IB Lagrangian: min L[p(Z|X), p(Y|Z); β] = −I(Z, Y) + βI(X, Z).

Next, we train the auxiliary encoders sequentially. For each auxiliary encoder E_i, the objective is to extract features that are informative about the target Y but independent of previously extracted features. We employ the IB Lagrangian to capture informative content: min L[p(Z_i|X), p(Y|Z_i); β] = −I(Z_i, Y) + βI(X, Z_i). To ensure feature independence, we minimize the mutual information between the current feature Z_i and the concatenation of previous features Z + ∑_{j=1}^{i-1} Z_j: min I(Z_i, Z + ∑_{j=1}^{i-1} Z_j).

To address the computational challenge of minimizing I(Z_i, Z + ∑_{j=1}^{i-1} Z_j), we adopt a sampling-based approach. We generate samples from the joint distribution p(Z_i, Z + ∑_{j=1}^{i-1} Z_j) and the product distribution p(Z_i)p(Z + ∑_{j=1}^{i-1} Z_j) by shuffling the samples along the batch dimension. We then employ a discriminator d to distinguish between samples from the joint and product distributions. The discriminator is trained adversarially using the objective: min_{E_i} max_d E_{p(Z_i)p(Z+∑_{j=1}^{i-1} Z_j)} log d(Z_i, Z + ∑_{j=1}^{i-1} Z_j) + E_{p(Z_i,Z+∑_{j=1}^{i-1} Z_j)} log(1 - d(Z_i, Z + ∑_{j=1}^{i-1} Z_j)).

After training the primary and auxiliary encoders, we optimize the weights w_i for aggregating features from different encoders. The objective is to minimize the IB Lagrangian: min_{w_i} L[p(ˆZ|X), p(Y|ˆZ); β] = −I(ˆZ, Y) + βI(X, ˆZ), where ˆZ = w_0 Z + ∑_{i=1}^K w_i Z_i.

Throughout the training process, we keep the decoder's parameters fixed after its initial training with the primary encoder. This ensures that the learned relationships between features and the target variable Y remain unchanged.

The proposed training process is designed to work with deep neural networks and is flexible and adaptable to different tasks and datasets. By incorporating auxiliary encoders and optimizing their weights, we aim to improve the informativeness of the compressed representation while maintaining the desired level of compression.

To handle the computational challenges associated with estimating mutual information, we employ variational bounds and neural estimators. Specifically, we use Monte Carlo sampling to estimate I(X, Z) and cross-entropy loss to estimate I(Z, Y).

The training process involves multiple stages, and each stage is designed to achieve a specific objective. The primary encoder and decoder are trained first, followed by the sequential training of auxiliary encoders. The weights for aggregating features are optimized last. This staged approach allows us to capture complementary information and ensure that the auxiliary encoders' features are distinct from the primary encoder's feature.

By following this research plan, we aim to develop a robust and effective training process for the proposed representation learning framework.",3054d1e4000c1e38,41d3ffce0940daa8,cs,cs.IT,2412.08222
"You are given the task of comparing the performance of different deep learning models for predicting multiple meteorological variables from satellite images. The models to be compared include Convolutional Neural Networks (CNN), Squeeze-and-Excitation Networks (SENet), and Conditional Denoising Diffusion Probability Models (CDDPM). The goal is to identify the most effective model for this task. Propose a comprehensive evaluation framework that includes relevant performance metrics and a detailed comparison methodology. The evaluation should be based on the Digital Typhoon satellite images and ERA5 reanalysis data for the region around Taiwan.","['The proposed metrics should include PSNR, SSIM, and RMSE to evaluate the accuracy and realism of the predictions.'
 'The comparison methodology should be fair and unbiased, ensuring that each model is evaluated under the same conditions.'
 'The evaluation should consider the specific characteristics of the typhoon data and the region around Taiwan.'
 'The proposed framework should be able to handle the complexities and uncertainties in the data.'
 'The evaluation should include a statistical analysis to determine the significance of the performance differences between models.'
 'The proposed framework should be able to identify the strengths and weaknesses of each model.'
 'The evaluation should consider the computational efficiency and feasibility of training each model.'
 ""The comparison should include an analysis of the models' ability to generalize to unseen data.""
 ""The proposed framework should provide insights into the models' performance on different meteorological variables.""
 ""The comparison should consider the interpretability and explainability of the models' predictions.""]","To compare the performance of different deep learning models for predicting multiple meteorological variables from satellite images, we will follow a comprehensive evaluation framework. The models to be compared include Convolutional Neural Networks (CNN), Squeeze-and-Excitation Networks (SENet), and Conditional Denoising Diffusion Probability Models (CDDPM).

First, we will utilize the Digital Typhoon satellite images and ERA5 reanalysis data for the region around Taiwan. The ERA5 dataset provides the u-component of wind (u10), v-component of wind (v10), surface pressure (sp), and temperature at 2 meters (t2m) within the specified latitude and longitude range. The Digital Typhoon dataset offers high-resolution satellite images.

We will process the data by selecting the region around Taiwan, extracting relevant typhoon data, and cropping it to ensure a fixed region of interest. The datasets will be cleaned, aligned, and normalized to a range of [0, 1] to ensure consistent scaling across all input features. Data augmentation techniques such as random noise addition, Gaussian smoothing, and contrast adjustment will be applied to improve the model's generalization capability. The dataset will be divided into 80% for training and 20% for testing.

For the evaluation framework, we will use a diverse set of performance metrics to comprehensively assess the models. The metrics will include Peak Signal-to-Noise Ratio (PSNR), Structural Similarity Index Measure (SSIM), Root Mean Squared Error (RMSE), KL-Divergence (KL-Div), Fréchet Inception Distance (FID), and Learned Perceptual Image Patch Similarity (LPIPS). These metrics will evaluate the accuracy and realism of the predictions.

The comparison methodology will be fair and unbiased, ensuring that each model is evaluated under the same conditions. The models will be trained and tested on the same dataset and experimental setup. We will also consider the specific characteristics of the typhoon data and the region around Taiwan.

To handle the complexities and uncertainties in the data, we will use a statistical analysis to determine the significance of the performance differences between models. This will involve comparing the mean evaluation results across all variables and models.

The evaluation will also consider the computational efficiency and feasibility of training each model. We will assess the ability of the models to generalize to unseen data and provide insights into their performance on different meteorological variables.

The CDDPM model will be trained using a forward diffusion process that involves gradually transforming the ERA5 meteorological data into pure noise by incrementally adding Gaussian noise over T time steps. The reverse diffusion process will be parameterized by a neural network that takes the conditional data (Digital Typhoon data), the noisy observation (Noisy ERA5), the noise level, and predicts the noise component.

During inference, the trained model will use the DT data as a condition to iteratively refine the noisy data sampled from a normal distribution, gradually denoising it to generate clean ERA5 meteorological data.

By following this comprehensive evaluation framework, we will be able to identify the most effective model for predicting multiple meteorological variables from satellite images and provide insights into their strengths and weaknesses.",33f417ba5a178e7f,cff596cc30ae8c77,cs,cs.CV,2409.07961
"You've observed that incorporating object relationships into a vision-and-language navigation agent improves its success rates but also increases the trajectory length due to more extensive exploration. However, the overall efficiency, as measured by metrics like SPL and RGSPL, doesn't show significant improvement. Propose a strategy to balance the exploration and exploitation trade-off in this context, and describe how you would test its effectiveness.","['The proposed strategy should aim to reduce the trajectory length while maintaining or improving the success rate.'
 'The approach should involve modifying the training regime or loss function to discourage redundant exploration.'
 'The solution should be able to differentiate between beneficial exploration and redundant revisits.'
 'The strategy should be tested on datasets with varying levels of complexity and object annotations.'
 'The evaluation metrics should include SPL, RGSPL, TL, SR, and OSR to assess both efficiency and effectiveness.'
 'The proposed method should be compared with the baseline model without the object relationship module.'
 'The implementation should be feasible within the existing architecture of the navigation agent.'
 'The solution should be able to adapt to different navigation environments and instructions.'
 'The strategy should be evaluated for its impact on both navigation and grounding-related metrics.'
 'The conclusions drawn should be supported by statistical analysis of the results.']","To address the scenario, we present a comprehensive research plan that aims to balance the exploration and exploitation trade-off in a vision-and-language navigation agent. The agent's performance is enhanced by incorporating object relationships, but this also increases the trajectory length due to more extensive exploration. Our strategy involves modifying the training regime and loss function to discourage redundant exploration while maintaining or improving the success rate.

First, we adopt the architecture of DUET as the baseline, which consists of three inputs: panoramic visual features of the current location, a topological map, and an instruction. Our method employs two modules, Temporal Object Relations (TOR) and Spatial Object Relations (SOR), to calculate temporal object features and spatial object features at each step. These features are then combined with object features and image features to generate panoramic features, which are fed into a dual-scale encoder to predict the agent's action.

The TOR module captures the variations in positional relationships among objects from the moving trajectory of the agent using a cross-attention mechanism. The SOR module models the spatial relations among objects from all locations within a navigational environment, ensuring complete spatial coverage. Both modules significantly enhance the accuracy of the navigation.

However, the detailed tracking and continuous updating of object relations can lead the agent to explore new locations that are not part of the correct path or to conduct multiple explorations at the same location. To counteract this, we introduce the Turning Back Penalty (TBP) loss function, which penalizes the agent's repetitive visiting behavior during training. The TBP loss function is designed to prevent the agent from retracing its steps while ensuring ample exploration of the environment.

The TBP loss function is formulated as $L_{TBP} = \sum_{i=1}^{r} e^{p_i} d_i / \sum_{j=1}^{r} e^{p_j}$, where $p_i$ symbolizes the probability of transitioning from location $a$ to location $b_i$, and $d_i$ represents the cumulative length of the paths that have been traversed repetitively by the agent in the course of navigating from $a$ to $b_i$.

To evaluate the effectiveness of our proposed strategy, we conduct experiments on three datasets: REVERIE, SOON, and R2R. The REVERIE and SOON datasets provide object annotations, while the R2R dataset lacks object annotations. We use evaluation metrics such as Trajectory Length (TL), Navigation Error (NE), Success Rate (SR), Oracle SR (OSR), SPL, Remote Grounding Success (RGS), and RGSPL to assess both efficiency and effectiveness.

Our experiments demonstrate that the inclusion of object relationships significantly enhances the agent's success rates in navigation. However, this also leads to an increase in the trajectory length, resulting in no pronounced improvement in metrics such as SPL and RGSPL. Upon integrating the TBP loss function, we observe a significant reduction in the agent's revisits to the same location, leading to a more efficient task completion and clear improvements in metrics such as TL and SPL.

The results of our method on the REVERIE and SOON datasets show superior performance across most metrics. On the REVERIE dataset, our method achieves notable improvements over the baseline: 4.64% on SR, 4.10% on SPL, 3.29% on RGS, and 2.34% on RGSPL. On the SOON dataset, our method also manifests exceptional performance, surpassing the current state-of-the-art.

We also conduct an ablation study to explore the effects of the TOR and SOR modules on the agent's navigation skills. Both modules notably enhance the navigation performance, with the TOR module contributing more significantly. When both modules are employed in tandem, the navigational prowess of the agent is further amplified.

Furthermore, we investigate the impact of penalizing the agent's repetitive visiting behavior during inference. Our findings indicate that such penalties during inference do not enhance the agent's navigational performance, as they prevent the agent from correcting its navigational errors.

In conclusion, our proposed strategy effectively balances the exploration and exploitation trade-off in vision-and-language navigation by modifying the training regime and loss function. The TBP loss function successfully prevents redundant exploration, enhancing navigational efficiency. Our approach is robust to variations in the navigation environment and task complexity, and the results demonstrate a clear improvement in navigation efficiency.",7ececdb905060007,0477361a6455de7e,cs,cs.CV,2403.15691
"You are evaluating the xTern ISA extension for its feasibility and effectiveness in a real-world edge AI system. The system is based on a RISC-V core and is implemented in a 22nm FDX process. You need to assess the implementation overhead, power consumption, and end-to-end performance of the xTern extension. Propose a comprehensive evaluation plan that includes backend layout, post-layout simulations, and end-to-end benchmark applications to test the xTern extension's impact on the system's area, timing, power, and inference efficiency.","['The evaluation plan includes a full backend layout in a 22nm FDX process.'
 'Post-layout simulations are used to assess the power consumption of the xTern-enabled system.'
 'The evaluation plan includes end-to-end benchmark applications to test inference efficiency.'
 'The area overhead of the xTern extension is evaluated at both the core and cluster levels.'
 'The timing impact of the xTern extension is assessed to ensure no degradation.'
 'The end-to-end benchmark applications are representative of real-world edge AI tasks.'
 'The evaluation plan assesses the throughput and energy efficiency of TNN inference.'
 'The comparison with a baseline system (without xTern) is included in the evaluation.'
 'The evaluation considers the impact on standard cell density.'
 ""The assessment includes the xTern extension's effect on the trade-off between inference latency/energy and accuracy.""]","To evaluate the xTern ISA extension for its feasibility and effectiveness in a real-world edge AI system, we will follow a comprehensive research plan. The system is based on a RISC-V core and is implemented in a 22nm FDX process.

First, we will synthesize the 8-core PULP cluster in the GlobalFoundries 22 nm FDX process using Synopsys Design Compiler 2019.3, constraining the core clock to a period t_clk = 1.5 ns. We will then perform a full backend layout using Cadence Innovus 21.13, optimizing for two supply voltages, V_DD = 0.72 V (HV, max. throughput) and V_DD = 0.65 V (LV, max. efficiency). The achieved frequencies will be used to assess the timing impact of the xTern extension.

To evaluate the implementation overhead of xTern, we will compare the silicon area and timing of the 8-core cluster implementing xTern to an identically parametrized baseline cluster implementing only the XpulpV2 and XpulpNN extensions. We will report the standard cell areas A_{core,clus} after synthesis, the achieved operating frequency, and the power consumption. This comparison will be done at both the core and cluster levels to assess the area overhead and ensure no timing degradation.

Post-layout simulations will be used to assess the power consumption of the xTern-enabled system. We will simulate the full system using the post-layout netlists of the two cluster implementations to collect value change dump (VCD) files, which will be used to estimate the power consumption in Innovus. This will provide an accurate assessment of the power consumption during relevant workloads, such as 2-bit convolution on the baseline system and ternary convolution on the xTern system.

To evaluate the performance and efficiency of the xTern hardware and software stack, we will conduct detailed performance and energy efficiency evaluations. We will run performance evaluations on an FPGA port of the complete system, generated from the same SystemVerilog RTL code as the physical implementation. The throughput of ternary convolutions using our optimized kernels will be compared to that of 2-bit convolutions using PULP-NN kernels on the baseline system.

We will also evaluate the xTern extension's impact on end-to-end benchmark applications. We will consider two benchmark tasks: 11-class gesture recognition on DVS data from the DVS128 dataset and image classification on the CIFAR-10 dataset. On both tasks, we will compare optimized 2-bit QNNs and TNNs mapped to the xTern system using our deployment pipeline. The evaluation will assess the trade-off between inference latency/energy and accuracy, using metrics such as inference latency, energy consumption, and validation accuracy.

The end-to-end benchmark applications are representative of real-world edge AI tasks, and the evaluation will provide a clear understanding of the xTern extension's benefits and limitations. By comparing the xTern-enabled system to the baseline system, we will be able to assess the effectiveness of the xTern extension in improving the efficiency and performance of TNN inference on RISC-V cores.

Overall, our evaluation plan is comprehensive and covers various aspects of the system's performance, including area overhead, timing impact, power consumption, throughput, and energy efficiency. The use of post-layout netlists for power estimation and the assessment of the xTern extension's effect on standard cell density will provide a thorough understanding of the implementation overhead. The evaluation will be designed to provide a clear understanding of the xTern extension's benefits and limitations, enabling the deployment of TNNs on RISC-V-based ultra-low-power edge AI platforms.",c620deeff0e2252d,23816059bb91a6a6,cs,cs.AR,2405.19065
"You are developing a language agent that can perform multi-step decision-making tasks in a textual environment. The agent uses a ReAct-style framework, where it reasons about the current state and then takes an action. However, the agent's performance is limited by the quality of the training data, which is currently annotated by humans. Your goal is to develop a method to autonomously annotate the training data without human effort, while maintaining the diversity of the trajectories. The environment automatically returns observations and rewards with action inputs, and you have access to a large language model that can be fine-tuned for specific tasks. How would you design a system to autonomously annotate the training data for the language agent?","['The proposed method should not rely on human annotation or diverse prompting frameworks.'
 'The method should leverage the in-context language ability of a large language model.'
 'The method should be able to annotate diverse trajectories without human effort.'
 'The annotation process should be automated and scalable.'
 'The method should be compatible with the ReAct-style framework used by the language agent.'
 'The annotation should include textual rationales for the actions taken by the agent.'
 ""The annotation should be based on the environmental observations and the agent's actions.""
 'The method should be able to provide a reason for the sampled action a posteriori.'
 'The synergy between the annotation method and the ReAct-style agent should facilitate self-training.'
 'The overall framework should enable a closed loop for the self-improvement of the language agent.']","To develop a method for autonomously annotating training data for a language agent that performs multi-step decision-making tasks in a textual environment, we will implement the A3T framework. This framework enables the Autonomous Annotation of Agent Trajectories in the style of ReAct.

### 1. Overview of A3T Framework

The A3T framework consists of two main components: 
1. Autonomous trajectory annotation with an ActRe agent.
2. Contrastive self-training process.

### 2. Autonomous Trajectory Annotation with ActRe

To annotate diverse trajectories without human effort, we will utilize an ActRe prompting agent. The ActRe agent inverts the causality of ReAct: while ReAct conditions the external action with a reason a priori, ActRe explains the reason a posteriori for an external action.

Here's how it works:
- The ReAct-style agent randomly samples an external action from the action space at an arbitrary step.
- The ActRe agent is queried with the sampled action to obtain its textual rationale.
- The synthetic reason is then prepended to the sampled action to compose a new ReAct-style trajectory.

The trajectory of a ReAct-style agent is represented as ..., o_t, RS_t, EA_t, o_(t+1), RS_(t+1), EA_(t+1), ..., where o_t is the environmental observation, RS_t is the internal reasoning, and EA_t is the external action at the t-th step. The ActRe agent has a synchronized trajectory but with the order of intermediate reasoning and actions inverted: ..., o_t, EA_t, RS_t, o_(t+1), EA_(t+1), RS_(t+1), ....

When the ReAct-style agent samples a different external action EA_f_(t+1) at step t+1, the ActRe agent is used to synthesize the corresponding internal reasoning RS_f_(t+1) by querying: ..., o_t, EA_t, RS_t, o_(t+1), EA_f_(t+1) → RS_f_(t+1).

### 3. Contrastive Self-Training

The gathered trajectories are used for contrastive self-training. The objective is to maximize the policy gradient estimation given by Eq. (1), which involves both successful and failed trajectories.

For a trajectory τ with T steps, the objective is ∇_θ J(θ) = 1/M ∑_(m=1)^M R(τ_m) ∇_θ log p_θ(τ_m), where R(τ_m) is the reward of the trajectory τ_m, and p_θ is the LLM with parameters θ to be fine-tuned.

To structure the objective for contrastive self-training, we consider K successful trajectories τ_s^1, τ_s^2, ..., τ_s^K and a failed trajectory τ_f in the same task. The objective is then modified to contrast between successful and failed trajectories.

In implementation, we binarize the reward of the failed trajectories with R(τ_f) = -1 and ensure K > 1 by collecting multiple successful trajectories via diverse exploration.

### 4. Experimental Setup

We will validate the A3T framework on two benchmarks: AlfWorld and WebShop. 
- For AlfWorld, we will use 600 out of 3,553 training tasks for training and 60 for validation. 
- For WebShop, we will use 2,300 out of 11,587 tasks for training and 400 for validation.

We will use the open-sourced Mistral-7B-Instruct-v0.2 with QLoRA fine-tuning for the training experiments. The ActRe prompting will be implemented using gpt-3.5-turbo-instruct-0914.

### 5. Implementation Details

- The probability of sampling a novel action is set to p = 0.5.
- In AlfWorld, 40 trajectories are composed for each training task failed by the policy agent.
- In WebShop, the policy agent first collects 3 trajectories, and then terminates when a successful trajectory is gathered or the total number of annotated trajectories reaches 20 for a single task.

The A3T framework addresses the need for autonomous annotation of agent trajectories by leveraging the in-context language ability of a large language model, specifically through the ActRe prompting agent. This approach enables the annotation of diverse trajectories without human effort and is compatible with the ReAct-style framework. The contrastive self-training process facilitates self-improvement of the language agent, forming a closed loop.

By following the A3T framework and its implementation details, we can develop a method that autonomously annotates training data for the language agent, maintaining the diversity of the trajectories and improving the agent's performance over time.",1c64487bc4c54ff4,de9fe2795222e17f,cs,cs.AI,2403.14589
"You are working on a time series forecasting task and want to improve the decomposition of time series data into its fundamental components. Traditional decomposition methods often struggle to accurately separate clear trends and seasonal components, especially when the data contains substantial noise or nonlinear components. Your goal is to develop a novel decomposition approach that can more precisely extract and identify the fundamental components of time series data.","['The response proposes decomposing the embedding vector of time series data rather than the original sequence.'
 'The response explains how decomposing the embedding vector can help eliminate the interference of random fluctuations on analysis and forecasting.'
 'The response discusses the use of a simple moving average technique for decomposing the latent vector.'
 'The response highlights how the decomposition approach separates the latent vector into smooth components and noisy residuals.'
 'The response explains how the separate processing of smooth components and noisy residuals can improve forecasting performance.'
 'The response outlines a plan to implement the proposed decomposition approach in a time series forecasting model.'
 'The response considers the importance of evaluating the performance of the proposed decomposition approach on various time series datasets.'
 'The response acknowledges the need to compare the performance of the proposed decomposition approach with traditional decomposition methods.'
 'The response outlines a plan to investigate the robustness of the proposed decomposition approach to different types of noise and outliers.'
 'The response discusses the importance of analyzing the impact of different decomposition techniques on the performance of the model.']","To address the task of improving the decomposition of time series data into its fundamental components, we develop a novel decomposition approach based on the insights gained from the PatchMLP model. The goal is to more precisely extract and identify the underlying components of time series data, which is crucial for enhancing predictive accuracy in time series forecasting tasks.

First, we employ a Multi-Scale Patch Embedding (MPE) layer to embed the multivariate time series into a latent space. This step involves dividing the time series into non-overlapping patches of various scales to capture local information and multiscale temporal relationships. The use of patches helps in providing a local view of the time series, thereby enhancing the representation of local information within the sequence.

Next, we introduce a Feature Decomposition layer that decomposes the embedded latent vector into smooth components and noisy residuals using a simple moving average technique. By applying Average Pooling (AvgPool) to the embedded vector, we extract the smooth components, and the residuals are obtained by subtracting these smooth components from the original embedded vector. This decomposition is performed on the embedding vector rather than the original sequence to eliminate the interference of random fluctuations on analysis and forecasting.

The decomposed smooth components and noisy residuals are then processed separately through a Multi-Layer Perceptron (MLP) layer. The MLP layer alternately applies MLPs within Intra-Variable (time domain) and Inter-Variable (feature domain) to enhance predictive performance. The Intra-Variable MLP focuses on identifying time-correlated patterns within time series, while the Inter-Variable MLP models the mutual influences among multivariate time series variables. The use of a dot product mechanism in the Inter-Variable MLP enhances the cross-variable interactivity.

To evaluate the performance of the proposed decomposition approach, we conduct extensive experiments on multiple real-world datasets, including Solar Energy, Weather, Traffic, Electricity, and four ETT datasets. We compare the performance of our model, PatchMLP, with nine widely acknowledged state-of-the-art forecasting models, including Transformer-based models, CNN-based models, and MLP-based models. The evaluation metrics used are Mean Squared Error (MSE) and Mean Absolute Error (MAE).

We also perform an ablation study to investigate the impact of each module of PatchMLP on performance. This involves replacing or removing components such as the decomposition module, MPE, and dot product in the MLP among variables, and evaluating the resulting performance.

Furthermore, we analyze the sensitivity of PatchMLP to hyperparameters such as learning rate, the number of blocks in the MLP, and the hidden dimension of the embedding. This helps in understanding the robustness of the model to different hyperparameter settings.

By following this research plan, we aim to demonstrate the efficacy of the proposed decomposition approach in enhancing predictive accuracy for time series forecasting tasks. The results of this study will provide insights into the effectiveness of decomposing the embedding vector, the importance of cross-variable interactions, and the potential benefits of using a simple yet effective model like PatchMLP for long-term time series forecasting.",7789b0a6e3901e69,b55d022a71c7bde8,cs,cs.LG,2405.13575
"You are required to design a novel communication game that facilitates emergent communication (EmCom) between two agents observing the same object from different perspectives. The game should leverage the principles of self-supervised learning (SSL) and collective predictive coding (CPC) to align the internal representations of the agents and develop a shared emergent language. You have been provided with a document that discusses the SimSiam+VAE model, which integrates a Variational Autoencoder (VAE) into the SimSiam framework for SSL. Your task is to extend the SimSiam+VAE model into a structured communication framework that enables EmCom between agents. You need to describe the architecture of the agents, the communication process, and the loss function used to train the agents.","['The proposed communication game is based on the SimSiam+VAE model and utilizes its discriminative and generative processes.'
 'Each agent in the game operates a SimSiam+VAE network, with the backbone and projector serving as a perception module.'
 'The VAE predictor in the SimSiam+VAE network acts as a language coder, responsible for generating and decoding messages.'
 'The agents exchange messages to align their internal representations and develop a shared emergent language.'
 'The communication process involves the agents taking turns as speaker and listener, with the speaker generating a message from its observation.'
 'The listener decodes the received message and compares it with its own internal representation to calculate the loss.'
 ""The loss function used to train the agents is based on the similarity between the decoded message and the listener's internal representation.""
 ""The loss function includes a regularization term to regularize the listener's latent space.""
 'The communication game is designed to facilitate mutual understanding between agents through iterative exchanges.'
 'The emergent language developed through the proposed game is evaluated using metrics like Topographical Similarity (TopSim).']","To address the research scenario, we design a novel communication game called the SimSiam Naming Game (SSNG) that facilitates emergent communication (EmCom) between two agents observing the same object from different perspectives. The SSNG leverages the principles of self-supervised learning (SSL) and collective predictive coding (CPC) to align the internal representations of the agents and develop a shared emergent language.

### Architecture of the Agents
Each agent in the SSNG operates a separate SimSiam+VAE network. The SimSiam+VAE model integrates a Variational Autoencoder (VAE) into the predictor of the SimSiam network, enhancing representation learning and capturing uncertainty. The backbone and projector of the SimSiam+VAE network serve as a perception module, transforming the observations into internal representations. The VAE predictor acts as a language coder, responsible for generating and decoding messages.

### Communication Process
The communication process in the SSNG involves the agents taking turns as speaker and listener. The speaker generates a message from its observation using the language coder (VAE predictor), and the listener decodes the received message and compares it with its own internal representation to calculate the loss. The loss function used to train the agents is based on the similarity between the decoded message and the listener's internal representation, along with a regularization term to regularize the listener's latent space.

### Loss Function
The objective function for the listener is given by:
\[ J_{Li} \approx [h_{Li}(w_{Sp})]^\top f_{Li}(x_{Li}) - \beta D_{KL}(q_{Li}(w_{Li}|z_{Li}, x_{Li})\|p(w_{Li})) \]
where $h_{Li}(w_{Sp})$ is the decoded representation obtained from the received message $w_{Sp}$, $f_{Li}(x_{Li})$ is the listener's internal representation, and $D_{KL}(q_{Li}(w_{Li}|z_{Li}, x_{Li})\|p(w_{Li}))$ is the KL divergence term that regularizes the listener's latent space.

### Training the Agents
The agents update their model parameters based on the calculated loss to refine their understanding. This process is repeated iteratively, with the roles of speaker and listener being swapped after each interaction. Through this iterative exchange, the agents align their internal representations and develop a shared emergent language.

### Evaluation
To evaluate the SSNG, we conduct two experiments. First, we assess the performance of SimSiam+VAE in representation learning by measuring classification accuracy on datasets like FashionMNIST and CIFAR-10. Second, we evaluate the SSNG's capability in EmCom using the dSprites dataset, measuring the compositional generalization of the emergent language by applying Topographical Similarity (TopSim) to unseen data.

### Comparison with Existing Models
We compare the SSNG with existing EmCom frameworks, such as the referential game and Metropolis-Hastings naming game. The SSNG demonstrates comparable or slightly better performance than these models in EmCom tasks, indicating its potential as an alternative approach for facilitating EmCom.

### Justification and Details
The SSNG is grounded in the principles of CPC and SSL, utilizing the discriminative process of SimSiam and the generative Bayesian perspective of the VI interpretation to align agents' internal representations. This approach enables the development of a shared emergent language between agents observing the same object from different viewpoints. The use of SimSiam+VAE as the underlying model allows for the integration of representation learning and EmCom, providing a unified framework for both tasks.

By following this research plan, we aim to demonstrate the effectiveness of the SSNG in facilitating EmCom and its potential applications in developing more sophisticated multi-agent communication systems.",8cbb7abe242a14cd,ad46f74bbb1d768d,cs,cs.CL,2410.21803
"You are working on an AI-powered guide for a social VR platform that assists blind and low vision (BLV) users. The guide uses GPT-4 to interpret user requests and respond accordingly. However, you are facing challenges in getting GPT-4 to accurately understand the user's location and surroundings in the VR environment. What techniques or additional information would you provide to GPT-4 to improve its understanding of the user's context, and how would you integrate this information into the guide's functionality?","[""The solution involves using a bird's eye view camera to provide additional context to GPT-4.""
 ""The guide is able to use the additional context to improve its understanding of the user's location.""
 'The solution involves re-contextualizing the prompt to GPT-4 to include the additional context.'
 'The guide is able to accurately identify objects and their locations in the VR environment.'
 'The guide is able to recognize when the user has moved to a different location in the VR environment.'
 'The solution involves updating the additional context in real-time or at regular intervals.'
 'The solution is designed to be flexible and adaptable to different VR environments and scenarios.'
 ""The solution considers the potential limitations and challenges of using a bird's eye view camera.""
 ""The guide's functionality is designed to be intuitive and easy to use for BLV users.""
 ""The solution involves using the additional context to inform the guide's responses to user queries.""]","To improve GPT-4's understanding of the user's location and surroundings in the VR environment, we will provide additional context through a bird's eye view camera. This camera will capture a different perspective of the VR environment, allowing GPT-4 to better understand the user's location and the objects around them.

The bird's eye view camera will be implemented in Unity, alongside the existing user perspective camera. Both cameras will capture images of the VR environment at regular intervals, every ten seconds, to update the user's location. The images from both cameras will be sent to GPT-4, which will be prompted to ""imagine as though a player in the game asked"" the user's query, using both the user perspective and bird's eye view images.

The prompt will be re-contextualized to include the additional context from the bird's eye view camera, stating that ""the two photos you are seeing are two views of a video game. One of these photos is the bird's eye view of the entire scene. The other photo is the player's current perspective and what they are currently looking at in the scene."" This will enable GPT-4 to more accurately identify objects and their locations in the VR environment.

To further improve the guide's understanding of the user's context, we will provide GPT-4 with a list of major objects in the environment, along with their descriptions. This will help GPT-4 identify the target object and action requested by the user, such as navigating to a specific object or adding an audio beacon.

The guide's ability to understand the user's context will be evaluated through testing and feedback from BLV users. The testing will involve assessing the guide's performance in different VR environments and scenarios, and gathering feedback on its accuracy and usability.

The solution is designed to be flexible and adaptable to different VR environments and scenarios. The use of a bird's eye view camera and re-contextualized prompts will allow the guide to improve its overall performance and accuracy. The guide's functionality is designed to be intuitive and easy to use for BLV users, with features such as audio beacons and navigation assistance.

The additional context from the bird's eye view camera will inform the guide's responses to user queries, enabling it to provide more accurate and relevant information. The guide's overall design and functionality are informed by the needs and preferences of BLV users, as identified through prior research and testing.

By providing additional context through a bird's eye view camera and re-contextualized prompts, we aim to improve GPT-4's understanding of the user's location and surroundings in the VR environment, and enhance the overall performance and accuracy of the AI guide.",ce3db09e8c97e1dd,d6e5321549827c63,cs,cs.HC,2410.14058
"You are evaluating the performance of rerankers in a Retrieval Augmented Generation (RAG) system for Open-Domain Question Answering (ODQA). You've observed that Large Language Models (LLMs) often produce tied ranking scores, making it challenging to assess their performance using traditional metrics like Mean Reciprocal Rank (MRR) and Mean Hits@10 (MHits@10). Your task is to develop new evaluation metrics that can effectively handle tied ranking scores and provide a more accurate assessment of reranker performance. Propose novel metrics that address this issue and explain how they can be applied to evaluate rerankers in ODQA.","['The proposed metrics are designed to handle tied ranking scores produced by LLMs.'
 'The metrics are variants of existing metrics such as MRR and MHits@10.'
 'MTRR averages the optimistic and pessimistic ranks for tied documents.'
 'TMHits@10 diminishes the optimistic effect by dividing the hit-number by the number of ties.'
 'The metrics are designed to be applicable to a wide range of ranking scenarios, including those with multiple ties.'
 'The proposed metrics reduce to traditional metrics (MRR and MHits@10) when there are no ties in the ranking scores.'
 'The metrics are applicable to evaluating the performance of different rerankers, including those based on LLMs.'
 'The metrics are robust to variations in the number of ties and the distribution of ranking scores.'
 'The proposed metrics are based on a clear understanding of the limitations of traditional evaluation metrics.'
 'The metrics are designed to be computationally efficient and scalable to large datasets.']","To address the challenge of evaluating reranker performance in a Retrieval Augmented Generation (RAG) system for Open-Domain Question Answering (ODQA) when Large Language Models (LLMs) produce tied ranking scores, we propose a research plan that involves developing new evaluation metrics.

First, we identify the limitations of traditional metrics such as Mean Reciprocal Rank (MRR) and Mean Hits@10 (MHits@10) in handling tied ranking scores. These metrics are commonly used to assess reranker performance but fail to account for ties, which can lead to overly optimistic assessments.

To address this issue, we introduce two novel metrics: Mean Tied Reciprocal Ranking (MTRR) and Tied Mean Hits@10 (TMHits@10). MTRR is designed to handle tied ranking scores by averaging the optimistic and pessimistic ranks for tied documents. For a document with a tied rank, the optimistic rank is the best possible rank it could achieve, while the pessimistic rank is the worst possible rank. By averaging these two ranks, MTRR provides a more nuanced assessment of reranker performance.

TMHits@10, on the other hand, diminishes the optimistic effect of tied rankings by dividing the hit-number by the number of ties. This metric is particularly useful when evaluating the performance of rerankers in retrieving relevant documents within the top 10 results.

Both MTRR and TMHits@10 are designed to be applicable to a wide range of ranking scenarios, including those with multiple ties. They reduce to traditional metrics (MRR and MHits@10) when there are no ties in the ranking scores, ensuring consistency and comparability across different evaluation settings.

To evaluate the effectiveness of these new metrics, we will conduct experiments on standard ODQA datasets such as Natural Questions (NQ) and TriviaQA (TQA). These datasets provide a robust testing ground for assessing reranker performance and will help us understand how MTRR and TMHits@10 perform in different scenarios.

We will compare the performance of our proposed G-RAG model, which leverages document graphs and Abstract Meaning Representation (AMR) information, with other reranking models, including those based on LLMs like PaLM 2. By using MTRR and TMHits@10, we aim to provide a more accurate assessment of reranker performance, especially in cases where LLMs produce tied ranking scores.

The proposed metrics are designed to be easy to interpret and provide a clear understanding of reranker performance. They will enable us to compare the performance of different reranking models and evaluate their robustness to variations in the number of ties and the distribution of ranking scores.

By following this research plan, we aim to develop a comprehensive understanding of how to effectively evaluate reranker performance in RAG systems for ODQA, even when faced with the challenge of tied ranking scores produced by LLMs. Our proposed metrics, MTRR and TMHits@10, will provide a more accurate and nuanced assessment of reranker performance, facilitating the development of more effective RAG systems.",030cabe74665bf5f,9098f936777581c6,cs,cs.CL,2405.18414
